/* AUTOGENERATED FILE! DO NOT EDIT */

// This autogenerated skeleton file illustrates how to build a server.
// You should copy it to another filename to avoid overwriting it.

#include "sai_rpc.h"
#include <thrift/protocol/TBinaryProtocol.h>
#include <thrift/server/TSimpleServer.h>
#include <thrift/transport/TServerSocket.h>
#include <thrift/transport/TBufferTransports.h>

using namespace ::apache::thrift;
using namespace ::apache::thrift::protocol;
using namespace ::apache::thrift::transport;
using namespace ::apache::thrift::server;

using namespace  ::sai;

#ifdef __cplusplus
extern "C" {
#endif
#include <sai.h>
#ifdef __cplusplus
}
#endif

extern sai_object_id_t switch_id;
sai_object_id_t switch_id;
extern sai_object_id_t gSwitchId;



void sai_thrift_parse_buffer(const std::string &thrift_buffer,
                             void *buffer) {
  /* not supported yet */
}


  // acl API helper functions

void sai_thrift_parse_acl_counter_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
                                             sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
      return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(static_cast<sai_object_type_t>(SAI_OBJECT_TYPE_ACL_COUNTER), attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_acl_counter_attributes(sai_attribute_t *attr_list,
                                               uint32_t attr_count,
                                               std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(static_cast<sai_object_type_t>(SAI_OBJECT_TYPE_ACL_COUNTER), attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

void sai_thrift_parse_acl_entry_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
                                           sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
      return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(static_cast<sai_object_type_t>(SAI_OBJECT_TYPE_ACL_ENTRY), attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_acl_entry_attributes(sai_attribute_t *attr_list,
                                             uint32_t attr_count,
                                             std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(static_cast<sai_object_type_t>(SAI_OBJECT_TYPE_ACL_ENTRY), attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

void sai_thrift_parse_acl_range_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
                                           sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
      return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(static_cast<sai_object_type_t>(SAI_OBJECT_TYPE_ACL_RANGE), attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_acl_range_attributes(sai_attribute_t *attr_list,
                                             uint32_t attr_count,
                                             std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(static_cast<sai_object_type_t>(SAI_OBJECT_TYPE_ACL_RANGE), attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

void sai_thrift_parse_acl_table_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
                                           sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
      return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(static_cast<sai_object_type_t>(SAI_OBJECT_TYPE_ACL_TABLE), attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_acl_table_attributes(sai_attribute_t *attr_list,
                                             uint32_t attr_count,
                                             std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(static_cast<sai_object_type_t>(SAI_OBJECT_TYPE_ACL_TABLE), attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

void sai_thrift_parse_acl_table_chain_group_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
                                                       sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
      return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(static_cast<sai_object_type_t>(SAI_OBJECT_TYPE_ACL_TABLE_CHAIN_GROUP), attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_acl_table_chain_group_attributes(sai_attribute_t *attr_list,
                                                         uint32_t attr_count,
                                                         std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(static_cast<sai_object_type_t>(SAI_OBJECT_TYPE_ACL_TABLE_CHAIN_GROUP), attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

void sai_thrift_parse_acl_table_group_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
                                                 sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
      return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(static_cast<sai_object_type_t>(SAI_OBJECT_TYPE_ACL_TABLE_GROUP), attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_acl_table_group_attributes(sai_attribute_t *attr_list,
                                                   uint32_t attr_count,
                                                   std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(static_cast<sai_object_type_t>(SAI_OBJECT_TYPE_ACL_TABLE_GROUP), attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

void sai_thrift_parse_acl_table_group_member_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
                                                        sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
      return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(static_cast<sai_object_type_t>(SAI_OBJECT_TYPE_ACL_TABLE_GROUP_MEMBER), attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_acl_table_group_member_attributes(sai_attribute_t *attr_list,
                                                          uint32_t attr_count,
                                                          std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(static_cast<sai_object_type_t>(SAI_OBJECT_TYPE_ACL_TABLE_GROUP_MEMBER), attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

  // ars API helper functions

void sai_thrift_parse_ars_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
                                     sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
      return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(static_cast<sai_object_type_t>(SAI_OBJECT_TYPE_ARS), attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_ars_attributes(sai_attribute_t *attr_list,
                                       uint32_t attr_count,
                                       std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(static_cast<sai_object_type_t>(SAI_OBJECT_TYPE_ARS), attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

  // arsprofile API helper functions

void sai_thrift_parse_ars_profile_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
                                             sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
      return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(static_cast<sai_object_type_t>(SAI_OBJECT_TYPE_ARS_PROFILE), attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_ars_profile_attributes(sai_attribute_t *attr_list,
                                               uint32_t attr_count,
                                               std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(static_cast<sai_object_type_t>(SAI_OBJECT_TYPE_ARS_PROFILE), attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

  // bfd API helper functions

void sai_thrift_parse_bfd_session_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
                                             sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
      return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(static_cast<sai_object_type_t>(SAI_OBJECT_TYPE_BFD_SESSION), attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_bfd_session_attributes(sai_attribute_t *attr_list,
                                               uint32_t attr_count,
                                               std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(static_cast<sai_object_type_t>(SAI_OBJECT_TYPE_BFD_SESSION), attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

void sai_thrift_parse_bfd_session_state_notification(const sai_thrift_bfd_session_state_notification_t &thrift_bfd_session_state_notification,
                                                     sai_bfd_session_state_notification_t *bfd_session_state_notification) {
  bfd_session_state_notification->bfd_session_id = thrift_bfd_session_state_notification.bfd_session_id;
#ifdef UNSUPPORTED /* complex struct members are not supported yet */
  bfd_session_state_notification->session_state = thrift_bfd_session_state_notification.session_state;
#endif
}

  // bridge API helper functions

void sai_thrift_parse_bridge_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
                                        sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
      return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(static_cast<sai_object_type_t>(SAI_OBJECT_TYPE_BRIDGE), attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_bridge_attributes(sai_attribute_t *attr_list,
                                          uint32_t attr_count,
                                          std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(static_cast<sai_object_type_t>(SAI_OBJECT_TYPE_BRIDGE), attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

void sai_thrift_parse_bridge_port_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
                                             sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
      return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(static_cast<sai_object_type_t>(SAI_OBJECT_TYPE_BRIDGE_PORT), attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_bridge_port_attributes(sai_attribute_t *attr_list,
                                               uint32_t attr_count,
                                               std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(static_cast<sai_object_type_t>(SAI_OBJECT_TYPE_BRIDGE_PORT), attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

  // buffer API helper functions

void sai_thrift_parse_buffer_pool_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
                                             sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
      return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(static_cast<sai_object_type_t>(SAI_OBJECT_TYPE_BUFFER_POOL), attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_buffer_pool_attributes(sai_attribute_t *attr_list,
                                               uint32_t attr_count,
                                               std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(static_cast<sai_object_type_t>(SAI_OBJECT_TYPE_BUFFER_POOL), attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

void sai_thrift_parse_buffer_profile_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
                                                sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
      return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(static_cast<sai_object_type_t>(SAI_OBJECT_TYPE_BUFFER_PROFILE), attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_buffer_profile_attributes(sai_attribute_t *attr_list,
                                                  uint32_t attr_count,
                                                  std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(static_cast<sai_object_type_t>(SAI_OBJECT_TYPE_BUFFER_PROFILE), attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

void sai_thrift_parse_ingress_priority_group_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
                                                        sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
      return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(static_cast<sai_object_type_t>(SAI_OBJECT_TYPE_INGRESS_PRIORITY_GROUP), attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_ingress_priority_group_attributes(sai_attribute_t *attr_list,
                                                          uint32_t attr_count,
                                                          std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(static_cast<sai_object_type_t>(SAI_OBJECT_TYPE_INGRESS_PRIORITY_GROUP), attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

  // counter API helper functions

void sai_thrift_parse_counter_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
                                         sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
      return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(static_cast<sai_object_type_t>(SAI_OBJECT_TYPE_COUNTER), attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_counter_attributes(sai_attribute_t *attr_list,
                                           uint32_t attr_count,
                                           std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(static_cast<sai_object_type_t>(SAI_OBJECT_TYPE_COUNTER), attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

  // debugcounter API helper functions

void sai_thrift_parse_debug_counter_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
                                               sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
      return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(static_cast<sai_object_type_t>(SAI_OBJECT_TYPE_DEBUG_COUNTER), attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_debug_counter_attributes(sai_attribute_t *attr_list,
                                                 uint32_t attr_count,
                                                 std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(static_cast<sai_object_type_t>(SAI_OBJECT_TYPE_DEBUG_COUNTER), attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

  // dtel API helper functions

void sai_thrift_parse_dtel_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
                                      sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
      return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(static_cast<sai_object_type_t>(SAI_OBJECT_TYPE_DTEL), attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_dtel_attributes(sai_attribute_t *attr_list,
                                        uint32_t attr_count,
                                        std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(static_cast<sai_object_type_t>(SAI_OBJECT_TYPE_DTEL), attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

void sai_thrift_parse_dtel_event_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
                                            sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
      return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(static_cast<sai_object_type_t>(SAI_OBJECT_TYPE_DTEL_EVENT), attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_dtel_event_attributes(sai_attribute_t *attr_list,
                                              uint32_t attr_count,
                                              std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(static_cast<sai_object_type_t>(SAI_OBJECT_TYPE_DTEL_EVENT), attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

void sai_thrift_parse_dtel_int_session_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
                                                  sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
      return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(static_cast<sai_object_type_t>(SAI_OBJECT_TYPE_DTEL_INT_SESSION), attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_dtel_int_session_attributes(sai_attribute_t *attr_list,
                                                    uint32_t attr_count,
                                                    std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(static_cast<sai_object_type_t>(SAI_OBJECT_TYPE_DTEL_INT_SESSION), attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

void sai_thrift_parse_dtel_queue_report_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
                                                   sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
      return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(static_cast<sai_object_type_t>(SAI_OBJECT_TYPE_DTEL_QUEUE_REPORT), attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_dtel_queue_report_attributes(sai_attribute_t *attr_list,
                                                     uint32_t attr_count,
                                                     std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(static_cast<sai_object_type_t>(SAI_OBJECT_TYPE_DTEL_QUEUE_REPORT), attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

void sai_thrift_parse_dtel_report_session_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
                                                     sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
      return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(static_cast<sai_object_type_t>(SAI_OBJECT_TYPE_DTEL_REPORT_SESSION), attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_dtel_report_session_attributes(sai_attribute_t *attr_list,
                                                       uint32_t attr_count,
                                                       std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(static_cast<sai_object_type_t>(SAI_OBJECT_TYPE_DTEL_REPORT_SESSION), attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

  // fdb API helper functions

void sai_thrift_parse_fdb_entry_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
                                           sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
      return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(static_cast<sai_object_type_t>(SAI_OBJECT_TYPE_FDB_ENTRY), attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_fdb_entry_attributes(sai_attribute_t *attr_list,
                                             uint32_t attr_count,
                                             std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(static_cast<sai_object_type_t>(SAI_OBJECT_TYPE_FDB_ENTRY), attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

void sai_thrift_parse_fdb_flush_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
                                           sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
      return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(static_cast<sai_object_type_t>(SAI_OBJECT_TYPE_FDB_FLUSH), attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_fdb_flush_attributes(sai_attribute_t *attr_list,
                                             uint32_t attr_count,
                                             std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(static_cast<sai_object_type_t>(SAI_OBJECT_TYPE_FDB_FLUSH), attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

void sai_thrift_parse_fdb_entry(const sai_thrift_fdb_entry_t &thrift_fdb_entry,
                                sai_fdb_entry_t *fdb_entry) {
  fdb_entry->switch_id = thrift_fdb_entry.switch_id;
  // using manual converter
  sai_thrift_mac_t_parse(thrift_fdb_entry.mac_address, &fdb_entry->mac_address);
  fdb_entry->bv_id = thrift_fdb_entry.bv_id;
}

void sai_thrift_parse_fdb_event_notification_data(const sai_thrift_fdb_event_notification_data_t &thrift_fdb_event_notification_data,
                                                  sai_fdb_event_notification_data_t *fdb_event_notification_data) {
#ifdef UNSUPPORTED /* complex struct members are not supported yet */
  fdb_event_notification_data->event_type = thrift_fdb_event_notification_data.event_type;
#endif
#ifdef UNSUPPORTED /* complex struct members are not supported yet */
  fdb_event_notification_data->fdb_entry = thrift_fdb_event_notification_data.fdb_entry;
#endif
  fdb_event_notification_data->attr_count = thrift_fdb_event_notification_data.attr_count;
  fdb_event_notification_data->attr = thrift_fdb_event_notification_data.attr;
}

  // genericprogrammable API helper functions

void sai_thrift_parse_generic_programmable_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
                                                      sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
      return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(static_cast<sai_object_type_t>(SAI_OBJECT_TYPE_GENERIC_PROGRAMMABLE), attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_generic_programmable_attributes(sai_attribute_t *attr_list,
                                                        uint32_t attr_count,
                                                        std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(static_cast<sai_object_type_t>(SAI_OBJECT_TYPE_GENERIC_PROGRAMMABLE), attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

  // hash API helper functions

void sai_thrift_parse_fine_grained_hash_field_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
                                                         sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
      return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(static_cast<sai_object_type_t>(SAI_OBJECT_TYPE_FINE_GRAINED_HASH_FIELD), attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_fine_grained_hash_field_attributes(sai_attribute_t *attr_list,
                                                           uint32_t attr_count,
                                                           std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(static_cast<sai_object_type_t>(SAI_OBJECT_TYPE_FINE_GRAINED_HASH_FIELD), attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

void sai_thrift_parse_hash_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
                                      sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
      return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(static_cast<sai_object_type_t>(SAI_OBJECT_TYPE_HASH), attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_hash_attributes(sai_attribute_t *attr_list,
                                        uint32_t attr_count,
                                        std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(static_cast<sai_object_type_t>(SAI_OBJECT_TYPE_HASH), attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

  // hostif API helper functions

void sai_thrift_parse_hostif_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
                                        sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
      return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(static_cast<sai_object_type_t>(SAI_OBJECT_TYPE_HOSTIF), attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_hostif_attributes(sai_attribute_t *attr_list,
                                          uint32_t attr_count,
                                          std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(static_cast<sai_object_type_t>(SAI_OBJECT_TYPE_HOSTIF), attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

void sai_thrift_parse_hostif_packet_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
                                               sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
      return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(static_cast<sai_object_type_t>(SAI_OBJECT_TYPE_HOSTIF_PACKET), attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_hostif_packet_attributes(sai_attribute_t *attr_list,
                                                 uint32_t attr_count,
                                                 std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(static_cast<sai_object_type_t>(SAI_OBJECT_TYPE_HOSTIF_PACKET), attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

void sai_thrift_parse_hostif_table_entry_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
                                                    sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
      return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(static_cast<sai_object_type_t>(SAI_OBJECT_TYPE_HOSTIF_TABLE_ENTRY), attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_hostif_table_entry_attributes(sai_attribute_t *attr_list,
                                                      uint32_t attr_count,
                                                      std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(static_cast<sai_object_type_t>(SAI_OBJECT_TYPE_HOSTIF_TABLE_ENTRY), attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

void sai_thrift_parse_hostif_trap_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
                                             sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
      return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(static_cast<sai_object_type_t>(SAI_OBJECT_TYPE_HOSTIF_TRAP), attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_hostif_trap_attributes(sai_attribute_t *attr_list,
                                               uint32_t attr_count,
                                               std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(static_cast<sai_object_type_t>(SAI_OBJECT_TYPE_HOSTIF_TRAP), attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

void sai_thrift_parse_hostif_trap_group_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
                                                   sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
      return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(static_cast<sai_object_type_t>(SAI_OBJECT_TYPE_HOSTIF_TRAP_GROUP), attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_hostif_trap_group_attributes(sai_attribute_t *attr_list,
                                                     uint32_t attr_count,
                                                     std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(static_cast<sai_object_type_t>(SAI_OBJECT_TYPE_HOSTIF_TRAP_GROUP), attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

void sai_thrift_parse_hostif_user_defined_trap_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
                                                          sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
      return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(static_cast<sai_object_type_t>(SAI_OBJECT_TYPE_HOSTIF_USER_DEFINED_TRAP), attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_hostif_user_defined_trap_attributes(sai_attribute_t *attr_list,
                                                            uint32_t attr_count,
                                                            std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(static_cast<sai_object_type_t>(SAI_OBJECT_TYPE_HOSTIF_USER_DEFINED_TRAP), attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

  // ipmc API helper functions

void sai_thrift_parse_ipmc_entry_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
                                            sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
      return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(static_cast<sai_object_type_t>(SAI_OBJECT_TYPE_IPMC_ENTRY), attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_ipmc_entry_attributes(sai_attribute_t *attr_list,
                                              uint32_t attr_count,
                                              std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(static_cast<sai_object_type_t>(SAI_OBJECT_TYPE_IPMC_ENTRY), attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

void sai_thrift_parse_ipmc_entry(const sai_thrift_ipmc_entry_t &thrift_ipmc_entry,
                                 sai_ipmc_entry_t *ipmc_entry) {
  ipmc_entry->switch_id = thrift_ipmc_entry.switch_id;
  ipmc_entry->vr_id = thrift_ipmc_entry.vr_id;
#ifdef UNSUPPORTED /* complex struct members are not supported yet */
  ipmc_entry->type = thrift_ipmc_entry.type;
#endif
  // using manual converter
  sai_thrift_ip_address_t_parse(thrift_ipmc_entry.destination, &ipmc_entry->destination);
  // using manual converter
  sai_thrift_ip_address_t_parse(thrift_ipmc_entry.source, &ipmc_entry->source);
}

  // ipmcgroup API helper functions

void sai_thrift_parse_ipmc_group_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
                                            sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
      return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(static_cast<sai_object_type_t>(SAI_OBJECT_TYPE_IPMC_GROUP), attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_ipmc_group_attributes(sai_attribute_t *attr_list,
                                              uint32_t attr_count,
                                              std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(static_cast<sai_object_type_t>(SAI_OBJECT_TYPE_IPMC_GROUP), attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

void sai_thrift_parse_ipmc_group_member_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
                                                   sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
      return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(static_cast<sai_object_type_t>(SAI_OBJECT_TYPE_IPMC_GROUP_MEMBER), attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_ipmc_group_member_attributes(sai_attribute_t *attr_list,
                                                     uint32_t attr_count,
                                                     std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(static_cast<sai_object_type_t>(SAI_OBJECT_TYPE_IPMC_GROUP_MEMBER), attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

  // ipsec API helper functions

void sai_thrift_parse_ipsec_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
                                       sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
      return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(static_cast<sai_object_type_t>(SAI_OBJECT_TYPE_IPSEC), attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_ipsec_attributes(sai_attribute_t *attr_list,
                                         uint32_t attr_count,
                                         std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(static_cast<sai_object_type_t>(SAI_OBJECT_TYPE_IPSEC), attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

void sai_thrift_parse_ipsec_port_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
                                            sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
      return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(static_cast<sai_object_type_t>(SAI_OBJECT_TYPE_IPSEC_PORT), attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_ipsec_port_attributes(sai_attribute_t *attr_list,
                                              uint32_t attr_count,
                                              std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(static_cast<sai_object_type_t>(SAI_OBJECT_TYPE_IPSEC_PORT), attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

void sai_thrift_parse_ipsec_sa_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
                                          sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
      return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(static_cast<sai_object_type_t>(SAI_OBJECT_TYPE_IPSEC_SA), attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_ipsec_sa_attributes(sai_attribute_t *attr_list,
                                            uint32_t attr_count,
                                            std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(static_cast<sai_object_type_t>(SAI_OBJECT_TYPE_IPSEC_SA), attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

void sai_thrift_parse_ipsec_sa_status_notification(const sai_thrift_ipsec_sa_status_notification_t &thrift_ipsec_sa_status_notification,
                                                   sai_ipsec_sa_status_notification_t *ipsec_sa_status_notification) {
  ipsec_sa_status_notification->ipsec_sa_id = thrift_ipsec_sa_status_notification.ipsec_sa_id;
#ifdef UNSUPPORTED /* complex struct members are not supported yet */
  ipsec_sa_status_notification->ipsec_sa_octet_count_status = thrift_ipsec_sa_status_notification.ipsec_sa_octet_count_status;
#endif
  ipsec_sa_status_notification->ipsec_egress_sn_at_max_limit = thrift_ipsec_sa_status_notification.ipsec_egress_sn_at_max_limit;
}

  // isolationgroup API helper functions

void sai_thrift_parse_isolation_group_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
                                                 sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
      return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(static_cast<sai_object_type_t>(SAI_OBJECT_TYPE_ISOLATION_GROUP), attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_isolation_group_attributes(sai_attribute_t *attr_list,
                                                   uint32_t attr_count,
                                                   std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(static_cast<sai_object_type_t>(SAI_OBJECT_TYPE_ISOLATION_GROUP), attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

void sai_thrift_parse_isolation_group_member_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
                                                        sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
      return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(static_cast<sai_object_type_t>(SAI_OBJECT_TYPE_ISOLATION_GROUP_MEMBER), attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_isolation_group_member_attributes(sai_attribute_t *attr_list,
                                                          uint32_t attr_count,
                                                          std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(static_cast<sai_object_type_t>(SAI_OBJECT_TYPE_ISOLATION_GROUP_MEMBER), attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

  // l2mc API helper functions

void sai_thrift_parse_l2mc_entry_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
                                            sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
      return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(static_cast<sai_object_type_t>(SAI_OBJECT_TYPE_L2MC_ENTRY), attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_l2mc_entry_attributes(sai_attribute_t *attr_list,
                                              uint32_t attr_count,
                                              std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(static_cast<sai_object_type_t>(SAI_OBJECT_TYPE_L2MC_ENTRY), attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

void sai_thrift_parse_l2mc_entry(const sai_thrift_l2mc_entry_t &thrift_l2mc_entry,
                                 sai_l2mc_entry_t *l2mc_entry) {
  l2mc_entry->switch_id = thrift_l2mc_entry.switch_id;
  l2mc_entry->bv_id = thrift_l2mc_entry.bv_id;
#ifdef UNSUPPORTED /* complex struct members are not supported yet */
  l2mc_entry->type = thrift_l2mc_entry.type;
#endif
  // using manual converter
  sai_thrift_ip_address_t_parse(thrift_l2mc_entry.destination, &l2mc_entry->destination);
  // using manual converter
  sai_thrift_ip_address_t_parse(thrift_l2mc_entry.source, &l2mc_entry->source);
}

  // l2mcgroup API helper functions

void sai_thrift_parse_l2mc_group_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
                                            sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
      return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(static_cast<sai_object_type_t>(SAI_OBJECT_TYPE_L2MC_GROUP), attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_l2mc_group_attributes(sai_attribute_t *attr_list,
                                              uint32_t attr_count,
                                              std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(static_cast<sai_object_type_t>(SAI_OBJECT_TYPE_L2MC_GROUP), attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

void sai_thrift_parse_l2mc_group_member_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
                                                   sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
      return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(static_cast<sai_object_type_t>(SAI_OBJECT_TYPE_L2MC_GROUP_MEMBER), attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_l2mc_group_member_attributes(sai_attribute_t *attr_list,
                                                     uint32_t attr_count,
                                                     std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(static_cast<sai_object_type_t>(SAI_OBJECT_TYPE_L2MC_GROUP_MEMBER), attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

  // lag API helper functions

void sai_thrift_parse_lag_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
                                     sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
      return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(static_cast<sai_object_type_t>(SAI_OBJECT_TYPE_LAG), attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_lag_attributes(sai_attribute_t *attr_list,
                                       uint32_t attr_count,
                                       std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(static_cast<sai_object_type_t>(SAI_OBJECT_TYPE_LAG), attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

void sai_thrift_parse_lag_member_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
                                            sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
      return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(static_cast<sai_object_type_t>(SAI_OBJECT_TYPE_LAG_MEMBER), attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_lag_member_attributes(sai_attribute_t *attr_list,
                                              uint32_t attr_count,
                                              std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(static_cast<sai_object_type_t>(SAI_OBJECT_TYPE_LAG_MEMBER), attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

  // macsec API helper functions

void sai_thrift_parse_macsec_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
                                        sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
      return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(static_cast<sai_object_type_t>(SAI_OBJECT_TYPE_MACSEC), attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_macsec_attributes(sai_attribute_t *attr_list,
                                          uint32_t attr_count,
                                          std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(static_cast<sai_object_type_t>(SAI_OBJECT_TYPE_MACSEC), attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

void sai_thrift_parse_macsec_flow_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
                                             sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
      return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(static_cast<sai_object_type_t>(SAI_OBJECT_TYPE_MACSEC_FLOW), attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_macsec_flow_attributes(sai_attribute_t *attr_list,
                                               uint32_t attr_count,
                                               std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(static_cast<sai_object_type_t>(SAI_OBJECT_TYPE_MACSEC_FLOW), attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

void sai_thrift_parse_macsec_port_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
                                             sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
      return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(static_cast<sai_object_type_t>(SAI_OBJECT_TYPE_MACSEC_PORT), attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_macsec_port_attributes(sai_attribute_t *attr_list,
                                               uint32_t attr_count,
                                               std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(static_cast<sai_object_type_t>(SAI_OBJECT_TYPE_MACSEC_PORT), attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

void sai_thrift_parse_macsec_sa_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
                                           sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
      return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(static_cast<sai_object_type_t>(SAI_OBJECT_TYPE_MACSEC_SA), attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_macsec_sa_attributes(sai_attribute_t *attr_list,
                                             uint32_t attr_count,
                                             std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(static_cast<sai_object_type_t>(SAI_OBJECT_TYPE_MACSEC_SA), attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

void sai_thrift_parse_macsec_sc_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
                                           sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
      return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(static_cast<sai_object_type_t>(SAI_OBJECT_TYPE_MACSEC_SC), attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_macsec_sc_attributes(sai_attribute_t *attr_list,
                                             uint32_t attr_count,
                                             std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(static_cast<sai_object_type_t>(SAI_OBJECT_TYPE_MACSEC_SC), attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

  // mcastfdb API helper functions

void sai_thrift_parse_mcast_fdb_entry_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
                                                 sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
      return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(static_cast<sai_object_type_t>(SAI_OBJECT_TYPE_MCAST_FDB_ENTRY), attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_mcast_fdb_entry_attributes(sai_attribute_t *attr_list,
                                                   uint32_t attr_count,
                                                   std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(static_cast<sai_object_type_t>(SAI_OBJECT_TYPE_MCAST_FDB_ENTRY), attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

void sai_thrift_parse_mcast_fdb_entry(const sai_thrift_mcast_fdb_entry_t &thrift_mcast_fdb_entry,
                                      sai_mcast_fdb_entry_t *mcast_fdb_entry) {
  mcast_fdb_entry->switch_id = thrift_mcast_fdb_entry.switch_id;
  // using manual converter
  sai_thrift_mac_t_parse(thrift_mcast_fdb_entry.mac_address, &mcast_fdb_entry->mac_address);
  mcast_fdb_entry->bv_id = thrift_mcast_fdb_entry.bv_id;
}

  // mirror API helper functions

void sai_thrift_parse_mirror_session_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
                                                sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
      return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(static_cast<sai_object_type_t>(SAI_OBJECT_TYPE_MIRROR_SESSION), attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_mirror_session_attributes(sai_attribute_t *attr_list,
                                                  uint32_t attr_count,
                                                  std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(static_cast<sai_object_type_t>(SAI_OBJECT_TYPE_MIRROR_SESSION), attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

  // mpls API helper functions

void sai_thrift_parse_inseg_entry_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
                                             sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
      return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(static_cast<sai_object_type_t>(SAI_OBJECT_TYPE_INSEG_ENTRY), attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_inseg_entry_attributes(sai_attribute_t *attr_list,
                                               uint32_t attr_count,
                                               std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(static_cast<sai_object_type_t>(SAI_OBJECT_TYPE_INSEG_ENTRY), attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

void sai_thrift_parse_inseg_entry(const sai_thrift_inseg_entry_t &thrift_inseg_entry,
                                  sai_inseg_entry_t *inseg_entry) {
  inseg_entry->switch_id = thrift_inseg_entry.switch_id;
  inseg_entry->label = thrift_inseg_entry.label;
}

  // mymac API helper functions

void sai_thrift_parse_my_mac_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
                                        sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
      return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(static_cast<sai_object_type_t>(SAI_OBJECT_TYPE_MY_MAC), attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_my_mac_attributes(sai_attribute_t *attr_list,
                                          uint32_t attr_count,
                                          std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(static_cast<sai_object_type_t>(SAI_OBJECT_TYPE_MY_MAC), attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

  // nat API helper functions

void sai_thrift_parse_nat_entry_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
                                           sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
      return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(static_cast<sai_object_type_t>(SAI_OBJECT_TYPE_NAT_ENTRY), attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_nat_entry_attributes(sai_attribute_t *attr_list,
                                             uint32_t attr_count,
                                             std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(static_cast<sai_object_type_t>(SAI_OBJECT_TYPE_NAT_ENTRY), attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

void sai_thrift_parse_nat_zone_counter_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
                                                  sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
      return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(static_cast<sai_object_type_t>(SAI_OBJECT_TYPE_NAT_ZONE_COUNTER), attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_nat_zone_counter_attributes(sai_attribute_t *attr_list,
                                                    uint32_t attr_count,
                                                    std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(static_cast<sai_object_type_t>(SAI_OBJECT_TYPE_NAT_ZONE_COUNTER), attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

void sai_thrift_parse_nat_entry_key(const sai_thrift_nat_entry_key_t &thrift_nat_entry_key,
                                    sai_nat_entry_key_t *nat_entry_key) {
  // using manual converter
  sai_thrift_ip4_t_parse(thrift_nat_entry_key.src_ip, &nat_entry_key->src_ip);
  // using manual converter
  sai_thrift_ip4_t_parse(thrift_nat_entry_key.dst_ip, &nat_entry_key->dst_ip);
  nat_entry_key->proto = thrift_nat_entry_key.proto;
  nat_entry_key->l4_src_port = thrift_nat_entry_key.l4_src_port;
  nat_entry_key->l4_dst_port = thrift_nat_entry_key.l4_dst_port;
}

void sai_thrift_parse_nat_entry_mask(const sai_thrift_nat_entry_mask_t &thrift_nat_entry_mask,
                                     sai_nat_entry_mask_t *nat_entry_mask) {
  // using manual converter
  sai_thrift_ip4_t_parse(thrift_nat_entry_mask.src_ip, &nat_entry_mask->src_ip);
  // using manual converter
  sai_thrift_ip4_t_parse(thrift_nat_entry_mask.dst_ip, &nat_entry_mask->dst_ip);
  nat_entry_mask->proto = thrift_nat_entry_mask.proto;
  nat_entry_mask->l4_src_port = thrift_nat_entry_mask.l4_src_port;
  nat_entry_mask->l4_dst_port = thrift_nat_entry_mask.l4_dst_port;
}

void sai_thrift_parse_nat_entry_data(const sai_thrift_nat_entry_data_t &thrift_nat_entry_data,
                                     sai_nat_entry_data_t *nat_entry_data) {
  // using existing converter
  sai_thrift_parse_nat_entry_key(thrift_nat_entry_data.key, &nat_entry_data->key);
  // using existing converter
  sai_thrift_parse_nat_entry_mask(thrift_nat_entry_data.mask, &nat_entry_data->mask);
}

void sai_thrift_parse_nat_entry(const sai_thrift_nat_entry_t &thrift_nat_entry,
                                sai_nat_entry_t *nat_entry) {
  nat_entry->switch_id = thrift_nat_entry.switch_id;
  nat_entry->vr_id = thrift_nat_entry.vr_id;
  // using manual converter
  sai_thrift_nat_type_t_parse(thrift_nat_entry.nat_type, &nat_entry->nat_type);
  // using existing converter
  sai_thrift_parse_nat_entry_data(thrift_nat_entry.data, &nat_entry->data);
}

void sai_thrift_parse_nat_event_notification_data(const sai_thrift_nat_event_notification_data_t &thrift_nat_event_notification_data,
                                                  sai_nat_event_notification_data_t *nat_event_notification_data) {
#ifdef UNSUPPORTED /* complex struct members are not supported yet */
  nat_event_notification_data->event_type = thrift_nat_event_notification_data.event_type;
#endif
  // using existing converter
  sai_thrift_parse_nat_entry(thrift_nat_event_notification_data.nat_entry, &nat_event_notification_data->nat_entry);
}

  // neighbor API helper functions

void sai_thrift_parse_neighbor_entry_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
                                                sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
      return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(static_cast<sai_object_type_t>(SAI_OBJECT_TYPE_NEIGHBOR_ENTRY), attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_neighbor_entry_attributes(sai_attribute_t *attr_list,
                                                  uint32_t attr_count,
                                                  std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(static_cast<sai_object_type_t>(SAI_OBJECT_TYPE_NEIGHBOR_ENTRY), attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

void sai_thrift_parse_neighbor_entry(const sai_thrift_neighbor_entry_t &thrift_neighbor_entry,
                                     sai_neighbor_entry_t *neighbor_entry) {
  neighbor_entry->switch_id = thrift_neighbor_entry.switch_id;
  neighbor_entry->rif_id = thrift_neighbor_entry.rif_id;
  // using manual converter
  sai_thrift_ip_address_t_parse(thrift_neighbor_entry.ip_address, &neighbor_entry->ip_address);
}

  // nexthop API helper functions

void sai_thrift_parse_next_hop_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
                                          sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
      return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(static_cast<sai_object_type_t>(SAI_OBJECT_TYPE_NEXT_HOP), attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_next_hop_attributes(sai_attribute_t *attr_list,
                                            uint32_t attr_count,
                                            std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(static_cast<sai_object_type_t>(SAI_OBJECT_TYPE_NEXT_HOP), attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

  // nexthopgroup API helper functions

void sai_thrift_parse_next_hop_group_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
                                                sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
      return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(static_cast<sai_object_type_t>(SAI_OBJECT_TYPE_NEXT_HOP_GROUP), attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_next_hop_group_attributes(sai_attribute_t *attr_list,
                                                  uint32_t attr_count,
                                                  std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(static_cast<sai_object_type_t>(SAI_OBJECT_TYPE_NEXT_HOP_GROUP), attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

void sai_thrift_parse_next_hop_group_map_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
                                                    sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
      return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(static_cast<sai_object_type_t>(SAI_OBJECT_TYPE_NEXT_HOP_GROUP_MAP), attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_next_hop_group_map_attributes(sai_attribute_t *attr_list,
                                                      uint32_t attr_count,
                                                      std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(static_cast<sai_object_type_t>(SAI_OBJECT_TYPE_NEXT_HOP_GROUP_MAP), attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

void sai_thrift_parse_next_hop_group_member_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
                                                       sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
      return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(static_cast<sai_object_type_t>(SAI_OBJECT_TYPE_NEXT_HOP_GROUP_MEMBER), attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_next_hop_group_member_attributes(sai_attribute_t *attr_list,
                                                         uint32_t attr_count,
                                                         std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(static_cast<sai_object_type_t>(SAI_OBJECT_TYPE_NEXT_HOP_GROUP_MEMBER), attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

  // policer API helper functions

void sai_thrift_parse_policer_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
                                         sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
      return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(static_cast<sai_object_type_t>(SAI_OBJECT_TYPE_POLICER), attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_policer_attributes(sai_attribute_t *attr_list,
                                           uint32_t attr_count,
                                           std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(static_cast<sai_object_type_t>(SAI_OBJECT_TYPE_POLICER), attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

  // port API helper functions

void sai_thrift_parse_port_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
                                      sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
      return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(static_cast<sai_object_type_t>(SAI_OBJECT_TYPE_PORT), attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_port_attributes(sai_attribute_t *attr_list,
                                        uint32_t attr_count,
                                        std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(static_cast<sai_object_type_t>(SAI_OBJECT_TYPE_PORT), attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

void sai_thrift_parse_port_connector_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
                                                sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
      return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(static_cast<sai_object_type_t>(SAI_OBJECT_TYPE_PORT_CONNECTOR), attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_port_connector_attributes(sai_attribute_t *attr_list,
                                                  uint32_t attr_count,
                                                  std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(static_cast<sai_object_type_t>(SAI_OBJECT_TYPE_PORT_CONNECTOR), attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

void sai_thrift_parse_port_pool_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
                                           sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
      return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(static_cast<sai_object_type_t>(SAI_OBJECT_TYPE_PORT_POOL), attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_port_pool_attributes(sai_attribute_t *attr_list,
                                             uint32_t attr_count,
                                             std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(static_cast<sai_object_type_t>(SAI_OBJECT_TYPE_PORT_POOL), attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

void sai_thrift_parse_port_serdes_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
                                             sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
      return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(static_cast<sai_object_type_t>(SAI_OBJECT_TYPE_PORT_SERDES), attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_port_serdes_attributes(sai_attribute_t *attr_list,
                                               uint32_t attr_count,
                                               std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(static_cast<sai_object_type_t>(SAI_OBJECT_TYPE_PORT_SERDES), attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

void sai_thrift_parse_port_oper_status_notification(const sai_thrift_port_oper_status_notification_t &thrift_port_oper_status_notification,
                                                    sai_port_oper_status_notification_t *port_oper_status_notification) {
  port_oper_status_notification->port_id = thrift_port_oper_status_notification.port_id;
#ifdef UNSUPPORTED /* complex struct members are not supported yet */
  port_oper_status_notification->port_state = thrift_port_oper_status_notification.port_state;
#endif
}

  // qosmap API helper functions

void sai_thrift_parse_qos_map_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
                                         sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
      return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(static_cast<sai_object_type_t>(SAI_OBJECT_TYPE_QOS_MAP), attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_qos_map_attributes(sai_attribute_t *attr_list,
                                           uint32_t attr_count,
                                           std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(static_cast<sai_object_type_t>(SAI_OBJECT_TYPE_QOS_MAP), attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

  // queue API helper functions

void sai_thrift_parse_queue_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
                                       sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
      return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(static_cast<sai_object_type_t>(SAI_OBJECT_TYPE_QUEUE), attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_queue_attributes(sai_attribute_t *attr_list,
                                         uint32_t attr_count,
                                         std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(static_cast<sai_object_type_t>(SAI_OBJECT_TYPE_QUEUE), attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

void sai_thrift_parse_queue_deadlock_notification_data(const sai_thrift_queue_deadlock_notification_data_t &thrift_queue_deadlock_notification_data,
                                                       sai_queue_deadlock_notification_data_t *queue_deadlock_notification_data) {
  queue_deadlock_notification_data->queue_id = thrift_queue_deadlock_notification_data.queue_id;
#ifdef UNSUPPORTED /* complex struct members are not supported yet */
  queue_deadlock_notification_data->event = thrift_queue_deadlock_notification_data.event;
#endif
  queue_deadlock_notification_data->app_managed_recovery = thrift_queue_deadlock_notification_data.app_managed_recovery;
}

  // route API helper functions

void sai_thrift_parse_route_entry_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
                                             sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
      return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(static_cast<sai_object_type_t>(SAI_OBJECT_TYPE_ROUTE_ENTRY), attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_route_entry_attributes(sai_attribute_t *attr_list,
                                               uint32_t attr_count,
                                               std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(static_cast<sai_object_type_t>(SAI_OBJECT_TYPE_ROUTE_ENTRY), attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

void sai_thrift_parse_route_entry(const sai_thrift_route_entry_t &thrift_route_entry,
                                  sai_route_entry_t *route_entry) {
  route_entry->switch_id = thrift_route_entry.switch_id;
  route_entry->vr_id = thrift_route_entry.vr_id;
  // using manual converter
  sai_thrift_ip_prefix_t_parse(thrift_route_entry.destination, &route_entry->destination);
}

  // routerinterface API helper functions

void sai_thrift_parse_router_interface_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
                                                  sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
      return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(static_cast<sai_object_type_t>(SAI_OBJECT_TYPE_ROUTER_INTERFACE), attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_router_interface_attributes(sai_attribute_t *attr_list,
                                                    uint32_t attr_count,
                                                    std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(static_cast<sai_object_type_t>(SAI_OBJECT_TYPE_ROUTER_INTERFACE), attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

  // rpfgroup API helper functions

void sai_thrift_parse_rpf_group_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
                                           sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
      return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(static_cast<sai_object_type_t>(SAI_OBJECT_TYPE_RPF_GROUP), attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_rpf_group_attributes(sai_attribute_t *attr_list,
                                             uint32_t attr_count,
                                             std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(static_cast<sai_object_type_t>(SAI_OBJECT_TYPE_RPF_GROUP), attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

void sai_thrift_parse_rpf_group_member_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
                                                  sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
      return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(static_cast<sai_object_type_t>(SAI_OBJECT_TYPE_RPF_GROUP_MEMBER), attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_rpf_group_member_attributes(sai_attribute_t *attr_list,
                                                    uint32_t attr_count,
                                                    std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(static_cast<sai_object_type_t>(SAI_OBJECT_TYPE_RPF_GROUP_MEMBER), attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

  // samplepacket API helper functions

void sai_thrift_parse_samplepacket_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
                                              sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
      return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(static_cast<sai_object_type_t>(SAI_OBJECT_TYPE_SAMPLEPACKET), attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_samplepacket_attributes(sai_attribute_t *attr_list,
                                                uint32_t attr_count,
                                                std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(static_cast<sai_object_type_t>(SAI_OBJECT_TYPE_SAMPLEPACKET), attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

  // scheduler API helper functions

void sai_thrift_parse_scheduler_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
                                           sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
      return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(static_cast<sai_object_type_t>(SAI_OBJECT_TYPE_SCHEDULER), attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_scheduler_attributes(sai_attribute_t *attr_list,
                                             uint32_t attr_count,
                                             std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(static_cast<sai_object_type_t>(SAI_OBJECT_TYPE_SCHEDULER), attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

  // schedulergroup API helper functions

void sai_thrift_parse_scheduler_group_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
                                                 sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
      return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(static_cast<sai_object_type_t>(SAI_OBJECT_TYPE_SCHEDULER_GROUP), attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_scheduler_group_attributes(sai_attribute_t *attr_list,
                                                   uint32_t attr_count,
                                                   std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(static_cast<sai_object_type_t>(SAI_OBJECT_TYPE_SCHEDULER_GROUP), attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

  // srv6 API helper functions

void sai_thrift_parse_my_sid_entry_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
                                              sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
      return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(static_cast<sai_object_type_t>(SAI_OBJECT_TYPE_MY_SID_ENTRY), attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_my_sid_entry_attributes(sai_attribute_t *attr_list,
                                                uint32_t attr_count,
                                                std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(static_cast<sai_object_type_t>(SAI_OBJECT_TYPE_MY_SID_ENTRY), attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

void sai_thrift_parse_srv6_sidlist_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
                                              sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
      return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(static_cast<sai_object_type_t>(SAI_OBJECT_TYPE_SRV6_SIDLIST), attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_srv6_sidlist_attributes(sai_attribute_t *attr_list,
                                                uint32_t attr_count,
                                                std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(static_cast<sai_object_type_t>(SAI_OBJECT_TYPE_SRV6_SIDLIST), attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

void sai_thrift_parse_my_sid_entry(const sai_thrift_my_sid_entry_t &thrift_my_sid_entry,
                                   sai_my_sid_entry_t *my_sid_entry) {
  my_sid_entry->switch_id = thrift_my_sid_entry.switch_id;
  my_sid_entry->vr_id = thrift_my_sid_entry.vr_id;
  my_sid_entry->locator_block_len = thrift_my_sid_entry.locator_block_len;
  my_sid_entry->locator_node_len = thrift_my_sid_entry.locator_node_len;
  my_sid_entry->function_len = thrift_my_sid_entry.function_len;
  my_sid_entry->args_len = thrift_my_sid_entry.args_len;
  // using manual converter
  sai_thrift_ip6_t_parse(thrift_my_sid_entry.sid, my_sid_entry->sid);
}

  // stp API helper functions

void sai_thrift_parse_stp_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
                                     sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
      return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(static_cast<sai_object_type_t>(SAI_OBJECT_TYPE_STP), attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_stp_attributes(sai_attribute_t *attr_list,
                                       uint32_t attr_count,
                                       std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(static_cast<sai_object_type_t>(SAI_OBJECT_TYPE_STP), attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

void sai_thrift_parse_stp_port_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
                                          sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
      return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(static_cast<sai_object_type_t>(SAI_OBJECT_TYPE_STP_PORT), attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_stp_port_attributes(sai_attribute_t *attr_list,
                                            uint32_t attr_count,
                                            std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(static_cast<sai_object_type_t>(SAI_OBJECT_TYPE_STP_PORT), attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

  // switch API helper functions

void sai_thrift_parse_switch_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
                                        sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
      return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(static_cast<sai_object_type_t>(SAI_OBJECT_TYPE_SWITCH), attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_switch_attributes(sai_attribute_t *attr_list,
                                          uint32_t attr_count,
                                          std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(static_cast<sai_object_type_t>(SAI_OBJECT_TYPE_SWITCH), attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

void sai_thrift_parse_switch_tunnel_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
                                               sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
      return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(static_cast<sai_object_type_t>(SAI_OBJECT_TYPE_SWITCH_TUNNEL), attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_switch_tunnel_attributes(sai_attribute_t *attr_list,
                                                 uint32_t attr_count,
                                                 std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(static_cast<sai_object_type_t>(SAI_OBJECT_TYPE_SWITCH_TUNNEL), attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

  // systemport API helper functions

void sai_thrift_parse_system_port_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
                                             sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
      return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(static_cast<sai_object_type_t>(SAI_OBJECT_TYPE_SYSTEM_PORT), attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_system_port_attributes(sai_attribute_t *attr_list,
                                               uint32_t attr_count,
                                               std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(static_cast<sai_object_type_t>(SAI_OBJECT_TYPE_SYSTEM_PORT), attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

  // tam API helper functions

void sai_thrift_parse_tam_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
                                     sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
      return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(static_cast<sai_object_type_t>(SAI_OBJECT_TYPE_TAM), attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_tam_attributes(sai_attribute_t *attr_list,
                                       uint32_t attr_count,
                                       std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(static_cast<sai_object_type_t>(SAI_OBJECT_TYPE_TAM), attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

void sai_thrift_parse_tam_collector_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
                                               sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
      return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(static_cast<sai_object_type_t>(SAI_OBJECT_TYPE_TAM_COLLECTOR), attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_tam_collector_attributes(sai_attribute_t *attr_list,
                                                 uint32_t attr_count,
                                                 std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(static_cast<sai_object_type_t>(SAI_OBJECT_TYPE_TAM_COLLECTOR), attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

void sai_thrift_parse_tam_event_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
                                           sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
      return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(static_cast<sai_object_type_t>(SAI_OBJECT_TYPE_TAM_EVENT), attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_tam_event_attributes(sai_attribute_t *attr_list,
                                             uint32_t attr_count,
                                             std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(static_cast<sai_object_type_t>(SAI_OBJECT_TYPE_TAM_EVENT), attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

void sai_thrift_parse_tam_event_action_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
                                                  sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
      return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(static_cast<sai_object_type_t>(SAI_OBJECT_TYPE_TAM_EVENT_ACTION), attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_tam_event_action_attributes(sai_attribute_t *attr_list,
                                                    uint32_t attr_count,
                                                    std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(static_cast<sai_object_type_t>(SAI_OBJECT_TYPE_TAM_EVENT_ACTION), attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

void sai_thrift_parse_tam_event_threshold_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
                                                     sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
      return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(static_cast<sai_object_type_t>(SAI_OBJECT_TYPE_TAM_EVENT_THRESHOLD), attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_tam_event_threshold_attributes(sai_attribute_t *attr_list,
                                                       uint32_t attr_count,
                                                       std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(static_cast<sai_object_type_t>(SAI_OBJECT_TYPE_TAM_EVENT_THRESHOLD), attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

void sai_thrift_parse_tam_int_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
                                         sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
      return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(static_cast<sai_object_type_t>(SAI_OBJECT_TYPE_TAM_INT), attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_tam_int_attributes(sai_attribute_t *attr_list,
                                           uint32_t attr_count,
                                           std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(static_cast<sai_object_type_t>(SAI_OBJECT_TYPE_TAM_INT), attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

void sai_thrift_parse_tam_math_func_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
                                               sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
      return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(static_cast<sai_object_type_t>(SAI_OBJECT_TYPE_TAM_MATH_FUNC), attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_tam_math_func_attributes(sai_attribute_t *attr_list,
                                                 uint32_t attr_count,
                                                 std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(static_cast<sai_object_type_t>(SAI_OBJECT_TYPE_TAM_MATH_FUNC), attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

void sai_thrift_parse_tam_report_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
                                            sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
      return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(static_cast<sai_object_type_t>(SAI_OBJECT_TYPE_TAM_REPORT), attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_tam_report_attributes(sai_attribute_t *attr_list,
                                              uint32_t attr_count,
                                              std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(static_cast<sai_object_type_t>(SAI_OBJECT_TYPE_TAM_REPORT), attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

void sai_thrift_parse_tam_tel_type_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
                                              sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
      return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(static_cast<sai_object_type_t>(SAI_OBJECT_TYPE_TAM_TEL_TYPE), attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_tam_tel_type_attributes(sai_attribute_t *attr_list,
                                                uint32_t attr_count,
                                                std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(static_cast<sai_object_type_t>(SAI_OBJECT_TYPE_TAM_TEL_TYPE), attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

void sai_thrift_parse_tam_telemetry_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
                                               sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
      return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(static_cast<sai_object_type_t>(SAI_OBJECT_TYPE_TAM_TELEMETRY), attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_tam_telemetry_attributes(sai_attribute_t *attr_list,
                                                 uint32_t attr_count,
                                                 std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(static_cast<sai_object_type_t>(SAI_OBJECT_TYPE_TAM_TELEMETRY), attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

void sai_thrift_parse_tam_transport_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
                                               sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
      return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(static_cast<sai_object_type_t>(SAI_OBJECT_TYPE_TAM_TRANSPORT), attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_tam_transport_attributes(sai_attribute_t *attr_list,
                                                 uint32_t attr_count,
                                                 std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(static_cast<sai_object_type_t>(SAI_OBJECT_TYPE_TAM_TRANSPORT), attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

  // tunnel API helper functions

void sai_thrift_parse_tunnel_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
                                        sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
      return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(static_cast<sai_object_type_t>(SAI_OBJECT_TYPE_TUNNEL), attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_tunnel_attributes(sai_attribute_t *attr_list,
                                          uint32_t attr_count,
                                          std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(static_cast<sai_object_type_t>(SAI_OBJECT_TYPE_TUNNEL), attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

void sai_thrift_parse_tunnel_map_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
                                            sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
      return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(static_cast<sai_object_type_t>(SAI_OBJECT_TYPE_TUNNEL_MAP), attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_tunnel_map_attributes(sai_attribute_t *attr_list,
                                              uint32_t attr_count,
                                              std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(static_cast<sai_object_type_t>(SAI_OBJECT_TYPE_TUNNEL_MAP), attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

void sai_thrift_parse_tunnel_map_entry_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
                                                  sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
      return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(static_cast<sai_object_type_t>(SAI_OBJECT_TYPE_TUNNEL_MAP_ENTRY), attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_tunnel_map_entry_attributes(sai_attribute_t *attr_list,
                                                    uint32_t attr_count,
                                                    std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(static_cast<sai_object_type_t>(SAI_OBJECT_TYPE_TUNNEL_MAP_ENTRY), attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

void sai_thrift_parse_tunnel_term_table_entry_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
                                                         sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
      return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(static_cast<sai_object_type_t>(SAI_OBJECT_TYPE_TUNNEL_TERM_TABLE_ENTRY), attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_tunnel_term_table_entry_attributes(sai_attribute_t *attr_list,
                                                           uint32_t attr_count,
                                                           std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(static_cast<sai_object_type_t>(SAI_OBJECT_TYPE_TUNNEL_TERM_TABLE_ENTRY), attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

  // udf API helper functions

void sai_thrift_parse_udf_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
                                     sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
      return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(static_cast<sai_object_type_t>(SAI_OBJECT_TYPE_UDF), attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_udf_attributes(sai_attribute_t *attr_list,
                                       uint32_t attr_count,
                                       std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(static_cast<sai_object_type_t>(SAI_OBJECT_TYPE_UDF), attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

void sai_thrift_parse_udf_group_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
                                           sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
      return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(static_cast<sai_object_type_t>(SAI_OBJECT_TYPE_UDF_GROUP), attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_udf_group_attributes(sai_attribute_t *attr_list,
                                             uint32_t attr_count,
                                             std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(static_cast<sai_object_type_t>(SAI_OBJECT_TYPE_UDF_GROUP), attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

void sai_thrift_parse_udf_match_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
                                           sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
      return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(static_cast<sai_object_type_t>(SAI_OBJECT_TYPE_UDF_MATCH), attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_udf_match_attributes(sai_attribute_t *attr_list,
                                             uint32_t attr_count,
                                             std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(static_cast<sai_object_type_t>(SAI_OBJECT_TYPE_UDF_MATCH), attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

  // virtualrouter API helper functions

void sai_thrift_parse_virtual_router_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
                                                sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
      return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(static_cast<sai_object_type_t>(SAI_OBJECT_TYPE_VIRTUAL_ROUTER), attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_virtual_router_attributes(sai_attribute_t *attr_list,
                                                  uint32_t attr_count,
                                                  std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(static_cast<sai_object_type_t>(SAI_OBJECT_TYPE_VIRTUAL_ROUTER), attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

  // vlan API helper functions

void sai_thrift_parse_vlan_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
                                      sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
      return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(static_cast<sai_object_type_t>(SAI_OBJECT_TYPE_VLAN), attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_vlan_attributes(sai_attribute_t *attr_list,
                                        uint32_t attr_count,
                                        std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(static_cast<sai_object_type_t>(SAI_OBJECT_TYPE_VLAN), attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

void sai_thrift_parse_vlan_member_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
                                             sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
      return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(static_cast<sai_object_type_t>(SAI_OBJECT_TYPE_VLAN_MEMBER), attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_vlan_member_attributes(sai_attribute_t *attr_list,
                                               uint32_t attr_count,
                                               std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(static_cast<sai_object_type_t>(SAI_OBJECT_TYPE_VLAN_MEMBER), attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

  // wred API helper functions

void sai_thrift_parse_wred_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
                                      sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
      return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(static_cast<sai_object_type_t>(SAI_OBJECT_TYPE_WRED), attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_wred_attributes(sai_attribute_t *attr_list,
                                        uint32_t attr_count,
                                        std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(static_cast<sai_object_type_t>(SAI_OBJECT_TYPE_WRED), attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}


class sai_rpcHandler : virtual public sai_rpcIf {
 public:
  sai_rpcHandler() {
  }

  sai_thrift_object_id_t sai_thrift_create_acl_table(const std::vector<sai_thrift_attribute_t> & attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t acl_table_oid_out = SAI_NULL_OBJECT_ID;

    sai_acl_api_t *acl_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_ACL), (void **)&acl_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_acl_table_attributes(attr_list, sai_attr_list);

    if (acl_api->create_acl_table == (void *)0) {
        std::cerr << "NULL ptr: acl_api->create_acl_table" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = acl_api->create_acl_table(&acl_table_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);    return acl_table_oid_out;
  }

  void sai_thrift_remove_acl_table(const sai_thrift_object_id_t acl_table_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_acl_api_t *acl_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_ACL), (void **)&acl_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    if (acl_api->remove_acl_table == (void *)0) {
        std::cerr << "NULL ptr: acl_api->remove_acl_table" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = acl_api->remove_acl_table((sai_object_id_t)acl_table_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_acl_table_attribute(const sai_thrift_object_id_t acl_table_oid, const sai_thrift_attribute_t& attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t sai_attr;

    sai_acl_api_t *acl_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_ACL), (void **)&acl_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);

    sai_thrift_parse_acl_table_attributes(attr_vec, &sai_attr);

    if (acl_api->set_acl_table_attribute == (void *)0) {
        std::cerr << "NULL ptr: acl_api->set_acl_table_attribute" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = acl_api->set_acl_table_attribute((sai_object_id_t)acl_table_oid, &sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_get_acl_table_attribute(sai_thrift_attribute_list_t& attr_list_out, const sai_thrift_object_id_t acl_table_oid, const sai_thrift_attribute_list_t& attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_acl_api_t *acl_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_ACL), (void **)&acl_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    else {
      return;
    }


    const std::vector<sai_thrift_attribute_t> &attr_list_vec = attr_list.attr_list;

    sai_thrift_parse_acl_table_attributes(attr_list_vec, sai_attr_list);

    if (acl_api->get_acl_table_attribute == (void *)0) {
        std::cerr << "NULL ptr: acl_api->get_acl_table_attribute" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = acl_api->get_acl_table_attribute((sai_object_id_t)acl_table_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_acl_table_attributes(sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  sai_thrift_object_id_t sai_thrift_create_acl_entry(const std::vector<sai_thrift_attribute_t> & attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t acl_entry_oid_out = SAI_NULL_OBJECT_ID;

    sai_acl_api_t *acl_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_ACL), (void **)&acl_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_acl_entry_attributes(attr_list, sai_attr_list);

    if (acl_api->create_acl_entry == (void *)0) {
        std::cerr << "NULL ptr: acl_api->create_acl_entry" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = acl_api->create_acl_entry(&acl_entry_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);    return acl_entry_oid_out;
  }

  void sai_thrift_remove_acl_entry(const sai_thrift_object_id_t acl_entry_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_acl_api_t *acl_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_ACL), (void **)&acl_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    if (acl_api->remove_acl_entry == (void *)0) {
        std::cerr << "NULL ptr: acl_api->remove_acl_entry" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = acl_api->remove_acl_entry((sai_object_id_t)acl_entry_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_acl_entry_attribute(const sai_thrift_object_id_t acl_entry_oid, const sai_thrift_attribute_t& attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t sai_attr;

    sai_acl_api_t *acl_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_ACL), (void **)&acl_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);

    sai_thrift_parse_acl_entry_attributes(attr_vec, &sai_attr);

    if (acl_api->set_acl_entry_attribute == (void *)0) {
        std::cerr << "NULL ptr: acl_api->set_acl_entry_attribute" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = acl_api->set_acl_entry_attribute((sai_object_id_t)acl_entry_oid, &sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_get_acl_entry_attribute(sai_thrift_attribute_list_t& attr_list_out, const sai_thrift_object_id_t acl_entry_oid, const sai_thrift_attribute_list_t& attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_acl_api_t *acl_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_ACL), (void **)&acl_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    else {
      return;
    }


    const std::vector<sai_thrift_attribute_t> &attr_list_vec = attr_list.attr_list;

    sai_thrift_parse_acl_entry_attributes(attr_list_vec, sai_attr_list);

    if (acl_api->get_acl_entry_attribute == (void *)0) {
        std::cerr << "NULL ptr: acl_api->get_acl_entry_attribute" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = acl_api->get_acl_entry_attribute((sai_object_id_t)acl_entry_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_acl_entry_attributes(sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  sai_thrift_object_id_t sai_thrift_create_acl_counter(const std::vector<sai_thrift_attribute_t> & attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t acl_counter_oid_out = SAI_NULL_OBJECT_ID;

    sai_acl_api_t *acl_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_ACL), (void **)&acl_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_acl_counter_attributes(attr_list, sai_attr_list);

    if (acl_api->create_acl_counter == (void *)0) {
        std::cerr << "NULL ptr: acl_api->create_acl_counter" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = acl_api->create_acl_counter(&acl_counter_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);    return acl_counter_oid_out;
  }

  void sai_thrift_remove_acl_counter(const sai_thrift_object_id_t acl_counter_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_acl_api_t *acl_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_ACL), (void **)&acl_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    if (acl_api->remove_acl_counter == (void *)0) {
        std::cerr << "NULL ptr: acl_api->remove_acl_counter" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = acl_api->remove_acl_counter((sai_object_id_t)acl_counter_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_acl_counter_attribute(const sai_thrift_object_id_t acl_counter_oid, const sai_thrift_attribute_t& attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t sai_attr;

    sai_acl_api_t *acl_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_ACL), (void **)&acl_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);

    sai_thrift_parse_acl_counter_attributes(attr_vec, &sai_attr);

    if (acl_api->set_acl_counter_attribute == (void *)0) {
        std::cerr << "NULL ptr: acl_api->set_acl_counter_attribute" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = acl_api->set_acl_counter_attribute((sai_object_id_t)acl_counter_oid, &sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_get_acl_counter_attribute(sai_thrift_attribute_list_t& attr_list_out, const sai_thrift_object_id_t acl_counter_oid, const sai_thrift_attribute_list_t& attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_acl_api_t *acl_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_ACL), (void **)&acl_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    else {
      return;
    }


    const std::vector<sai_thrift_attribute_t> &attr_list_vec = attr_list.attr_list;

    sai_thrift_parse_acl_counter_attributes(attr_list_vec, sai_attr_list);

    if (acl_api->get_acl_counter_attribute == (void *)0) {
        std::cerr << "NULL ptr: acl_api->get_acl_counter_attribute" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = acl_api->get_acl_counter_attribute((sai_object_id_t)acl_counter_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_acl_counter_attributes(sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  sai_thrift_object_id_t sai_thrift_create_acl_range(const std::vector<sai_thrift_attribute_t> & attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t acl_range_oid_out = SAI_NULL_OBJECT_ID;

    sai_acl_api_t *acl_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_ACL), (void **)&acl_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_acl_range_attributes(attr_list, sai_attr_list);

    if (acl_api->create_acl_range == (void *)0) {
        std::cerr << "NULL ptr: acl_api->create_acl_range" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = acl_api->create_acl_range(&acl_range_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);    return acl_range_oid_out;
  }

  void sai_thrift_remove_acl_range(const sai_thrift_object_id_t acl_range_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_acl_api_t *acl_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_ACL), (void **)&acl_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    if (acl_api->remove_acl_range == (void *)0) {
        std::cerr << "NULL ptr: acl_api->remove_acl_range" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = acl_api->remove_acl_range((sai_object_id_t)acl_range_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_acl_range_attribute(const sai_thrift_object_id_t acl_range_oid, const sai_thrift_attribute_t& attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t sai_attr;

    sai_acl_api_t *acl_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_ACL), (void **)&acl_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);

    sai_thrift_parse_acl_range_attributes(attr_vec, &sai_attr);

    if (acl_api->set_acl_range_attribute == (void *)0) {
        std::cerr << "NULL ptr: acl_api->set_acl_range_attribute" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = acl_api->set_acl_range_attribute((sai_object_id_t)acl_range_oid, &sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_get_acl_range_attribute(sai_thrift_attribute_list_t& attr_list_out, const sai_thrift_object_id_t acl_range_oid, const sai_thrift_attribute_list_t& attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_acl_api_t *acl_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_ACL), (void **)&acl_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    else {
      return;
    }


    const std::vector<sai_thrift_attribute_t> &attr_list_vec = attr_list.attr_list;

    sai_thrift_parse_acl_range_attributes(attr_list_vec, sai_attr_list);

    if (acl_api->get_acl_range_attribute == (void *)0) {
        std::cerr << "NULL ptr: acl_api->get_acl_range_attribute" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = acl_api->get_acl_range_attribute((sai_object_id_t)acl_range_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_acl_range_attributes(sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  sai_thrift_object_id_t sai_thrift_create_acl_table_group(const std::vector<sai_thrift_attribute_t> & attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t acl_table_group_oid_out = SAI_NULL_OBJECT_ID;

    sai_acl_api_t *acl_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_ACL), (void **)&acl_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_acl_table_group_attributes(attr_list, sai_attr_list);

    if (acl_api->create_acl_table_group == (void *)0) {
        std::cerr << "NULL ptr: acl_api->create_acl_table_group" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = acl_api->create_acl_table_group(&acl_table_group_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);    return acl_table_group_oid_out;
  }

  void sai_thrift_remove_acl_table_group(const sai_thrift_object_id_t acl_table_group_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_acl_api_t *acl_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_ACL), (void **)&acl_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    if (acl_api->remove_acl_table_group == (void *)0) {
        std::cerr << "NULL ptr: acl_api->remove_acl_table_group" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = acl_api->remove_acl_table_group((sai_object_id_t)acl_table_group_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_acl_table_group_attribute(const sai_thrift_object_id_t acl_table_group_oid, const sai_thrift_attribute_t& attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t sai_attr;

    sai_acl_api_t *acl_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_ACL), (void **)&acl_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);

    sai_thrift_parse_acl_table_group_attributes(attr_vec, &sai_attr);

    if (acl_api->set_acl_table_group_attribute == (void *)0) {
        std::cerr << "NULL ptr: acl_api->set_acl_table_group_attribute" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = acl_api->set_acl_table_group_attribute((sai_object_id_t)acl_table_group_oid, &sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_get_acl_table_group_attribute(sai_thrift_attribute_list_t& attr_list_out, const sai_thrift_object_id_t acl_table_group_oid, const sai_thrift_attribute_list_t& attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_acl_api_t *acl_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_ACL), (void **)&acl_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    else {
      return;
    }


    const std::vector<sai_thrift_attribute_t> &attr_list_vec = attr_list.attr_list;

    sai_thrift_parse_acl_table_group_attributes(attr_list_vec, sai_attr_list);

    if (acl_api->get_acl_table_group_attribute == (void *)0) {
        std::cerr << "NULL ptr: acl_api->get_acl_table_group_attribute" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = acl_api->get_acl_table_group_attribute((sai_object_id_t)acl_table_group_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_acl_table_group_attributes(sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  sai_thrift_object_id_t sai_thrift_create_acl_table_group_member(const std::vector<sai_thrift_attribute_t> & attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t acl_table_group_member_oid_out = SAI_NULL_OBJECT_ID;

    sai_acl_api_t *acl_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_ACL), (void **)&acl_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_acl_table_group_member_attributes(attr_list, sai_attr_list);

    if (acl_api->create_acl_table_group_member == (void *)0) {
        std::cerr << "NULL ptr: acl_api->create_acl_table_group_member" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = acl_api->create_acl_table_group_member(&acl_table_group_member_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);    return acl_table_group_member_oid_out;
  }

  void sai_thrift_remove_acl_table_group_member(const sai_thrift_object_id_t acl_table_group_member_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_acl_api_t *acl_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_ACL), (void **)&acl_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    if (acl_api->remove_acl_table_group_member == (void *)0) {
        std::cerr << "NULL ptr: acl_api->remove_acl_table_group_member" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = acl_api->remove_acl_table_group_member((sai_object_id_t)acl_table_group_member_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_acl_table_group_member_attribute(const sai_thrift_object_id_t acl_table_group_member_oid, const sai_thrift_attribute_t& attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t sai_attr;

    sai_acl_api_t *acl_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_ACL), (void **)&acl_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);

    sai_thrift_parse_acl_table_group_member_attributes(attr_vec, &sai_attr);

    if (acl_api->set_acl_table_group_member_attribute == (void *)0) {
        std::cerr << "NULL ptr: acl_api->set_acl_table_group_member_attribute" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = acl_api->set_acl_table_group_member_attribute((sai_object_id_t)acl_table_group_member_oid, &sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_get_acl_table_group_member_attribute(sai_thrift_attribute_list_t& attr_list_out, const sai_thrift_object_id_t acl_table_group_member_oid, const sai_thrift_attribute_list_t& attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_acl_api_t *acl_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_ACL), (void **)&acl_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    else {
      return;
    }


    const std::vector<sai_thrift_attribute_t> &attr_list_vec = attr_list.attr_list;

    sai_thrift_parse_acl_table_group_member_attributes(attr_list_vec, sai_attr_list);

    if (acl_api->get_acl_table_group_member_attribute == (void *)0) {
        std::cerr << "NULL ptr: acl_api->get_acl_table_group_member_attribute" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = acl_api->get_acl_table_group_member_attribute((sai_object_id_t)acl_table_group_member_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_acl_table_group_member_attributes(sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  sai_thrift_object_id_t sai_thrift_create_acl_table_chain_group(const std::vector<sai_thrift_attribute_t> & attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t acl_table_chain_group_oid_out = SAI_NULL_OBJECT_ID;

    sai_acl_api_t *acl_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_ACL), (void **)&acl_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_acl_table_chain_group_attributes(attr_list, sai_attr_list);

    if (acl_api->create_acl_table_chain_group == (void *)0) {
        std::cerr << "NULL ptr: acl_api->create_acl_table_chain_group" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = acl_api->create_acl_table_chain_group(&acl_table_chain_group_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);    return acl_table_chain_group_oid_out;
  }

  void sai_thrift_remove_acl_table_chain_group(const sai_thrift_object_id_t acl_table_chain_group_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_acl_api_t *acl_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_ACL), (void **)&acl_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    if (acl_api->remove_acl_table_chain_group == (void *)0) {
        std::cerr << "NULL ptr: acl_api->remove_acl_table_chain_group" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = acl_api->remove_acl_table_chain_group((sai_object_id_t)acl_table_chain_group_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_acl_table_chain_group_attribute(const sai_thrift_object_id_t acl_table_chain_group_oid, const sai_thrift_attribute_t& attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t sai_attr;

    sai_acl_api_t *acl_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_ACL), (void **)&acl_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);

    sai_thrift_parse_acl_table_chain_group_attributes(attr_vec, &sai_attr);

    if (acl_api->set_acl_table_chain_group_attribute == (void *)0) {
        std::cerr << "NULL ptr: acl_api->set_acl_table_chain_group_attribute" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = acl_api->set_acl_table_chain_group_attribute((sai_object_id_t)acl_table_chain_group_oid, &sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_get_acl_table_chain_group_attribute(sai_thrift_attribute_list_t& attr_list_out, const sai_thrift_object_id_t acl_table_chain_group_oid, const sai_thrift_attribute_list_t& attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_acl_api_t *acl_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_ACL), (void **)&acl_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    else {
      return;
    }


    const std::vector<sai_thrift_attribute_t> &attr_list_vec = attr_list.attr_list;

    sai_thrift_parse_acl_table_chain_group_attributes(attr_list_vec, sai_attr_list);

    if (acl_api->get_acl_table_chain_group_attribute == (void *)0) {
        std::cerr << "NULL ptr: acl_api->get_acl_table_chain_group_attribute" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = acl_api->get_acl_table_chain_group_attribute((sai_object_id_t)acl_table_chain_group_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_acl_table_chain_group_attributes(sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  sai_thrift_object_id_t sai_thrift_create_ars(const std::vector<sai_thrift_attribute_t> & attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t ars_oid_out = SAI_NULL_OBJECT_ID;

    sai_ars_api_t *ars_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_ARS), (void **)&ars_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_ars_attributes(attr_list, sai_attr_list);

    if (ars_api->create_ars == (void *)0) {
        std::cerr << "NULL ptr: ars_api->create_ars" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = ars_api->create_ars(&ars_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);    return ars_oid_out;
  }

  void sai_thrift_remove_ars(const sai_thrift_object_id_t ars_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_ars_api_t *ars_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_ARS), (void **)&ars_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    if (ars_api->remove_ars == (void *)0) {
        std::cerr << "NULL ptr: ars_api->remove_ars" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = ars_api->remove_ars((sai_object_id_t)ars_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_ars_attribute(const sai_thrift_object_id_t ars_oid, const sai_thrift_attribute_t& attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t sai_attr;

    sai_ars_api_t *ars_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_ARS), (void **)&ars_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);

    sai_thrift_parse_ars_attributes(attr_vec, &sai_attr);

    if (ars_api->set_ars_attribute == (void *)0) {
        std::cerr << "NULL ptr: ars_api->set_ars_attribute" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = ars_api->set_ars_attribute((sai_object_id_t)ars_oid, &sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_get_ars_attribute(sai_thrift_attribute_list_t& attr_list_out, const sai_thrift_object_id_t ars_oid, const sai_thrift_attribute_list_t& attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_ars_api_t *ars_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_ARS), (void **)&ars_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    else {
      return;
    }


    const std::vector<sai_thrift_attribute_t> &attr_list_vec = attr_list.attr_list;

    sai_thrift_parse_ars_attributes(attr_list_vec, sai_attr_list);

    if (ars_api->get_ars_attribute == (void *)0) {
        std::cerr << "NULL ptr: ars_api->get_ars_attribute" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = ars_api->get_ars_attribute((sai_object_id_t)ars_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_ars_attributes(sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  sai_thrift_object_id_t sai_thrift_create_ars_profile(const std::vector<sai_thrift_attribute_t> & attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t ars_profile_oid_out = SAI_NULL_OBJECT_ID;

    sai_arsprofile_api_t *arsprofile_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_ARSPROFILE), (void **)&arsprofile_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_ars_profile_attributes(attr_list, sai_attr_list);

    if (arsprofile_api->create_ars_profile == (void *)0) {
        std::cerr << "NULL ptr: arsprofile_api->create_ars_profile" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = arsprofile_api->create_ars_profile(&ars_profile_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);    return ars_profile_oid_out;
  }

  void sai_thrift_remove_ars_profile(const sai_thrift_object_id_t ars_profile_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_arsprofile_api_t *arsprofile_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_ARSPROFILE), (void **)&arsprofile_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    if (arsprofile_api->remove_ars_profile == (void *)0) {
        std::cerr << "NULL ptr: arsprofile_api->remove_ars_profile" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = arsprofile_api->remove_ars_profile((sai_object_id_t)ars_profile_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_ars_profile_attribute(const sai_thrift_object_id_t ars_profile_oid, const sai_thrift_attribute_t& attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t sai_attr;

    sai_arsprofile_api_t *arsprofile_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_ARSPROFILE), (void **)&arsprofile_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);

    sai_thrift_parse_ars_profile_attributes(attr_vec, &sai_attr);

    if (arsprofile_api->set_ars_profile_attribute == (void *)0) {
        std::cerr << "NULL ptr: arsprofile_api->set_ars_profile_attribute" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = arsprofile_api->set_ars_profile_attribute((sai_object_id_t)ars_profile_oid, &sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_get_ars_profile_attribute(sai_thrift_attribute_list_t& attr_list_out, const sai_thrift_object_id_t ars_profile_oid, const sai_thrift_attribute_list_t& attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_arsprofile_api_t *arsprofile_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_ARSPROFILE), (void **)&arsprofile_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    else {
      return;
    }


    const std::vector<sai_thrift_attribute_t> &attr_list_vec = attr_list.attr_list;

    sai_thrift_parse_ars_profile_attributes(attr_list_vec, sai_attr_list);

    if (arsprofile_api->get_ars_profile_attribute == (void *)0) {
        std::cerr << "NULL ptr: arsprofile_api->get_ars_profile_attribute" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = arsprofile_api->get_ars_profile_attribute((sai_object_id_t)ars_profile_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_ars_profile_attributes(sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  sai_thrift_object_id_t sai_thrift_create_bfd_session(const std::vector<sai_thrift_attribute_t> & attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t bfd_session_oid_out = SAI_NULL_OBJECT_ID;

    sai_bfd_api_t *bfd_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_BFD), (void **)&bfd_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_bfd_session_attributes(attr_list, sai_attr_list);

    if (bfd_api->create_bfd_session == (void *)0) {
        std::cerr << "NULL ptr: bfd_api->create_bfd_session" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = bfd_api->create_bfd_session(&bfd_session_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);    return bfd_session_oid_out;
  }

  void sai_thrift_remove_bfd_session(const sai_thrift_object_id_t bfd_session_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_bfd_api_t *bfd_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_BFD), (void **)&bfd_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    if (bfd_api->remove_bfd_session == (void *)0) {
        std::cerr << "NULL ptr: bfd_api->remove_bfd_session" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = bfd_api->remove_bfd_session((sai_object_id_t)bfd_session_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_bfd_session_attribute(const sai_thrift_object_id_t bfd_session_oid, const sai_thrift_attribute_t& attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t sai_attr;

    sai_bfd_api_t *bfd_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_BFD), (void **)&bfd_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);

    sai_thrift_parse_bfd_session_attributes(attr_vec, &sai_attr);

    if (bfd_api->set_bfd_session_attribute == (void *)0) {
        std::cerr << "NULL ptr: bfd_api->set_bfd_session_attribute" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = bfd_api->set_bfd_session_attribute((sai_object_id_t)bfd_session_oid, &sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_get_bfd_session_attribute(sai_thrift_attribute_list_t& attr_list_out, const sai_thrift_object_id_t bfd_session_oid, const sai_thrift_attribute_list_t& attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_bfd_api_t *bfd_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_BFD), (void **)&bfd_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    else {
      return;
    }


    const std::vector<sai_thrift_attribute_t> &attr_list_vec = attr_list.attr_list;

    sai_thrift_parse_bfd_session_attributes(attr_list_vec, sai_attr_list);

    if (bfd_api->get_bfd_session_attribute == (void *)0) {
        std::cerr << "NULL ptr: bfd_api->get_bfd_session_attribute" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = bfd_api->get_bfd_session_attribute((sai_object_id_t)bfd_session_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_bfd_session_attributes(sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  void sai_thrift_get_bfd_session_stats(std::vector<sai_thrift_uint64_t> & counters_out, const sai_thrift_object_id_t bfd_session_oid, const std::vector<sai_thrift_stat_id_t> & counter_ids) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_bfd_api_t *bfd_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_BFD), (void **)&bfd_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_stat_id_t *sai_counter_ids = NULL;
    uint32_t number_of_counters = counter_ids.size();

    if (number_of_counters != 0) {
      sai_counter_ids = (sai_stat_id_t *)malloc(sizeof(sai_stat_id_t) * number_of_counters);
    }
    else {
      return;
    }


    std::vector<sai_thrift_stat_id_t>::const_iterator it = counter_ids.begin();
    for (uint32_t i = 0; i < counter_ids.size(); i++, it++) {
      sai_counter_ids[i] = (sai_stat_id_t)*it;
    }

    uint64_t *sai_counters = NULL;
    if (number_of_counters != 0) {
      sai_counters = (uint64_t *)malloc(sizeof(uint64_t) * number_of_counters);
    }

    if (bfd_api->get_bfd_session_stats == (void *)0) {
        std::cerr << "NULL ptr: bfd_api->get_bfd_session_stats" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = bfd_api->get_bfd_session_stats((sai_object_id_t)bfd_session_oid, number_of_counters, sai_counter_ids, sai_counters);

    // sai_adapter always takes all bfd stats. Since some of them may be
    // not supported, SAI_STATUS_INVALID_PARAMETER should not be raised.
    if (status != SAI_STATUS_SUCCESS && status != SAI_STATUS_INVALID_PARAMETER) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_counter_ids);
    for (uint32_t i = 0; i < (uint32_t)number_of_counters; i++) {
      counters_out.push_back((sai_thrift_uint64_t)sai_counters[i]);
    }
    free(sai_counters);
    return;
  }

  void sai_thrift_get_bfd_session_stats_ext(std::vector<sai_thrift_uint64_t> & counters_out, const sai_thrift_object_id_t bfd_session_oid, const std::vector<sai_thrift_stat_id_t> & counter_ids, const sai_thrift_stats_mode_t mode) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_bfd_api_t *bfd_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_BFD), (void **)&bfd_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_stat_id_t *sai_counter_ids = NULL;
    uint32_t number_of_counters = counter_ids.size();

    if (number_of_counters != 0) {
      sai_counter_ids = (sai_stat_id_t *)malloc(sizeof(sai_stat_id_t) * number_of_counters);
    }
    else {
      return;
    }


    std::vector<sai_thrift_stat_id_t>::const_iterator it = counter_ids.begin();
    for (uint32_t i = 0; i < counter_ids.size(); i++, it++) {
      sai_counter_ids[i] = (sai_stat_id_t)*it;
    }

    uint64_t *sai_counters = NULL;
    if (number_of_counters != 0) {
      sai_counters = (uint64_t *)malloc(sizeof(uint64_t) * number_of_counters);
    }

    if (bfd_api->get_bfd_session_stats_ext == (void *)0) {
        std::cerr << "NULL ptr: bfd_api->get_bfd_session_stats_ext" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = bfd_api->get_bfd_session_stats_ext((sai_object_id_t)bfd_session_oid, number_of_counters, sai_counter_ids, (sai_stats_mode_t)mode, sai_counters);

    // sai_adapter always takes all bfd stats. Since some of them may be
    // not supported, SAI_STATUS_INVALID_PARAMETER should not be raised.
    if (status != SAI_STATUS_SUCCESS && status != SAI_STATUS_INVALID_PARAMETER) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_counter_ids);
    for (uint32_t i = 0; i < (uint32_t)number_of_counters; i++) {
      counters_out.push_back((sai_thrift_uint64_t)sai_counters[i]);
    }
    free(sai_counters);
    return;
  }

  void sai_thrift_clear_bfd_session_stats(const sai_thrift_object_id_t bfd_session_oid, const std::vector<sai_thrift_stat_id_t> & counter_ids) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_bfd_api_t *bfd_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_BFD), (void **)&bfd_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_stat_id_t *sai_counter_ids = NULL;
    uint32_t number_of_counters = counter_ids.size();

    if (number_of_counters != 0) {
      sai_counter_ids = (sai_stat_id_t *)malloc(sizeof(sai_stat_id_t) * number_of_counters);
    }
    else {
      return;
    }


    std::vector<sai_thrift_stat_id_t>::const_iterator it = counter_ids.begin();
    for (uint32_t i = 0; i < counter_ids.size(); i++, it++) {
      sai_counter_ids[i] = (sai_stat_id_t)*it;
    }

    if (bfd_api->clear_bfd_session_stats == (void *)0) {
        std::cerr << "NULL ptr: bfd_api->clear_bfd_session_stats" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = bfd_api->clear_bfd_session_stats((sai_object_id_t)bfd_session_oid, number_of_counters, sai_counter_ids);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_counter_ids);
    return;
  }

  sai_thrift_object_id_t sai_thrift_create_table_bitmap_classification_entry(const std::vector<sai_thrift_attribute_t> & attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai__api_t *_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_), (void **)&_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    //
if (_api-> == (void *)0) {
        std::cerr << "NULL ptr: _api->" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    //status = 
#ifdef SAI_METHOD_NOT_DEFINED
_api->();

#endif
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_remove_table_bitmap_classification_entry(const sai_thrift_object_id_t table_bitmap_classification_entry_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai__api_t *_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_), (void **)&_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    //
if (_api-> == (void *)0) {
        std::cerr << "NULL ptr: _api->" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    //status = 
#ifdef SAI_METHOD_NOT_DEFINED
_api->();

#endif
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_table_bitmap_classification_entry_attribute(const sai_thrift_object_id_t table_bitmap_classification_entry_oid, const sai_thrift_attribute_t& attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai__api_t *_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_), (void **)&_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    //
if (_api-> == (void *)0) {
        std::cerr << "NULL ptr: _api->" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    //status = 
#ifdef SAI_METHOD_NOT_DEFINED
_api->();

#endif
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_get_table_bitmap_classification_entry_attribute(sai_thrift_attribute_list_t& _out, const sai_thrift_object_id_t table_bitmap_classification_entry_oid, const sai_thrift_attribute_list_t& attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai__api_t *_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_), (void **)&_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    //
if (_api-> == (void *)0) {
        std::cerr << "NULL ptr: _api->" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    //status = 
#ifdef SAI_METHOD_NOT_DEFINED
_api->();

#endif
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_get_table_bitmap_classification_entry_stats(std::vector<sai_thrift_uint64_t> & _out, const sai_thrift_object_id_t table_bitmap_classification_entry_oid, const std::vector<sai_thrift_stat_id_t> & counter_ids) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai__api_t *_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_), (void **)&_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    //
if (_api-> == (void *)0) {
        std::cerr << "NULL ptr: _api->" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    //status = 
#ifdef SAI_METHOD_NOT_DEFINED
_api->();

#endif
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_get_table_bitmap_classification_entry_stats_ext(std::vector<sai_thrift_uint64_t> & _out, const sai_thrift_object_id_t table_bitmap_classification_entry_oid, const std::vector<sai_thrift_stat_id_t> & counter_ids, const sai_thrift_stats_mode_t mode) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai__api_t *_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_), (void **)&_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    //
if (_api-> == (void *)0) {
        std::cerr << "NULL ptr: _api->" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    //status = 
#ifdef SAI_METHOD_NOT_DEFINED
_api->();

#endif
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_clear_table_bitmap_classification_entry_stats(const sai_thrift_object_id_t table_bitmap_classification_entry_oid, const std::vector<sai_thrift_stat_id_t> & counter_ids) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai__api_t *_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_), (void **)&_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    //
if (_api-> == (void *)0) {
        std::cerr << "NULL ptr: _api->" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    //status = 
#ifdef SAI_METHOD_NOT_DEFINED
_api->();

#endif
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  sai_thrift_object_id_t sai_thrift_create_table_bitmap_router_entry(const std::vector<sai_thrift_attribute_t> & attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai__api_t *_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_), (void **)&_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    //
if (_api-> == (void *)0) {
        std::cerr << "NULL ptr: _api->" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    //status = 
#ifdef SAI_METHOD_NOT_DEFINED
_api->();

#endif
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_remove_table_bitmap_router_entry(const sai_thrift_object_id_t table_bitmap_router_entry_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai__api_t *_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_), (void **)&_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    //
if (_api-> == (void *)0) {
        std::cerr << "NULL ptr: _api->" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    //status = 
#ifdef SAI_METHOD_NOT_DEFINED
_api->();

#endif
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_table_bitmap_router_entry_attribute(const sai_thrift_object_id_t table_bitmap_router_entry_oid, const sai_thrift_attribute_t& attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai__api_t *_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_), (void **)&_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    //
if (_api-> == (void *)0) {
        std::cerr << "NULL ptr: _api->" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    //status = 
#ifdef SAI_METHOD_NOT_DEFINED
_api->();

#endif
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_get_table_bitmap_router_entry_attribute(sai_thrift_attribute_list_t& _out, const sai_thrift_object_id_t table_bitmap_router_entry_oid, const sai_thrift_attribute_list_t& attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai__api_t *_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_), (void **)&_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    //
if (_api-> == (void *)0) {
        std::cerr << "NULL ptr: _api->" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    //status = 
#ifdef SAI_METHOD_NOT_DEFINED
_api->();

#endif
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_get_table_bitmap_router_entry_stats(std::vector<sai_thrift_uint64_t> & _out, const sai_thrift_object_id_t table_bitmap_router_entry_oid, const std::vector<sai_thrift_stat_id_t> & counter_ids) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai__api_t *_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_), (void **)&_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    //
if (_api-> == (void *)0) {
        std::cerr << "NULL ptr: _api->" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    //status = 
#ifdef SAI_METHOD_NOT_DEFINED
_api->();

#endif
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_get_table_bitmap_router_entry_stats_ext(std::vector<sai_thrift_uint64_t> & _out, const sai_thrift_object_id_t table_bitmap_router_entry_oid, const std::vector<sai_thrift_stat_id_t> & counter_ids, const sai_thrift_stats_mode_t mode) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai__api_t *_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_), (void **)&_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    //
if (_api-> == (void *)0) {
        std::cerr << "NULL ptr: _api->" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    //status = 
#ifdef SAI_METHOD_NOT_DEFINED
_api->();

#endif
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_clear_table_bitmap_router_entry_stats(const sai_thrift_object_id_t table_bitmap_router_entry_oid, const std::vector<sai_thrift_stat_id_t> & counter_ids) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai__api_t *_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_), (void **)&_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    //
if (_api-> == (void *)0) {
        std::cerr << "NULL ptr: _api->" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    //status = 
#ifdef SAI_METHOD_NOT_DEFINED
_api->();

#endif
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  sai_thrift_object_id_t sai_thrift_create_table_meta_tunnel_entry(const std::vector<sai_thrift_attribute_t> & attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai__api_t *_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_), (void **)&_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    //
if (_api-> == (void *)0) {
        std::cerr << "NULL ptr: _api->" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    //status = 
#ifdef SAI_METHOD_NOT_DEFINED
_api->();

#endif
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_remove_table_meta_tunnel_entry(const sai_thrift_object_id_t table_meta_tunnel_entry_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai__api_t *_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_), (void **)&_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    //
if (_api-> == (void *)0) {
        std::cerr << "NULL ptr: _api->" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    //status = 
#ifdef SAI_METHOD_NOT_DEFINED
_api->();

#endif
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_table_meta_tunnel_entry_attribute(const sai_thrift_object_id_t table_meta_tunnel_entry_oid, const sai_thrift_attribute_t& attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai__api_t *_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_), (void **)&_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    //
if (_api-> == (void *)0) {
        std::cerr << "NULL ptr: _api->" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    //status = 
#ifdef SAI_METHOD_NOT_DEFINED
_api->();

#endif
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_get_table_meta_tunnel_entry_attribute(sai_thrift_attribute_list_t& _out, const sai_thrift_object_id_t table_meta_tunnel_entry_oid, const sai_thrift_attribute_list_t& attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai__api_t *_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_), (void **)&_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    //
if (_api-> == (void *)0) {
        std::cerr << "NULL ptr: _api->" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    //status = 
#ifdef SAI_METHOD_NOT_DEFINED
_api->();

#endif
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_get_table_meta_tunnel_entry_stats(std::vector<sai_thrift_uint64_t> & _out, const sai_thrift_object_id_t table_meta_tunnel_entry_oid, const std::vector<sai_thrift_stat_id_t> & counter_ids) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai__api_t *_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_), (void **)&_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    //
if (_api-> == (void *)0) {
        std::cerr << "NULL ptr: _api->" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    //status = 
#ifdef SAI_METHOD_NOT_DEFINED
_api->();

#endif
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_get_table_meta_tunnel_entry_stats_ext(std::vector<sai_thrift_uint64_t> & _out, const sai_thrift_object_id_t table_meta_tunnel_entry_oid, const std::vector<sai_thrift_stat_id_t> & counter_ids, const sai_thrift_stats_mode_t mode) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai__api_t *_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_), (void **)&_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    //
if (_api-> == (void *)0) {
        std::cerr << "NULL ptr: _api->" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    //status = 
#ifdef SAI_METHOD_NOT_DEFINED
_api->();

#endif
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_clear_table_meta_tunnel_entry_stats(const sai_thrift_object_id_t table_meta_tunnel_entry_oid, const std::vector<sai_thrift_stat_id_t> & counter_ids) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai__api_t *_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_), (void **)&_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    //
if (_api-> == (void *)0) {
        std::cerr << "NULL ptr: _api->" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    //status = 
#ifdef SAI_METHOD_NOT_DEFINED
_api->();

#endif
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  sai_thrift_object_id_t sai_thrift_create_bridge_port(const std::vector<sai_thrift_attribute_t> & attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t bridge_port_oid_out = SAI_NULL_OBJECT_ID;

    sai_bridge_api_t *bridge_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_BRIDGE), (void **)&bridge_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_bridge_port_attributes(attr_list, sai_attr_list);

    if (bridge_api->create_bridge_port == (void *)0) {
        std::cerr << "NULL ptr: bridge_api->create_bridge_port" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = bridge_api->create_bridge_port(&bridge_port_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);    return bridge_port_oid_out;
  }

  void sai_thrift_remove_bridge_port(const sai_thrift_object_id_t bridge_port_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_bridge_api_t *bridge_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_BRIDGE), (void **)&bridge_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    if (bridge_api->remove_bridge_port == (void *)0) {
        std::cerr << "NULL ptr: bridge_api->remove_bridge_port" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = bridge_api->remove_bridge_port((sai_object_id_t)bridge_port_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_bridge_port_attribute(const sai_thrift_object_id_t bridge_port_oid, const sai_thrift_attribute_t& attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t sai_attr;

    sai_bridge_api_t *bridge_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_BRIDGE), (void **)&bridge_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);

    sai_thrift_parse_bridge_port_attributes(attr_vec, &sai_attr);

    if (bridge_api->set_bridge_port_attribute == (void *)0) {
        std::cerr << "NULL ptr: bridge_api->set_bridge_port_attribute" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = bridge_api->set_bridge_port_attribute((sai_object_id_t)bridge_port_oid, &sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_get_bridge_port_attribute(sai_thrift_attribute_list_t& attr_list_out, const sai_thrift_object_id_t bridge_port_oid, const sai_thrift_attribute_list_t& attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_bridge_api_t *bridge_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_BRIDGE), (void **)&bridge_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    else {
      return;
    }


    const std::vector<sai_thrift_attribute_t> &attr_list_vec = attr_list.attr_list;

    sai_thrift_parse_bridge_port_attributes(attr_list_vec, sai_attr_list);

    if (bridge_api->get_bridge_port_attribute == (void *)0) {
        std::cerr << "NULL ptr: bridge_api->get_bridge_port_attribute" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = bridge_api->get_bridge_port_attribute((sai_object_id_t)bridge_port_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_bridge_port_attributes(sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  void sai_thrift_get_bridge_port_stats(std::vector<sai_thrift_uint64_t> & counters_out, const sai_thrift_object_id_t bridge_port_oid, const std::vector<sai_thrift_stat_id_t> & counter_ids) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_bridge_api_t *bridge_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_BRIDGE), (void **)&bridge_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_stat_id_t *sai_counter_ids = NULL;
    uint32_t number_of_counters = counter_ids.size();

    if (number_of_counters != 0) {
      sai_counter_ids = (sai_stat_id_t *)malloc(sizeof(sai_stat_id_t) * number_of_counters);
    }
    else {
      return;
    }


    std::vector<sai_thrift_stat_id_t>::const_iterator it = counter_ids.begin();
    for (uint32_t i = 0; i < counter_ids.size(); i++, it++) {
      sai_counter_ids[i] = (sai_stat_id_t)*it;
    }

    uint64_t *sai_counters = NULL;
    if (number_of_counters != 0) {
      sai_counters = (uint64_t *)malloc(sizeof(uint64_t) * number_of_counters);
    }

    if (bridge_api->get_bridge_port_stats == (void *)0) {
        std::cerr << "NULL ptr: bridge_api->get_bridge_port_stats" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = bridge_api->get_bridge_port_stats((sai_object_id_t)bridge_port_oid, number_of_counters, sai_counter_ids, sai_counters);

    // sai_adapter always takes all bridge stats. Since some of them may be
    // not supported, SAI_STATUS_INVALID_PARAMETER should not be raised.
    if (status != SAI_STATUS_SUCCESS && status != SAI_STATUS_INVALID_PARAMETER) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_counter_ids);
    for (uint32_t i = 0; i < (uint32_t)number_of_counters; i++) {
      counters_out.push_back((sai_thrift_uint64_t)sai_counters[i]);
    }
    free(sai_counters);
    return;
  }

  void sai_thrift_get_bridge_port_stats_ext(std::vector<sai_thrift_uint64_t> & counters_out, const sai_thrift_object_id_t bridge_port_oid, const std::vector<sai_thrift_stat_id_t> & counter_ids, const sai_thrift_stats_mode_t mode) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_bridge_api_t *bridge_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_BRIDGE), (void **)&bridge_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_stat_id_t *sai_counter_ids = NULL;
    uint32_t number_of_counters = counter_ids.size();

    if (number_of_counters != 0) {
      sai_counter_ids = (sai_stat_id_t *)malloc(sizeof(sai_stat_id_t) * number_of_counters);
    }
    else {
      return;
    }


    std::vector<sai_thrift_stat_id_t>::const_iterator it = counter_ids.begin();
    for (uint32_t i = 0; i < counter_ids.size(); i++, it++) {
      sai_counter_ids[i] = (sai_stat_id_t)*it;
    }

    uint64_t *sai_counters = NULL;
    if (number_of_counters != 0) {
      sai_counters = (uint64_t *)malloc(sizeof(uint64_t) * number_of_counters);
    }

    if (bridge_api->get_bridge_port_stats_ext == (void *)0) {
        std::cerr << "NULL ptr: bridge_api->get_bridge_port_stats_ext" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = bridge_api->get_bridge_port_stats_ext((sai_object_id_t)bridge_port_oid, number_of_counters, sai_counter_ids, (sai_stats_mode_t)mode, sai_counters);

    // sai_adapter always takes all bridge stats. Since some of them may be
    // not supported, SAI_STATUS_INVALID_PARAMETER should not be raised.
    if (status != SAI_STATUS_SUCCESS && status != SAI_STATUS_INVALID_PARAMETER) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_counter_ids);
    for (uint32_t i = 0; i < (uint32_t)number_of_counters; i++) {
      counters_out.push_back((sai_thrift_uint64_t)sai_counters[i]);
    }
    free(sai_counters);
    return;
  }

  void sai_thrift_clear_bridge_port_stats(const sai_thrift_object_id_t bridge_port_oid, const std::vector<sai_thrift_stat_id_t> & counter_ids) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_bridge_api_t *bridge_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_BRIDGE), (void **)&bridge_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_stat_id_t *sai_counter_ids = NULL;
    uint32_t number_of_counters = counter_ids.size();

    if (number_of_counters != 0) {
      sai_counter_ids = (sai_stat_id_t *)malloc(sizeof(sai_stat_id_t) * number_of_counters);
    }
    else {
      return;
    }


    std::vector<sai_thrift_stat_id_t>::const_iterator it = counter_ids.begin();
    for (uint32_t i = 0; i < counter_ids.size(); i++, it++) {
      sai_counter_ids[i] = (sai_stat_id_t)*it;
    }

    if (bridge_api->clear_bridge_port_stats == (void *)0) {
        std::cerr << "NULL ptr: bridge_api->clear_bridge_port_stats" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = bridge_api->clear_bridge_port_stats((sai_object_id_t)bridge_port_oid, number_of_counters, sai_counter_ids);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_counter_ids);
    return;
  }

  sai_thrift_object_id_t sai_thrift_create_bridge(const std::vector<sai_thrift_attribute_t> & attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t bridge_oid_out = SAI_NULL_OBJECT_ID;

    sai_bridge_api_t *bridge_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_BRIDGE), (void **)&bridge_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_bridge_attributes(attr_list, sai_attr_list);

    if (bridge_api->create_bridge == (void *)0) {
        std::cerr << "NULL ptr: bridge_api->create_bridge" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = bridge_api->create_bridge(&bridge_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);    return bridge_oid_out;
  }

  void sai_thrift_remove_bridge(const sai_thrift_object_id_t bridge_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_bridge_api_t *bridge_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_BRIDGE), (void **)&bridge_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    if (bridge_api->remove_bridge == (void *)0) {
        std::cerr << "NULL ptr: bridge_api->remove_bridge" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = bridge_api->remove_bridge((sai_object_id_t)bridge_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_bridge_attribute(const sai_thrift_object_id_t bridge_oid, const sai_thrift_attribute_t& attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t sai_attr;

    sai_bridge_api_t *bridge_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_BRIDGE), (void **)&bridge_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);

    sai_thrift_parse_bridge_attributes(attr_vec, &sai_attr);

    if (bridge_api->set_bridge_attribute == (void *)0) {
        std::cerr << "NULL ptr: bridge_api->set_bridge_attribute" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = bridge_api->set_bridge_attribute((sai_object_id_t)bridge_oid, &sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_get_bridge_attribute(sai_thrift_attribute_list_t& attr_list_out, const sai_thrift_object_id_t bridge_oid, const sai_thrift_attribute_list_t& attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_bridge_api_t *bridge_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_BRIDGE), (void **)&bridge_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    else {
      return;
    }


    const std::vector<sai_thrift_attribute_t> &attr_list_vec = attr_list.attr_list;

    sai_thrift_parse_bridge_attributes(attr_list_vec, sai_attr_list);

    if (bridge_api->get_bridge_attribute == (void *)0) {
        std::cerr << "NULL ptr: bridge_api->get_bridge_attribute" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = bridge_api->get_bridge_attribute((sai_object_id_t)bridge_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_bridge_attributes(sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  void sai_thrift_get_bridge_stats(std::vector<sai_thrift_uint64_t> & counters_out, const sai_thrift_object_id_t bridge_oid, const std::vector<sai_thrift_stat_id_t> & counter_ids) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_bridge_api_t *bridge_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_BRIDGE), (void **)&bridge_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_stat_id_t *sai_counter_ids = NULL;
    uint32_t number_of_counters = counter_ids.size();

    if (number_of_counters != 0) {
      sai_counter_ids = (sai_stat_id_t *)malloc(sizeof(sai_stat_id_t) * number_of_counters);
    }
    else {
      return;
    }


    std::vector<sai_thrift_stat_id_t>::const_iterator it = counter_ids.begin();
    for (uint32_t i = 0; i < counter_ids.size(); i++, it++) {
      sai_counter_ids[i] = (sai_stat_id_t)*it;
    }

    uint64_t *sai_counters = NULL;
    if (number_of_counters != 0) {
      sai_counters = (uint64_t *)malloc(sizeof(uint64_t) * number_of_counters);
    }

    if (bridge_api->get_bridge_stats == (void *)0) {
        std::cerr << "NULL ptr: bridge_api->get_bridge_stats" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = bridge_api->get_bridge_stats((sai_object_id_t)bridge_oid, number_of_counters, sai_counter_ids, sai_counters);

    // sai_adapter always takes all bridge stats. Since some of them may be
    // not supported, SAI_STATUS_INVALID_PARAMETER should not be raised.
    if (status != SAI_STATUS_SUCCESS && status != SAI_STATUS_INVALID_PARAMETER) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_counter_ids);
    for (uint32_t i = 0; i < (uint32_t)number_of_counters; i++) {
      counters_out.push_back((sai_thrift_uint64_t)sai_counters[i]);
    }
    free(sai_counters);
    return;
  }

  void sai_thrift_get_bridge_stats_ext(std::vector<sai_thrift_uint64_t> & counters_out, const sai_thrift_object_id_t bridge_oid, const std::vector<sai_thrift_stat_id_t> & counter_ids, const sai_thrift_stats_mode_t mode) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_bridge_api_t *bridge_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_BRIDGE), (void **)&bridge_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_stat_id_t *sai_counter_ids = NULL;
    uint32_t number_of_counters = counter_ids.size();

    if (number_of_counters != 0) {
      sai_counter_ids = (sai_stat_id_t *)malloc(sizeof(sai_stat_id_t) * number_of_counters);
    }
    else {
      return;
    }


    std::vector<sai_thrift_stat_id_t>::const_iterator it = counter_ids.begin();
    for (uint32_t i = 0; i < counter_ids.size(); i++, it++) {
      sai_counter_ids[i] = (sai_stat_id_t)*it;
    }

    uint64_t *sai_counters = NULL;
    if (number_of_counters != 0) {
      sai_counters = (uint64_t *)malloc(sizeof(uint64_t) * number_of_counters);
    }

    if (bridge_api->get_bridge_stats_ext == (void *)0) {
        std::cerr << "NULL ptr: bridge_api->get_bridge_stats_ext" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = bridge_api->get_bridge_stats_ext((sai_object_id_t)bridge_oid, number_of_counters, sai_counter_ids, (sai_stats_mode_t)mode, sai_counters);

    // sai_adapter always takes all bridge stats. Since some of them may be
    // not supported, SAI_STATUS_INVALID_PARAMETER should not be raised.
    if (status != SAI_STATUS_SUCCESS && status != SAI_STATUS_INVALID_PARAMETER) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_counter_ids);
    for (uint32_t i = 0; i < (uint32_t)number_of_counters; i++) {
      counters_out.push_back((sai_thrift_uint64_t)sai_counters[i]);
    }
    free(sai_counters);
    return;
  }

  void sai_thrift_clear_bridge_stats(const sai_thrift_object_id_t bridge_oid, const std::vector<sai_thrift_stat_id_t> & counter_ids) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_bridge_api_t *bridge_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_BRIDGE), (void **)&bridge_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_stat_id_t *sai_counter_ids = NULL;
    uint32_t number_of_counters = counter_ids.size();

    if (number_of_counters != 0) {
      sai_counter_ids = (sai_stat_id_t *)malloc(sizeof(sai_stat_id_t) * number_of_counters);
    }
    else {
      return;
    }


    std::vector<sai_thrift_stat_id_t>::const_iterator it = counter_ids.begin();
    for (uint32_t i = 0; i < counter_ids.size(); i++, it++) {
      sai_counter_ids[i] = (sai_stat_id_t)*it;
    }

    if (bridge_api->clear_bridge_stats == (void *)0) {
        std::cerr << "NULL ptr: bridge_api->clear_bridge_stats" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = bridge_api->clear_bridge_stats((sai_object_id_t)bridge_oid, number_of_counters, sai_counter_ids);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_counter_ids);
    return;
  }

  sai_thrift_object_id_t sai_thrift_create_ingress_priority_group(const std::vector<sai_thrift_attribute_t> & attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t ingress_priority_group_oid_out = SAI_NULL_OBJECT_ID;

    sai_buffer_api_t *buffer_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_BUFFER), (void **)&buffer_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_ingress_priority_group_attributes(attr_list, sai_attr_list);

    if (buffer_api->create_ingress_priority_group == (void *)0) {
        std::cerr << "NULL ptr: buffer_api->create_ingress_priority_group" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = buffer_api->create_ingress_priority_group(&ingress_priority_group_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);    return ingress_priority_group_oid_out;
  }

  void sai_thrift_remove_ingress_priority_group(const sai_thrift_object_id_t ingress_priority_group_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_buffer_api_t *buffer_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_BUFFER), (void **)&buffer_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    if (buffer_api->remove_ingress_priority_group == (void *)0) {
        std::cerr << "NULL ptr: buffer_api->remove_ingress_priority_group" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = buffer_api->remove_ingress_priority_group((sai_object_id_t)ingress_priority_group_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_ingress_priority_group_attribute(const sai_thrift_object_id_t ingress_priority_group_oid, const sai_thrift_attribute_t& attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t sai_attr;

    sai_buffer_api_t *buffer_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_BUFFER), (void **)&buffer_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);

    sai_thrift_parse_ingress_priority_group_attributes(attr_vec, &sai_attr);

    if (buffer_api->set_ingress_priority_group_attribute == (void *)0) {
        std::cerr << "NULL ptr: buffer_api->set_ingress_priority_group_attribute" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = buffer_api->set_ingress_priority_group_attribute((sai_object_id_t)ingress_priority_group_oid, &sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_get_ingress_priority_group_attribute(sai_thrift_attribute_list_t& attr_list_out, const sai_thrift_object_id_t ingress_priority_group_oid, const sai_thrift_attribute_list_t& attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_buffer_api_t *buffer_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_BUFFER), (void **)&buffer_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    else {
      return;
    }


    const std::vector<sai_thrift_attribute_t> &attr_list_vec = attr_list.attr_list;

    sai_thrift_parse_ingress_priority_group_attributes(attr_list_vec, sai_attr_list);

    if (buffer_api->get_ingress_priority_group_attribute == (void *)0) {
        std::cerr << "NULL ptr: buffer_api->get_ingress_priority_group_attribute" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = buffer_api->get_ingress_priority_group_attribute((sai_object_id_t)ingress_priority_group_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_ingress_priority_group_attributes(sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  void sai_thrift_get_ingress_priority_group_stats(std::vector<sai_thrift_uint64_t> & counters_out, const sai_thrift_object_id_t ingress_priority_group_oid, const std::vector<sai_thrift_stat_id_t> & counter_ids) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_buffer_api_t *buffer_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_BUFFER), (void **)&buffer_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_stat_id_t *sai_counter_ids = NULL;
    uint32_t number_of_counters = counter_ids.size();

    if (number_of_counters != 0) {
      sai_counter_ids = (sai_stat_id_t *)malloc(sizeof(sai_stat_id_t) * number_of_counters);
    }
    else {
      return;
    }


    std::vector<sai_thrift_stat_id_t>::const_iterator it = counter_ids.begin();
    for (uint32_t i = 0; i < counter_ids.size(); i++, it++) {
      sai_counter_ids[i] = (sai_stat_id_t)*it;
    }

    uint64_t *sai_counters = NULL;
    if (number_of_counters != 0) {
      sai_counters = (uint64_t *)malloc(sizeof(uint64_t) * number_of_counters);
    }

    if (buffer_api->get_ingress_priority_group_stats == (void *)0) {
        std::cerr << "NULL ptr: buffer_api->get_ingress_priority_group_stats" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = buffer_api->get_ingress_priority_group_stats((sai_object_id_t)ingress_priority_group_oid, number_of_counters, sai_counter_ids, sai_counters);

    // sai_adapter always takes all buffer stats. Since some of them may be
    // not supported, SAI_STATUS_INVALID_PARAMETER should not be raised.
    if (status != SAI_STATUS_SUCCESS && status != SAI_STATUS_INVALID_PARAMETER) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_counter_ids);
    for (uint32_t i = 0; i < (uint32_t)number_of_counters; i++) {
      counters_out.push_back((sai_thrift_uint64_t)sai_counters[i]);
    }
    free(sai_counters);
    return;
  }

  void sai_thrift_get_ingress_priority_group_stats_ext(std::vector<sai_thrift_uint64_t> & counters_out, const sai_thrift_object_id_t ingress_priority_group_oid, const std::vector<sai_thrift_stat_id_t> & counter_ids, const sai_thrift_stats_mode_t mode) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_buffer_api_t *buffer_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_BUFFER), (void **)&buffer_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_stat_id_t *sai_counter_ids = NULL;
    uint32_t number_of_counters = counter_ids.size();

    if (number_of_counters != 0) {
      sai_counter_ids = (sai_stat_id_t *)malloc(sizeof(sai_stat_id_t) * number_of_counters);
    }
    else {
      return;
    }


    std::vector<sai_thrift_stat_id_t>::const_iterator it = counter_ids.begin();
    for (uint32_t i = 0; i < counter_ids.size(); i++, it++) {
      sai_counter_ids[i] = (sai_stat_id_t)*it;
    }

    uint64_t *sai_counters = NULL;
    if (number_of_counters != 0) {
      sai_counters = (uint64_t *)malloc(sizeof(uint64_t) * number_of_counters);
    }

    if (buffer_api->get_ingress_priority_group_stats_ext == (void *)0) {
        std::cerr << "NULL ptr: buffer_api->get_ingress_priority_group_stats_ext" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = buffer_api->get_ingress_priority_group_stats_ext((sai_object_id_t)ingress_priority_group_oid, number_of_counters, sai_counter_ids, (sai_stats_mode_t)mode, sai_counters);

    // sai_adapter always takes all buffer stats. Since some of them may be
    // not supported, SAI_STATUS_INVALID_PARAMETER should not be raised.
    if (status != SAI_STATUS_SUCCESS && status != SAI_STATUS_INVALID_PARAMETER) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_counter_ids);
    for (uint32_t i = 0; i < (uint32_t)number_of_counters; i++) {
      counters_out.push_back((sai_thrift_uint64_t)sai_counters[i]);
    }
    free(sai_counters);
    return;
  }

  void sai_thrift_clear_ingress_priority_group_stats(const sai_thrift_object_id_t ingress_priority_group_oid, const std::vector<sai_thrift_stat_id_t> & counter_ids) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_buffer_api_t *buffer_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_BUFFER), (void **)&buffer_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_stat_id_t *sai_counter_ids = NULL;
    uint32_t number_of_counters = counter_ids.size();

    if (number_of_counters != 0) {
      sai_counter_ids = (sai_stat_id_t *)malloc(sizeof(sai_stat_id_t) * number_of_counters);
    }
    else {
      return;
    }


    std::vector<sai_thrift_stat_id_t>::const_iterator it = counter_ids.begin();
    for (uint32_t i = 0; i < counter_ids.size(); i++, it++) {
      sai_counter_ids[i] = (sai_stat_id_t)*it;
    }

    if (buffer_api->clear_ingress_priority_group_stats == (void *)0) {
        std::cerr << "NULL ptr: buffer_api->clear_ingress_priority_group_stats" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = buffer_api->clear_ingress_priority_group_stats((sai_object_id_t)ingress_priority_group_oid, number_of_counters, sai_counter_ids);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_counter_ids);
    return;
  }

  sai_thrift_object_id_t sai_thrift_create_buffer_pool(const std::vector<sai_thrift_attribute_t> & attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t buffer_pool_oid_out = SAI_NULL_OBJECT_ID;

    sai_buffer_api_t *buffer_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_BUFFER), (void **)&buffer_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_buffer_pool_attributes(attr_list, sai_attr_list);

    if (buffer_api->create_buffer_pool == (void *)0) {
        std::cerr << "NULL ptr: buffer_api->create_buffer_pool" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = buffer_api->create_buffer_pool(&buffer_pool_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);    return buffer_pool_oid_out;
  }

  void sai_thrift_remove_buffer_pool(const sai_thrift_object_id_t buffer_pool_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_buffer_api_t *buffer_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_BUFFER), (void **)&buffer_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    if (buffer_api->remove_buffer_pool == (void *)0) {
        std::cerr << "NULL ptr: buffer_api->remove_buffer_pool" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = buffer_api->remove_buffer_pool((sai_object_id_t)buffer_pool_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_buffer_pool_attribute(const sai_thrift_object_id_t buffer_pool_oid, const sai_thrift_attribute_t& attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t sai_attr;

    sai_buffer_api_t *buffer_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_BUFFER), (void **)&buffer_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);

    sai_thrift_parse_buffer_pool_attributes(attr_vec, &sai_attr);

    if (buffer_api->set_buffer_pool_attribute == (void *)0) {
        std::cerr << "NULL ptr: buffer_api->set_buffer_pool_attribute" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = buffer_api->set_buffer_pool_attribute((sai_object_id_t)buffer_pool_oid, &sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_get_buffer_pool_attribute(sai_thrift_attribute_list_t& attr_list_out, const sai_thrift_object_id_t buffer_pool_oid, const sai_thrift_attribute_list_t& attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_buffer_api_t *buffer_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_BUFFER), (void **)&buffer_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    else {
      return;
    }


    const std::vector<sai_thrift_attribute_t> &attr_list_vec = attr_list.attr_list;

    sai_thrift_parse_buffer_pool_attributes(attr_list_vec, sai_attr_list);

    if (buffer_api->get_buffer_pool_attribute == (void *)0) {
        std::cerr << "NULL ptr: buffer_api->get_buffer_pool_attribute" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = buffer_api->get_buffer_pool_attribute((sai_object_id_t)buffer_pool_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_buffer_pool_attributes(sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  void sai_thrift_get_buffer_pool_stats(std::vector<sai_thrift_uint64_t> & counters_out, const sai_thrift_object_id_t buffer_pool_oid, const std::vector<sai_thrift_stat_id_t> & counter_ids) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_buffer_api_t *buffer_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_BUFFER), (void **)&buffer_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_stat_id_t *sai_counter_ids = NULL;
    uint32_t number_of_counters = counter_ids.size();

    if (number_of_counters != 0) {
      sai_counter_ids = (sai_stat_id_t *)malloc(sizeof(sai_stat_id_t) * number_of_counters);
    }
    else {
      return;
    }


    std::vector<sai_thrift_stat_id_t>::const_iterator it = counter_ids.begin();
    for (uint32_t i = 0; i < counter_ids.size(); i++, it++) {
      sai_counter_ids[i] = (sai_stat_id_t)*it;
    }

    uint64_t *sai_counters = NULL;
    if (number_of_counters != 0) {
      sai_counters = (uint64_t *)malloc(sizeof(uint64_t) * number_of_counters);
    }

    if (buffer_api->get_buffer_pool_stats == (void *)0) {
        std::cerr << "NULL ptr: buffer_api->get_buffer_pool_stats" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = buffer_api->get_buffer_pool_stats((sai_object_id_t)buffer_pool_oid, number_of_counters, sai_counter_ids, sai_counters);

    // sai_adapter always takes all buffer stats. Since some of them may be
    // not supported, SAI_STATUS_INVALID_PARAMETER should not be raised.
    if (status != SAI_STATUS_SUCCESS && status != SAI_STATUS_INVALID_PARAMETER) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_counter_ids);
    for (uint32_t i = 0; i < (uint32_t)number_of_counters; i++) {
      counters_out.push_back((sai_thrift_uint64_t)sai_counters[i]);
    }
    free(sai_counters);
    return;
  }

  void sai_thrift_get_buffer_pool_stats_ext(std::vector<sai_thrift_uint64_t> & counters_out, const sai_thrift_object_id_t buffer_pool_oid, const std::vector<sai_thrift_stat_id_t> & counter_ids, const sai_thrift_stats_mode_t mode) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_buffer_api_t *buffer_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_BUFFER), (void **)&buffer_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_stat_id_t *sai_counter_ids = NULL;
    uint32_t number_of_counters = counter_ids.size();

    if (number_of_counters != 0) {
      sai_counter_ids = (sai_stat_id_t *)malloc(sizeof(sai_stat_id_t) * number_of_counters);
    }
    else {
      return;
    }


    std::vector<sai_thrift_stat_id_t>::const_iterator it = counter_ids.begin();
    for (uint32_t i = 0; i < counter_ids.size(); i++, it++) {
      sai_counter_ids[i] = (sai_stat_id_t)*it;
    }

    uint64_t *sai_counters = NULL;
    if (number_of_counters != 0) {
      sai_counters = (uint64_t *)malloc(sizeof(uint64_t) * number_of_counters);
    }

    if (buffer_api->get_buffer_pool_stats_ext == (void *)0) {
        std::cerr << "NULL ptr: buffer_api->get_buffer_pool_stats_ext" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = buffer_api->get_buffer_pool_stats_ext((sai_object_id_t)buffer_pool_oid, number_of_counters, sai_counter_ids, (sai_stats_mode_t)mode, sai_counters);

    // sai_adapter always takes all buffer stats. Since some of them may be
    // not supported, SAI_STATUS_INVALID_PARAMETER should not be raised.
    if (status != SAI_STATUS_SUCCESS && status != SAI_STATUS_INVALID_PARAMETER) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_counter_ids);
    for (uint32_t i = 0; i < (uint32_t)number_of_counters; i++) {
      counters_out.push_back((sai_thrift_uint64_t)sai_counters[i]);
    }
    free(sai_counters);
    return;
  }

  void sai_thrift_clear_buffer_pool_stats(const sai_thrift_object_id_t buffer_pool_oid, const std::vector<sai_thrift_stat_id_t> & counter_ids) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_buffer_api_t *buffer_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_BUFFER), (void **)&buffer_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_stat_id_t *sai_counter_ids = NULL;
    uint32_t number_of_counters = counter_ids.size();

    if (number_of_counters != 0) {
      sai_counter_ids = (sai_stat_id_t *)malloc(sizeof(sai_stat_id_t) * number_of_counters);
    }
    else {
      return;
    }


    std::vector<sai_thrift_stat_id_t>::const_iterator it = counter_ids.begin();
    for (uint32_t i = 0; i < counter_ids.size(); i++, it++) {
      sai_counter_ids[i] = (sai_stat_id_t)*it;
    }

    if (buffer_api->clear_buffer_pool_stats == (void *)0) {
        std::cerr << "NULL ptr: buffer_api->clear_buffer_pool_stats" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = buffer_api->clear_buffer_pool_stats((sai_object_id_t)buffer_pool_oid, number_of_counters, sai_counter_ids);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_counter_ids);
    return;
  }

  sai_thrift_object_id_t sai_thrift_create_buffer_profile(const std::vector<sai_thrift_attribute_t> & attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t buffer_profile_oid_out = SAI_NULL_OBJECT_ID;

    sai_buffer_api_t *buffer_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_BUFFER), (void **)&buffer_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_buffer_profile_attributes(attr_list, sai_attr_list);

    if (buffer_api->create_buffer_profile == (void *)0) {
        std::cerr << "NULL ptr: buffer_api->create_buffer_profile" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = buffer_api->create_buffer_profile(&buffer_profile_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);    return buffer_profile_oid_out;
  }

  void sai_thrift_remove_buffer_profile(const sai_thrift_object_id_t buffer_profile_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_buffer_api_t *buffer_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_BUFFER), (void **)&buffer_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    if (buffer_api->remove_buffer_profile == (void *)0) {
        std::cerr << "NULL ptr: buffer_api->remove_buffer_profile" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = buffer_api->remove_buffer_profile((sai_object_id_t)buffer_profile_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_buffer_profile_attribute(const sai_thrift_object_id_t buffer_profile_oid, const sai_thrift_attribute_t& attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t sai_attr;

    sai_buffer_api_t *buffer_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_BUFFER), (void **)&buffer_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);

    sai_thrift_parse_buffer_profile_attributes(attr_vec, &sai_attr);

    if (buffer_api->set_buffer_profile_attribute == (void *)0) {
        std::cerr << "NULL ptr: buffer_api->set_buffer_profile_attribute" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = buffer_api->set_buffer_profile_attribute((sai_object_id_t)buffer_profile_oid, &sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_get_buffer_profile_attribute(sai_thrift_attribute_list_t& attr_list_out, const sai_thrift_object_id_t buffer_profile_oid, const sai_thrift_attribute_list_t& attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_buffer_api_t *buffer_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_BUFFER), (void **)&buffer_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    else {
      return;
    }


    const std::vector<sai_thrift_attribute_t> &attr_list_vec = attr_list.attr_list;

    sai_thrift_parse_buffer_profile_attributes(attr_list_vec, sai_attr_list);

    if (buffer_api->get_buffer_profile_attribute == (void *)0) {
        std::cerr << "NULL ptr: buffer_api->get_buffer_profile_attribute" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = buffer_api->get_buffer_profile_attribute((sai_object_id_t)buffer_profile_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_buffer_profile_attributes(sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  sai_thrift_object_id_t sai_thrift_create_counter(const std::vector<sai_thrift_attribute_t> & attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t counter_oid_out = SAI_NULL_OBJECT_ID;

    sai_counter_api_t *counter_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_COUNTER), (void **)&counter_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_counter_attributes(attr_list, sai_attr_list);

    if (counter_api->create_counter == (void *)0) {
        std::cerr << "NULL ptr: counter_api->create_counter" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = counter_api->create_counter(&counter_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);    return counter_oid_out;
  }

  void sai_thrift_remove_counter(const sai_thrift_object_id_t counter_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_counter_api_t *counter_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_COUNTER), (void **)&counter_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    if (counter_api->remove_counter == (void *)0) {
        std::cerr << "NULL ptr: counter_api->remove_counter" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = counter_api->remove_counter((sai_object_id_t)counter_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_counter_attribute(const sai_thrift_object_id_t counter_oid, const sai_thrift_attribute_t& attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t sai_attr;

    sai_counter_api_t *counter_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_COUNTER), (void **)&counter_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);

    sai_thrift_parse_counter_attributes(attr_vec, &sai_attr);

    if (counter_api->set_counter_attribute == (void *)0) {
        std::cerr << "NULL ptr: counter_api->set_counter_attribute" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = counter_api->set_counter_attribute((sai_object_id_t)counter_oid, &sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_get_counter_attribute(sai_thrift_attribute_list_t& attr_list_out, const sai_thrift_object_id_t counter_oid, const sai_thrift_attribute_list_t& attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_counter_api_t *counter_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_COUNTER), (void **)&counter_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    else {
      return;
    }


    const std::vector<sai_thrift_attribute_t> &attr_list_vec = attr_list.attr_list;

    sai_thrift_parse_counter_attributes(attr_list_vec, sai_attr_list);

    if (counter_api->get_counter_attribute == (void *)0) {
        std::cerr << "NULL ptr: counter_api->get_counter_attribute" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = counter_api->get_counter_attribute((sai_object_id_t)counter_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_counter_attributes(sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  void sai_thrift_get_counter_stats(std::vector<sai_thrift_uint64_t> & counters_out, const sai_thrift_object_id_t counter_oid, const std::vector<sai_thrift_stat_id_t> & counter_ids) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_counter_api_t *counter_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_COUNTER), (void **)&counter_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_stat_id_t *sai_counter_ids = NULL;
    uint32_t number_of_counters = counter_ids.size();

    if (number_of_counters != 0) {
      sai_counter_ids = (sai_stat_id_t *)malloc(sizeof(sai_stat_id_t) * number_of_counters);
    }
    else {
      return;
    }


    std::vector<sai_thrift_stat_id_t>::const_iterator it = counter_ids.begin();
    for (uint32_t i = 0; i < counter_ids.size(); i++, it++) {
      sai_counter_ids[i] = (sai_stat_id_t)*it;
    }

    uint64_t *sai_counters = NULL;
    if (number_of_counters != 0) {
      sai_counters = (uint64_t *)malloc(sizeof(uint64_t) * number_of_counters);
    }

    if (counter_api->get_counter_stats == (void *)0) {
        std::cerr << "NULL ptr: counter_api->get_counter_stats" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = counter_api->get_counter_stats((sai_object_id_t)counter_oid, number_of_counters, sai_counter_ids, sai_counters);

    // sai_adapter always takes all counter stats. Since some of them may be
    // not supported, SAI_STATUS_INVALID_PARAMETER should not be raised.
    if (status != SAI_STATUS_SUCCESS && status != SAI_STATUS_INVALID_PARAMETER) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_counter_ids);
    for (uint32_t i = 0; i < (uint32_t)number_of_counters; i++) {
      counters_out.push_back((sai_thrift_uint64_t)sai_counters[i]);
    }
    free(sai_counters);
    return;
  }

  void sai_thrift_get_counter_stats_ext(std::vector<sai_thrift_uint64_t> & counters_out, const sai_thrift_object_id_t counter_oid, const std::vector<sai_thrift_stat_id_t> & counter_ids, const sai_thrift_stats_mode_t mode) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_counter_api_t *counter_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_COUNTER), (void **)&counter_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_stat_id_t *sai_counter_ids = NULL;
    uint32_t number_of_counters = counter_ids.size();

    if (number_of_counters != 0) {
      sai_counter_ids = (sai_stat_id_t *)malloc(sizeof(sai_stat_id_t) * number_of_counters);
    }
    else {
      return;
    }


    std::vector<sai_thrift_stat_id_t>::const_iterator it = counter_ids.begin();
    for (uint32_t i = 0; i < counter_ids.size(); i++, it++) {
      sai_counter_ids[i] = (sai_stat_id_t)*it;
    }

    uint64_t *sai_counters = NULL;
    if (number_of_counters != 0) {
      sai_counters = (uint64_t *)malloc(sizeof(uint64_t) * number_of_counters);
    }

    if (counter_api->get_counter_stats_ext == (void *)0) {
        std::cerr << "NULL ptr: counter_api->get_counter_stats_ext" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = counter_api->get_counter_stats_ext((sai_object_id_t)counter_oid, number_of_counters, sai_counter_ids, (sai_stats_mode_t)mode, sai_counters);

    // sai_adapter always takes all counter stats. Since some of them may be
    // not supported, SAI_STATUS_INVALID_PARAMETER should not be raised.
    if (status != SAI_STATUS_SUCCESS && status != SAI_STATUS_INVALID_PARAMETER) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_counter_ids);
    for (uint32_t i = 0; i < (uint32_t)number_of_counters; i++) {
      counters_out.push_back((sai_thrift_uint64_t)sai_counters[i]);
    }
    free(sai_counters);
    return;
  }

  void sai_thrift_clear_counter_stats(const sai_thrift_object_id_t counter_oid, const std::vector<sai_thrift_stat_id_t> & counter_ids) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_counter_api_t *counter_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_COUNTER), (void **)&counter_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_stat_id_t *sai_counter_ids = NULL;
    uint32_t number_of_counters = counter_ids.size();

    if (number_of_counters != 0) {
      sai_counter_ids = (sai_stat_id_t *)malloc(sizeof(sai_stat_id_t) * number_of_counters);
    }
    else {
      return;
    }


    std::vector<sai_thrift_stat_id_t>::const_iterator it = counter_ids.begin();
    for (uint32_t i = 0; i < counter_ids.size(); i++, it++) {
      sai_counter_ids[i] = (sai_stat_id_t)*it;
    }

    if (counter_api->clear_counter_stats == (void *)0) {
        std::cerr << "NULL ptr: counter_api->clear_counter_stats" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = counter_api->clear_counter_stats((sai_object_id_t)counter_oid, number_of_counters, sai_counter_ids);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_counter_ids);
    return;
  }

  sai_thrift_object_id_t sai_thrift_create_dash_acl_group(const std::vector<sai_thrift_attribute_t> & attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai__api_t *_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_), (void **)&_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    //
if (_api-> == (void *)0) {
        std::cerr << "NULL ptr: _api->" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    //status = 
#ifdef SAI_METHOD_NOT_DEFINED
_api->();

#endif
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_remove_dash_acl_group(const sai_thrift_object_id_t dash_acl_group_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai__api_t *_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_), (void **)&_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    //
if (_api-> == (void *)0) {
        std::cerr << "NULL ptr: _api->" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    //status = 
#ifdef SAI_METHOD_NOT_DEFINED
_api->();

#endif
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_dash_acl_group_attribute(const sai_thrift_object_id_t dash_acl_group_oid, const sai_thrift_attribute_t& attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai__api_t *_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_), (void **)&_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    //
if (_api-> == (void *)0) {
        std::cerr << "NULL ptr: _api->" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    //status = 
#ifdef SAI_METHOD_NOT_DEFINED
_api->();

#endif
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_get_dash_acl_group_attribute(sai_thrift_attribute_list_t& _out, const sai_thrift_object_id_t dash_acl_group_oid, const sai_thrift_attribute_list_t& attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai__api_t *_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_), (void **)&_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    //
if (_api-> == (void *)0) {
        std::cerr << "NULL ptr: _api->" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    //status = 
#ifdef SAI_METHOD_NOT_DEFINED
_api->();

#endif
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  sai_thrift_object_id_t sai_thrift_create_dash_acl_rule(const std::vector<sai_thrift_attribute_t> & attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai__api_t *_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_), (void **)&_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    //
if (_api-> == (void *)0) {
        std::cerr << "NULL ptr: _api->" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    //status = 
#ifdef SAI_METHOD_NOT_DEFINED
_api->();

#endif
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_remove_dash_acl_rule(const sai_thrift_object_id_t dash_acl_rule_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai__api_t *_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_), (void **)&_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    //
if (_api-> == (void *)0) {
        std::cerr << "NULL ptr: _api->" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    //status = 
#ifdef SAI_METHOD_NOT_DEFINED
_api->();

#endif
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_dash_acl_rule_attribute(const sai_thrift_object_id_t dash_acl_rule_oid, const sai_thrift_attribute_t& attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai__api_t *_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_), (void **)&_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    //
if (_api-> == (void *)0) {
        std::cerr << "NULL ptr: _api->" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    //status = 
#ifdef SAI_METHOD_NOT_DEFINED
_api->();

#endif
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_get_dash_acl_rule_attribute(sai_thrift_attribute_list_t& _out, const sai_thrift_object_id_t dash_acl_rule_oid, const sai_thrift_attribute_list_t& attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai__api_t *_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_), (void **)&_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    //
if (_api-> == (void *)0) {
        std::cerr << "NULL ptr: _api->" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    //status = 
#ifdef SAI_METHOD_NOT_DEFINED
_api->();

#endif
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_create_direction_lookup_entry(const sai_thrift_direction_lookup_entry_t& direction_lookup_entry, const std::vector<sai_thrift_attribute_t> & attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai__api_t *_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_), (void **)&_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    //
if (_api-> == (void *)0) {
        std::cerr << "NULL ptr: _api->" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    //status = 
#ifdef SAI_METHOD_NOT_DEFINED
_api->();

#endif
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_remove_direction_lookup_entry(const sai_thrift_direction_lookup_entry_t& direction_lookup_entry) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai__api_t *_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_), (void **)&_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    //
if (_api-> == (void *)0) {
        std::cerr << "NULL ptr: _api->" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    //status = 
#ifdef SAI_METHOD_NOT_DEFINED
_api->();

#endif
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_direction_lookup_entry_attribute(const sai_thrift_direction_lookup_entry_t& direction_lookup_entry, const sai_thrift_attribute_t& attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai__api_t *_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_), (void **)&_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    //
if (_api-> == (void *)0) {
        std::cerr << "NULL ptr: _api->" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    //status = 
#ifdef SAI_METHOD_NOT_DEFINED
_api->();

#endif
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_get_direction_lookup_entry_attribute(sai_thrift_attribute_list_t& _out, const sai_thrift_direction_lookup_entry_t& direction_lookup_entry, const sai_thrift_attribute_list_t& attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai__api_t *_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_), (void **)&_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    //
if (_api-> == (void *)0) {
        std::cerr << "NULL ptr: _api->" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    //status = 
#ifdef SAI_METHOD_NOT_DEFINED
_api->();

#endif
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_bulk_create_direction_lookup_entry(std::vector<sai_thrift_status_t> & _out, const std::vector<sai_thrift_direction_lookup_entry_t> & direction_lookup_entry, const std::vector<sai_thrift_uint32_t> & attr_count, const std::vector<sai_thrift_attribute_t> & attr_list, const sai_thrift_bulk_op_error_mode_t mode) {

    // This function is UNSUPPORTED
    return;
  }

  void sai_thrift_bulk_remove_direction_lookup_entry(std::vector<sai_thrift_status_t> & _out, const std::vector<sai_thrift_direction_lookup_entry_t> & direction_lookup_entry, const sai_thrift_bulk_op_error_mode_t mode) {

    // This function is UNSUPPORTED
    return;
  }

  void sai_thrift_create_eni_ether_address_map_entry(const sai_thrift_eni_ether_address_map_entry_t& eni_ether_address_map_entry, const std::vector<sai_thrift_attribute_t> & attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai__api_t *_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_), (void **)&_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    //
if (_api-> == (void *)0) {
        std::cerr << "NULL ptr: _api->" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    //status = 
#ifdef SAI_METHOD_NOT_DEFINED
_api->();

#endif
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_remove_eni_ether_address_map_entry(const sai_thrift_eni_ether_address_map_entry_t& eni_ether_address_map_entry) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai__api_t *_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_), (void **)&_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    //
if (_api-> == (void *)0) {
        std::cerr << "NULL ptr: _api->" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    //status = 
#ifdef SAI_METHOD_NOT_DEFINED
_api->();

#endif
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_eni_ether_address_map_entry_attribute(const sai_thrift_eni_ether_address_map_entry_t& eni_ether_address_map_entry, const sai_thrift_attribute_t& attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai__api_t *_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_), (void **)&_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    //
if (_api-> == (void *)0) {
        std::cerr << "NULL ptr: _api->" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    //status = 
#ifdef SAI_METHOD_NOT_DEFINED
_api->();

#endif
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_get_eni_ether_address_map_entry_attribute(sai_thrift_attribute_list_t& _out, const sai_thrift_eni_ether_address_map_entry_t& eni_ether_address_map_entry, const sai_thrift_attribute_list_t& attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai__api_t *_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_), (void **)&_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    //
if (_api-> == (void *)0) {
        std::cerr << "NULL ptr: _api->" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    //status = 
#ifdef SAI_METHOD_NOT_DEFINED
_api->();

#endif
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_bulk_create_eni_ether_address_map_entry(std::vector<sai_thrift_status_t> & _out, const std::vector<sai_thrift_eni_ether_address_map_entry_t> & eni_ether_address_map_entry, const std::vector<sai_thrift_uint32_t> & attr_count, const std::vector<sai_thrift_attribute_t> & attr_list, const sai_thrift_bulk_op_error_mode_t mode) {

    // This function is UNSUPPORTED
    return;
  }

  void sai_thrift_bulk_remove_eni_ether_address_map_entry(std::vector<sai_thrift_status_t> & _out, const std::vector<sai_thrift_eni_ether_address_map_entry_t> & eni_ether_address_map_entry, const sai_thrift_bulk_op_error_mode_t mode) {

    // This function is UNSUPPORTED
    return;
  }

  sai_thrift_object_id_t sai_thrift_create_eni(const std::vector<sai_thrift_attribute_t> & attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai__api_t *_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_), (void **)&_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    //
if (_api-> == (void *)0) {
        std::cerr << "NULL ptr: _api->" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    //status = 
#ifdef SAI_METHOD_NOT_DEFINED
_api->();

#endif
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_remove_eni(const sai_thrift_object_id_t eni_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai__api_t *_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_), (void **)&_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    //
if (_api-> == (void *)0) {
        std::cerr << "NULL ptr: _api->" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    //status = 
#ifdef SAI_METHOD_NOT_DEFINED
_api->();

#endif
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_eni_attribute(const sai_thrift_object_id_t eni_oid, const sai_thrift_attribute_t& attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai__api_t *_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_), (void **)&_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    //
if (_api-> == (void *)0) {
        std::cerr << "NULL ptr: _api->" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    //status = 
#ifdef SAI_METHOD_NOT_DEFINED
_api->();

#endif
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_get_eni_attribute(sai_thrift_attribute_list_t& _out, const sai_thrift_object_id_t eni_oid, const sai_thrift_attribute_list_t& attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai__api_t *_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_), (void **)&_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    //
if (_api-> == (void *)0) {
        std::cerr << "NULL ptr: _api->" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    //status = 
#ifdef SAI_METHOD_NOT_DEFINED
_api->();

#endif
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_create_inbound_routing_entry(const sai_thrift_inbound_routing_entry_t& inbound_routing_entry, const std::vector<sai_thrift_attribute_t> & attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai__api_t *_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_), (void **)&_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    //
if (_api-> == (void *)0) {
        std::cerr << "NULL ptr: _api->" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    //status = 
#ifdef SAI_METHOD_NOT_DEFINED
_api->();

#endif
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_remove_inbound_routing_entry(const sai_thrift_inbound_routing_entry_t& inbound_routing_entry) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai__api_t *_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_), (void **)&_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    //
if (_api-> == (void *)0) {
        std::cerr << "NULL ptr: _api->" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    //status = 
#ifdef SAI_METHOD_NOT_DEFINED
_api->();

#endif
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_inbound_routing_entry_attribute(const sai_thrift_inbound_routing_entry_t& inbound_routing_entry, const sai_thrift_attribute_t& attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai__api_t *_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_), (void **)&_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    //
if (_api-> == (void *)0) {
        std::cerr << "NULL ptr: _api->" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    //status = 
#ifdef SAI_METHOD_NOT_DEFINED
_api->();

#endif
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_get_inbound_routing_entry_attribute(sai_thrift_attribute_list_t& _out, const sai_thrift_inbound_routing_entry_t& inbound_routing_entry, const sai_thrift_attribute_list_t& attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai__api_t *_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_), (void **)&_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    //
if (_api-> == (void *)0) {
        std::cerr << "NULL ptr: _api->" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    //status = 
#ifdef SAI_METHOD_NOT_DEFINED
_api->();

#endif
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_bulk_create_inbound_routing_entry(std::vector<sai_thrift_status_t> & _out, const std::vector<sai_thrift_inbound_routing_entry_t> & inbound_routing_entry, const std::vector<sai_thrift_uint32_t> & attr_count, const std::vector<sai_thrift_attribute_t> & attr_list, const sai_thrift_bulk_op_error_mode_t mode) {

    // This function is UNSUPPORTED
    return;
  }

  void sai_thrift_bulk_remove_inbound_routing_entry(std::vector<sai_thrift_status_t> & _out, const std::vector<sai_thrift_inbound_routing_entry_t> & inbound_routing_entry, const sai_thrift_bulk_op_error_mode_t mode) {

    // This function is UNSUPPORTED
    return;
  }

  sai_thrift_object_id_t sai_thrift_create_meter_bucket(const std::vector<sai_thrift_attribute_t> & attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai__api_t *_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_), (void **)&_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    //
if (_api-> == (void *)0) {
        std::cerr << "NULL ptr: _api->" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    //status = 
#ifdef SAI_METHOD_NOT_DEFINED
_api->();

#endif
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_remove_meter_bucket(const sai_thrift_object_id_t meter_bucket_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai__api_t *_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_), (void **)&_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    //
if (_api-> == (void *)0) {
        std::cerr << "NULL ptr: _api->" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    //status = 
#ifdef SAI_METHOD_NOT_DEFINED
_api->();

#endif
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_meter_bucket_attribute(const sai_thrift_object_id_t meter_bucket_oid, const sai_thrift_attribute_t& attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai__api_t *_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_), (void **)&_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    //
if (_api-> == (void *)0) {
        std::cerr << "NULL ptr: _api->" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    //status = 
#ifdef SAI_METHOD_NOT_DEFINED
_api->();

#endif
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_get_meter_bucket_attribute(sai_thrift_attribute_list_t& _out, const sai_thrift_object_id_t meter_bucket_oid, const sai_thrift_attribute_list_t& attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai__api_t *_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_), (void **)&_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    //
if (_api-> == (void *)0) {
        std::cerr << "NULL ptr: _api->" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    //status = 
#ifdef SAI_METHOD_NOT_DEFINED
_api->();

#endif
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  sai_thrift_object_id_t sai_thrift_create_meter_policy(const std::vector<sai_thrift_attribute_t> & attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai__api_t *_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_), (void **)&_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    //
if (_api-> == (void *)0) {
        std::cerr << "NULL ptr: _api->" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    //status = 
#ifdef SAI_METHOD_NOT_DEFINED
_api->();

#endif
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_remove_meter_policy(const sai_thrift_object_id_t meter_policy_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai__api_t *_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_), (void **)&_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    //
if (_api-> == (void *)0) {
        std::cerr << "NULL ptr: _api->" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    //status = 
#ifdef SAI_METHOD_NOT_DEFINED
_api->();

#endif
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_meter_policy_attribute(const sai_thrift_object_id_t meter_policy_oid, const sai_thrift_attribute_t& attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai__api_t *_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_), (void **)&_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    //
if (_api-> == (void *)0) {
        std::cerr << "NULL ptr: _api->" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    //status = 
#ifdef SAI_METHOD_NOT_DEFINED
_api->();

#endif
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_get_meter_policy_attribute(sai_thrift_attribute_list_t& _out, const sai_thrift_object_id_t meter_policy_oid, const sai_thrift_attribute_list_t& attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai__api_t *_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_), (void **)&_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    //
if (_api-> == (void *)0) {
        std::cerr << "NULL ptr: _api->" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    //status = 
#ifdef SAI_METHOD_NOT_DEFINED
_api->();

#endif
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  sai_thrift_object_id_t sai_thrift_create_meter_rule(const std::vector<sai_thrift_attribute_t> & attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai__api_t *_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_), (void **)&_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    //
if (_api-> == (void *)0) {
        std::cerr << "NULL ptr: _api->" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    //status = 
#ifdef SAI_METHOD_NOT_DEFINED
_api->();

#endif
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_remove_meter_rule(const sai_thrift_object_id_t meter_rule_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai__api_t *_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_), (void **)&_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    //
if (_api-> == (void *)0) {
        std::cerr << "NULL ptr: _api->" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    //status = 
#ifdef SAI_METHOD_NOT_DEFINED
_api->();

#endif
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_meter_rule_attribute(const sai_thrift_object_id_t meter_rule_oid, const sai_thrift_attribute_t& attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai__api_t *_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_), (void **)&_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    //
if (_api-> == (void *)0) {
        std::cerr << "NULL ptr: _api->" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    //status = 
#ifdef SAI_METHOD_NOT_DEFINED
_api->();

#endif
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_get_meter_rule_attribute(sai_thrift_attribute_list_t& _out, const sai_thrift_object_id_t meter_rule_oid, const sai_thrift_attribute_list_t& attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai__api_t *_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_), (void **)&_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    //
if (_api-> == (void *)0) {
        std::cerr << "NULL ptr: _api->" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    //status = 
#ifdef SAI_METHOD_NOT_DEFINED
_api->();

#endif
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_create_outbound_ca_to_pa_entry(const sai_thrift_outbound_ca_to_pa_entry_t& outbound_ca_to_pa_entry, const std::vector<sai_thrift_attribute_t> & attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai__api_t *_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_), (void **)&_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    //
if (_api-> == (void *)0) {
        std::cerr << "NULL ptr: _api->" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    //status = 
#ifdef SAI_METHOD_NOT_DEFINED
_api->();

#endif
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_remove_outbound_ca_to_pa_entry(const sai_thrift_outbound_ca_to_pa_entry_t& outbound_ca_to_pa_entry) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai__api_t *_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_), (void **)&_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    //
if (_api-> == (void *)0) {
        std::cerr << "NULL ptr: _api->" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    //status = 
#ifdef SAI_METHOD_NOT_DEFINED
_api->();

#endif
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_outbound_ca_to_pa_entry_attribute(const sai_thrift_outbound_ca_to_pa_entry_t& outbound_ca_to_pa_entry, const sai_thrift_attribute_t& attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai__api_t *_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_), (void **)&_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    //
if (_api-> == (void *)0) {
        std::cerr << "NULL ptr: _api->" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    //status = 
#ifdef SAI_METHOD_NOT_DEFINED
_api->();

#endif
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_get_outbound_ca_to_pa_entry_attribute(sai_thrift_attribute_list_t& _out, const sai_thrift_outbound_ca_to_pa_entry_t& outbound_ca_to_pa_entry, const sai_thrift_attribute_list_t& attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai__api_t *_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_), (void **)&_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    //
if (_api-> == (void *)0) {
        std::cerr << "NULL ptr: _api->" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    //status = 
#ifdef SAI_METHOD_NOT_DEFINED
_api->();

#endif
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_bulk_create_outbound_ca_to_pa_entry(std::vector<sai_thrift_status_t> & _out, const std::vector<sai_thrift_outbound_ca_to_pa_entry_t> & outbound_ca_to_pa_entry, const std::vector<sai_thrift_uint32_t> & attr_count, const std::vector<sai_thrift_attribute_t> & attr_list, const sai_thrift_bulk_op_error_mode_t mode) {

    // This function is UNSUPPORTED
    return;
  }

  void sai_thrift_bulk_remove_outbound_ca_to_pa_entry(std::vector<sai_thrift_status_t> & _out, const std::vector<sai_thrift_outbound_ca_to_pa_entry_t> & outbound_ca_to_pa_entry, const sai_thrift_bulk_op_error_mode_t mode) {

    // This function is UNSUPPORTED
    return;
  }

  void sai_thrift_create_outbound_routing_entry(const sai_thrift_outbound_routing_entry_t& outbound_routing_entry, const std::vector<sai_thrift_attribute_t> & attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai__api_t *_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_), (void **)&_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    //
if (_api-> == (void *)0) {
        std::cerr << "NULL ptr: _api->" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    //status = 
#ifdef SAI_METHOD_NOT_DEFINED
_api->();

#endif
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_remove_outbound_routing_entry(const sai_thrift_outbound_routing_entry_t& outbound_routing_entry) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai__api_t *_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_), (void **)&_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    //
if (_api-> == (void *)0) {
        std::cerr << "NULL ptr: _api->" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    //status = 
#ifdef SAI_METHOD_NOT_DEFINED
_api->();

#endif
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_outbound_routing_entry_attribute(const sai_thrift_outbound_routing_entry_t& outbound_routing_entry, const sai_thrift_attribute_t& attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai__api_t *_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_), (void **)&_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    //
if (_api-> == (void *)0) {
        std::cerr << "NULL ptr: _api->" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    //status = 
#ifdef SAI_METHOD_NOT_DEFINED
_api->();

#endif
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_get_outbound_routing_entry_attribute(sai_thrift_attribute_list_t& _out, const sai_thrift_outbound_routing_entry_t& outbound_routing_entry, const sai_thrift_attribute_list_t& attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai__api_t *_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_), (void **)&_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    //
if (_api-> == (void *)0) {
        std::cerr << "NULL ptr: _api->" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    //status = 
#ifdef SAI_METHOD_NOT_DEFINED
_api->();

#endif
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_bulk_create_outbound_routing_entry(std::vector<sai_thrift_status_t> & _out, const std::vector<sai_thrift_outbound_routing_entry_t> & outbound_routing_entry, const std::vector<sai_thrift_uint32_t> & attr_count, const std::vector<sai_thrift_attribute_t> & attr_list, const sai_thrift_bulk_op_error_mode_t mode) {

    // This function is UNSUPPORTED
    return;
  }

  void sai_thrift_bulk_remove_outbound_routing_entry(std::vector<sai_thrift_status_t> & _out, const std::vector<sai_thrift_outbound_routing_entry_t> & outbound_routing_entry, const sai_thrift_bulk_op_error_mode_t mode) {

    // This function is UNSUPPORTED
    return;
  }

  void sai_thrift_create_pa_validation_entry(const sai_thrift_pa_validation_entry_t& pa_validation_entry, const std::vector<sai_thrift_attribute_t> & attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai__api_t *_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_), (void **)&_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    //
if (_api-> == (void *)0) {
        std::cerr << "NULL ptr: _api->" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    //status = 
#ifdef SAI_METHOD_NOT_DEFINED
_api->();

#endif
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_remove_pa_validation_entry(const sai_thrift_pa_validation_entry_t& pa_validation_entry) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai__api_t *_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_), (void **)&_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    //
if (_api-> == (void *)0) {
        std::cerr << "NULL ptr: _api->" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    //status = 
#ifdef SAI_METHOD_NOT_DEFINED
_api->();

#endif
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_pa_validation_entry_attribute(const sai_thrift_pa_validation_entry_t& pa_validation_entry, const sai_thrift_attribute_t& attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai__api_t *_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_), (void **)&_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    //
if (_api-> == (void *)0) {
        std::cerr << "NULL ptr: _api->" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    //status = 
#ifdef SAI_METHOD_NOT_DEFINED
_api->();

#endif
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_get_pa_validation_entry_attribute(sai_thrift_attribute_list_t& _out, const sai_thrift_pa_validation_entry_t& pa_validation_entry, const sai_thrift_attribute_list_t& attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai__api_t *_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_), (void **)&_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    //
if (_api-> == (void *)0) {
        std::cerr << "NULL ptr: _api->" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    //status = 
#ifdef SAI_METHOD_NOT_DEFINED
_api->();

#endif
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_bulk_create_pa_validation_entry(std::vector<sai_thrift_status_t> & _out, const std::vector<sai_thrift_pa_validation_entry_t> & pa_validation_entry, const std::vector<sai_thrift_uint32_t> & attr_count, const std::vector<sai_thrift_attribute_t> & attr_list, const sai_thrift_bulk_op_error_mode_t mode) {

    // This function is UNSUPPORTED
    return;
  }

  void sai_thrift_bulk_remove_pa_validation_entry(std::vector<sai_thrift_status_t> & _out, const std::vector<sai_thrift_pa_validation_entry_t> & pa_validation_entry, const sai_thrift_bulk_op_error_mode_t mode) {

    // This function is UNSUPPORTED
    return;
  }

  void sai_thrift_create_dst_tag_entry(const sai_thrift_dst_tag_entry_t& dst_tag_entry, const std::vector<sai_thrift_attribute_t> & attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai__api_t *_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_), (void **)&_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    //
if (_api-> == (void *)0) {
        std::cerr << "NULL ptr: _api->" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    //status = 
#ifdef SAI_METHOD_NOT_DEFINED
_api->();

#endif
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_remove_dst_tag_entry(const sai_thrift_dst_tag_entry_t& dst_tag_entry) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai__api_t *_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_), (void **)&_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    //
if (_api-> == (void *)0) {
        std::cerr << "NULL ptr: _api->" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    //status = 
#ifdef SAI_METHOD_NOT_DEFINED
_api->();

#endif
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_dst_tag_entry_attribute(const sai_thrift_dst_tag_entry_t& dst_tag_entry, const sai_thrift_attribute_t& attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai__api_t *_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_), (void **)&_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    //
if (_api-> == (void *)0) {
        std::cerr << "NULL ptr: _api->" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    //status = 
#ifdef SAI_METHOD_NOT_DEFINED
_api->();

#endif
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_get_dst_tag_entry_attribute(sai_thrift_attribute_list_t& _out, const sai_thrift_dst_tag_entry_t& dst_tag_entry, const sai_thrift_attribute_list_t& attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai__api_t *_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_), (void **)&_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    //
if (_api-> == (void *)0) {
        std::cerr << "NULL ptr: _api->" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    //status = 
#ifdef SAI_METHOD_NOT_DEFINED
_api->();

#endif
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_bulk_create_dst_tag_entry(std::vector<sai_thrift_status_t> & _out, const std::vector<sai_thrift_dst_tag_entry_t> & dst_tag_entry, const std::vector<sai_thrift_uint32_t> & attr_count, const std::vector<sai_thrift_attribute_t> & attr_list, const sai_thrift_bulk_op_error_mode_t mode) {

    // This function is UNSUPPORTED
    return;
  }

  void sai_thrift_bulk_remove_dst_tag_entry(std::vector<sai_thrift_status_t> & _out, const std::vector<sai_thrift_dst_tag_entry_t> & dst_tag_entry, const sai_thrift_bulk_op_error_mode_t mode) {

    // This function is UNSUPPORTED
    return;
  }

  void sai_thrift_create_src_tag_entry(const sai_thrift_src_tag_entry_t& src_tag_entry, const std::vector<sai_thrift_attribute_t> & attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai__api_t *_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_), (void **)&_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    //
if (_api-> == (void *)0) {
        std::cerr << "NULL ptr: _api->" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    //status = 
#ifdef SAI_METHOD_NOT_DEFINED
_api->();

#endif
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_remove_src_tag_entry(const sai_thrift_src_tag_entry_t& src_tag_entry) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai__api_t *_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_), (void **)&_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    //
if (_api-> == (void *)0) {
        std::cerr << "NULL ptr: _api->" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    //status = 
#ifdef SAI_METHOD_NOT_DEFINED
_api->();

#endif
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_src_tag_entry_attribute(const sai_thrift_src_tag_entry_t& src_tag_entry, const sai_thrift_attribute_t& attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai__api_t *_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_), (void **)&_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    //
if (_api-> == (void *)0) {
        std::cerr << "NULL ptr: _api->" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    //status = 
#ifdef SAI_METHOD_NOT_DEFINED
_api->();

#endif
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_get_src_tag_entry_attribute(sai_thrift_attribute_list_t& _out, const sai_thrift_src_tag_entry_t& src_tag_entry, const sai_thrift_attribute_list_t& attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai__api_t *_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_), (void **)&_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    //
if (_api-> == (void *)0) {
        std::cerr << "NULL ptr: _api->" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    //status = 
#ifdef SAI_METHOD_NOT_DEFINED
_api->();

#endif
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_bulk_create_src_tag_entry(std::vector<sai_thrift_status_t> & _out, const std::vector<sai_thrift_src_tag_entry_t> & src_tag_entry, const std::vector<sai_thrift_uint32_t> & attr_count, const std::vector<sai_thrift_attribute_t> & attr_list, const sai_thrift_bulk_op_error_mode_t mode) {

    // This function is UNSUPPORTED
    return;
  }

  void sai_thrift_bulk_remove_src_tag_entry(std::vector<sai_thrift_status_t> & _out, const std::vector<sai_thrift_src_tag_entry_t> & src_tag_entry, const sai_thrift_bulk_op_error_mode_t mode) {

    // This function is UNSUPPORTED
    return;
  }

  void sai_thrift_create_vip_entry(const sai_thrift_vip_entry_t& vip_entry, const std::vector<sai_thrift_attribute_t> & attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai__api_t *_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_), (void **)&_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    //
if (_api-> == (void *)0) {
        std::cerr << "NULL ptr: _api->" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    //status = 
#ifdef SAI_METHOD_NOT_DEFINED
_api->();

#endif
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_remove_vip_entry(const sai_thrift_vip_entry_t& vip_entry) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai__api_t *_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_), (void **)&_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    //
if (_api-> == (void *)0) {
        std::cerr << "NULL ptr: _api->" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    //status = 
#ifdef SAI_METHOD_NOT_DEFINED
_api->();

#endif
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_vip_entry_attribute(const sai_thrift_vip_entry_t& vip_entry, const sai_thrift_attribute_t& attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai__api_t *_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_), (void **)&_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    //
if (_api-> == (void *)0) {
        std::cerr << "NULL ptr: _api->" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    //status = 
#ifdef SAI_METHOD_NOT_DEFINED
_api->();

#endif
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_get_vip_entry_attribute(sai_thrift_attribute_list_t& _out, const sai_thrift_vip_entry_t& vip_entry, const sai_thrift_attribute_list_t& attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai__api_t *_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_), (void **)&_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    //
if (_api-> == (void *)0) {
        std::cerr << "NULL ptr: _api->" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    //status = 
#ifdef SAI_METHOD_NOT_DEFINED
_api->();

#endif
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_bulk_create_vip_entry(std::vector<sai_thrift_status_t> & _out, const std::vector<sai_thrift_vip_entry_t> & vip_entry, const std::vector<sai_thrift_uint32_t> & attr_count, const std::vector<sai_thrift_attribute_t> & attr_list, const sai_thrift_bulk_op_error_mode_t mode) {

    // This function is UNSUPPORTED
    return;
  }

  void sai_thrift_bulk_remove_vip_entry(std::vector<sai_thrift_status_t> & _out, const std::vector<sai_thrift_vip_entry_t> & vip_entry, const sai_thrift_bulk_op_error_mode_t mode) {

    // This function is UNSUPPORTED
    return;
  }

  sai_thrift_object_id_t sai_thrift_create_vnet(const std::vector<sai_thrift_attribute_t> & attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai__api_t *_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_), (void **)&_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    //
if (_api-> == (void *)0) {
        std::cerr << "NULL ptr: _api->" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    //status = 
#ifdef SAI_METHOD_NOT_DEFINED
_api->();

#endif
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_remove_vnet(const sai_thrift_object_id_t vnet_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai__api_t *_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_), (void **)&_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    //
if (_api-> == (void *)0) {
        std::cerr << "NULL ptr: _api->" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    //status = 
#ifdef SAI_METHOD_NOT_DEFINED
_api->();

#endif
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_vnet_attribute(const sai_thrift_object_id_t vnet_oid, const sai_thrift_attribute_t& attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai__api_t *_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_), (void **)&_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    //
if (_api-> == (void *)0) {
        std::cerr << "NULL ptr: _api->" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    //status = 
#ifdef SAI_METHOD_NOT_DEFINED
_api->();

#endif
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_get_vnet_attribute(sai_thrift_attribute_list_t& _out, const sai_thrift_object_id_t vnet_oid, const sai_thrift_attribute_list_t& attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai__api_t *_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_), (void **)&_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    //
if (_api-> == (void *)0) {
        std::cerr << "NULL ptr: _api->" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    //status = 
#ifdef SAI_METHOD_NOT_DEFINED
_api->();

#endif
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  sai_thrift_object_id_t sai_thrift_create_debug_counter(const std::vector<sai_thrift_attribute_t> & attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t debug_counter_oid_out = SAI_NULL_OBJECT_ID;

    sai_debugcounter_api_t *debugcounter_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_DEBUGCOUNTER), (void **)&debugcounter_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_debug_counter_attributes(attr_list, sai_attr_list);

    if (debugcounter_api->create_debug_counter == (void *)0) {
        std::cerr << "NULL ptr: debugcounter_api->create_debug_counter" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = debugcounter_api->create_debug_counter(&debug_counter_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);    return debug_counter_oid_out;
  }

  void sai_thrift_remove_debug_counter(const sai_thrift_object_id_t debug_counter_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_debugcounter_api_t *debugcounter_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_DEBUGCOUNTER), (void **)&debugcounter_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    if (debugcounter_api->remove_debug_counter == (void *)0) {
        std::cerr << "NULL ptr: debugcounter_api->remove_debug_counter" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = debugcounter_api->remove_debug_counter((sai_object_id_t)debug_counter_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_debug_counter_attribute(const sai_thrift_object_id_t debug_counter_oid, const sai_thrift_attribute_t& attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t sai_attr;

    sai_debugcounter_api_t *debugcounter_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_DEBUGCOUNTER), (void **)&debugcounter_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);

    sai_thrift_parse_debug_counter_attributes(attr_vec, &sai_attr);

    if (debugcounter_api->set_debug_counter_attribute == (void *)0) {
        std::cerr << "NULL ptr: debugcounter_api->set_debug_counter_attribute" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = debugcounter_api->set_debug_counter_attribute((sai_object_id_t)debug_counter_oid, &sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_get_debug_counter_attribute(sai_thrift_attribute_list_t& attr_list_out, const sai_thrift_object_id_t debug_counter_oid, const sai_thrift_attribute_list_t& attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_debugcounter_api_t *debugcounter_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_DEBUGCOUNTER), (void **)&debugcounter_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    else {
      return;
    }


    const std::vector<sai_thrift_attribute_t> &attr_list_vec = attr_list.attr_list;

    sai_thrift_parse_debug_counter_attributes(attr_list_vec, sai_attr_list);

    if (debugcounter_api->get_debug_counter_attribute == (void *)0) {
        std::cerr << "NULL ptr: debugcounter_api->get_debug_counter_attribute" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = debugcounter_api->get_debug_counter_attribute((sai_object_id_t)debug_counter_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_debug_counter_attributes(sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  sai_thrift_object_id_t sai_thrift_create_dtel(const std::vector<sai_thrift_attribute_t> & attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t dtel_oid_out = SAI_NULL_OBJECT_ID;

    sai_dtel_api_t *dtel_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_DTEL), (void **)&dtel_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_dtel_attributes(attr_list, sai_attr_list);

    if (dtel_api->create_dtel == (void *)0) {
        std::cerr << "NULL ptr: dtel_api->create_dtel" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = dtel_api->create_dtel(&dtel_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);    return dtel_oid_out;
  }

  void sai_thrift_remove_dtel(const sai_thrift_object_id_t dtel_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_dtel_api_t *dtel_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_DTEL), (void **)&dtel_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    if (dtel_api->remove_dtel == (void *)0) {
        std::cerr << "NULL ptr: dtel_api->remove_dtel" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = dtel_api->remove_dtel((sai_object_id_t)dtel_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_dtel_attribute(const sai_thrift_object_id_t dtel_oid, const sai_thrift_attribute_t& attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t sai_attr;

    sai_dtel_api_t *dtel_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_DTEL), (void **)&dtel_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);

    sai_thrift_parse_dtel_attributes(attr_vec, &sai_attr);

    if (dtel_api->set_dtel_attribute == (void *)0) {
        std::cerr << "NULL ptr: dtel_api->set_dtel_attribute" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = dtel_api->set_dtel_attribute((sai_object_id_t)dtel_oid, &sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_get_dtel_attribute(sai_thrift_attribute_list_t& attr_list_out, const sai_thrift_object_id_t dtel_oid, const sai_thrift_attribute_list_t& attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_dtel_api_t *dtel_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_DTEL), (void **)&dtel_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    else {
      return;
    }


    const std::vector<sai_thrift_attribute_t> &attr_list_vec = attr_list.attr_list;

    sai_thrift_parse_dtel_attributes(attr_list_vec, sai_attr_list);

    if (dtel_api->get_dtel_attribute == (void *)0) {
        std::cerr << "NULL ptr: dtel_api->get_dtel_attribute" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = dtel_api->get_dtel_attribute((sai_object_id_t)dtel_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_dtel_attributes(sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  sai_thrift_object_id_t sai_thrift_create_dtel_queue_report(const std::vector<sai_thrift_attribute_t> & attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t dtel_queue_report_oid_out = SAI_NULL_OBJECT_ID;

    sai_dtel_api_t *dtel_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_DTEL), (void **)&dtel_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_dtel_queue_report_attributes(attr_list, sai_attr_list);

    if (dtel_api->create_dtel_queue_report == (void *)0) {
        std::cerr << "NULL ptr: dtel_api->create_dtel_queue_report" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = dtel_api->create_dtel_queue_report(&dtel_queue_report_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);    return dtel_queue_report_oid_out;
  }

  void sai_thrift_remove_dtel_queue_report(const sai_thrift_object_id_t dtel_queue_report_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_dtel_api_t *dtel_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_DTEL), (void **)&dtel_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    if (dtel_api->remove_dtel_queue_report == (void *)0) {
        std::cerr << "NULL ptr: dtel_api->remove_dtel_queue_report" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = dtel_api->remove_dtel_queue_report((sai_object_id_t)dtel_queue_report_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_dtel_queue_report_attribute(const sai_thrift_object_id_t dtel_queue_report_oid, const sai_thrift_attribute_t& attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t sai_attr;

    sai_dtel_api_t *dtel_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_DTEL), (void **)&dtel_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);

    sai_thrift_parse_dtel_queue_report_attributes(attr_vec, &sai_attr);

    if (dtel_api->set_dtel_queue_report_attribute == (void *)0) {
        std::cerr << "NULL ptr: dtel_api->set_dtel_queue_report_attribute" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = dtel_api->set_dtel_queue_report_attribute((sai_object_id_t)dtel_queue_report_oid, &sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_get_dtel_queue_report_attribute(sai_thrift_attribute_list_t& attr_list_out, const sai_thrift_object_id_t dtel_queue_report_oid, const sai_thrift_attribute_list_t& attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_dtel_api_t *dtel_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_DTEL), (void **)&dtel_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    else {
      return;
    }


    const std::vector<sai_thrift_attribute_t> &attr_list_vec = attr_list.attr_list;

    sai_thrift_parse_dtel_queue_report_attributes(attr_list_vec, sai_attr_list);

    if (dtel_api->get_dtel_queue_report_attribute == (void *)0) {
        std::cerr << "NULL ptr: dtel_api->get_dtel_queue_report_attribute" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = dtel_api->get_dtel_queue_report_attribute((sai_object_id_t)dtel_queue_report_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_dtel_queue_report_attributes(sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  sai_thrift_object_id_t sai_thrift_create_dtel_int_session(const std::vector<sai_thrift_attribute_t> & attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t dtel_int_session_oid_out = SAI_NULL_OBJECT_ID;

    sai_dtel_api_t *dtel_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_DTEL), (void **)&dtel_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_dtel_int_session_attributes(attr_list, sai_attr_list);

    if (dtel_api->create_dtel_int_session == (void *)0) {
        std::cerr << "NULL ptr: dtel_api->create_dtel_int_session" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = dtel_api->create_dtel_int_session(&dtel_int_session_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);    return dtel_int_session_oid_out;
  }

  void sai_thrift_remove_dtel_int_session(const sai_thrift_object_id_t dtel_int_session_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_dtel_api_t *dtel_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_DTEL), (void **)&dtel_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    if (dtel_api->remove_dtel_int_session == (void *)0) {
        std::cerr << "NULL ptr: dtel_api->remove_dtel_int_session" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = dtel_api->remove_dtel_int_session((sai_object_id_t)dtel_int_session_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_dtel_int_session_attribute(const sai_thrift_object_id_t dtel_int_session_oid, const sai_thrift_attribute_t& attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t sai_attr;

    sai_dtel_api_t *dtel_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_DTEL), (void **)&dtel_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);

    sai_thrift_parse_dtel_int_session_attributes(attr_vec, &sai_attr);

    if (dtel_api->set_dtel_int_session_attribute == (void *)0) {
        std::cerr << "NULL ptr: dtel_api->set_dtel_int_session_attribute" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = dtel_api->set_dtel_int_session_attribute((sai_object_id_t)dtel_int_session_oid, &sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_get_dtel_int_session_attribute(sai_thrift_attribute_list_t& attr_list_out, const sai_thrift_object_id_t dtel_int_session_oid, const sai_thrift_attribute_list_t& attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_dtel_api_t *dtel_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_DTEL), (void **)&dtel_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    else {
      return;
    }


    const std::vector<sai_thrift_attribute_t> &attr_list_vec = attr_list.attr_list;

    sai_thrift_parse_dtel_int_session_attributes(attr_list_vec, sai_attr_list);

    if (dtel_api->get_dtel_int_session_attribute == (void *)0) {
        std::cerr << "NULL ptr: dtel_api->get_dtel_int_session_attribute" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = dtel_api->get_dtel_int_session_attribute((sai_object_id_t)dtel_int_session_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_dtel_int_session_attributes(sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  sai_thrift_object_id_t sai_thrift_create_dtel_report_session(const std::vector<sai_thrift_attribute_t> & attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t dtel_report_session_oid_out = SAI_NULL_OBJECT_ID;

    sai_dtel_api_t *dtel_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_DTEL), (void **)&dtel_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_dtel_report_session_attributes(attr_list, sai_attr_list);

    if (dtel_api->create_dtel_report_session == (void *)0) {
        std::cerr << "NULL ptr: dtel_api->create_dtel_report_session" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = dtel_api->create_dtel_report_session(&dtel_report_session_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);    return dtel_report_session_oid_out;
  }

  void sai_thrift_remove_dtel_report_session(const sai_thrift_object_id_t dtel_report_session_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_dtel_api_t *dtel_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_DTEL), (void **)&dtel_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    if (dtel_api->remove_dtel_report_session == (void *)0) {
        std::cerr << "NULL ptr: dtel_api->remove_dtel_report_session" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = dtel_api->remove_dtel_report_session((sai_object_id_t)dtel_report_session_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_dtel_report_session_attribute(const sai_thrift_object_id_t dtel_report_session_oid, const sai_thrift_attribute_t& attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t sai_attr;

    sai_dtel_api_t *dtel_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_DTEL), (void **)&dtel_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);

    sai_thrift_parse_dtel_report_session_attributes(attr_vec, &sai_attr);

    if (dtel_api->set_dtel_report_session_attribute == (void *)0) {
        std::cerr << "NULL ptr: dtel_api->set_dtel_report_session_attribute" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = dtel_api->set_dtel_report_session_attribute((sai_object_id_t)dtel_report_session_oid, &sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_get_dtel_report_session_attribute(sai_thrift_attribute_list_t& attr_list_out, const sai_thrift_object_id_t dtel_report_session_oid, const sai_thrift_attribute_list_t& attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_dtel_api_t *dtel_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_DTEL), (void **)&dtel_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    else {
      return;
    }


    const std::vector<sai_thrift_attribute_t> &attr_list_vec = attr_list.attr_list;

    sai_thrift_parse_dtel_report_session_attributes(attr_list_vec, sai_attr_list);

    if (dtel_api->get_dtel_report_session_attribute == (void *)0) {
        std::cerr << "NULL ptr: dtel_api->get_dtel_report_session_attribute" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = dtel_api->get_dtel_report_session_attribute((sai_object_id_t)dtel_report_session_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_dtel_report_session_attributes(sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  sai_thrift_object_id_t sai_thrift_create_dtel_event(const std::vector<sai_thrift_attribute_t> & attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t dtel_event_oid_out = SAI_NULL_OBJECT_ID;

    sai_dtel_api_t *dtel_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_DTEL), (void **)&dtel_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_dtel_event_attributes(attr_list, sai_attr_list);

    if (dtel_api->create_dtel_event == (void *)0) {
        std::cerr << "NULL ptr: dtel_api->create_dtel_event" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = dtel_api->create_dtel_event(&dtel_event_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);    return dtel_event_oid_out;
  }

  void sai_thrift_remove_dtel_event(const sai_thrift_object_id_t dtel_event_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_dtel_api_t *dtel_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_DTEL), (void **)&dtel_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    if (dtel_api->remove_dtel_event == (void *)0) {
        std::cerr << "NULL ptr: dtel_api->remove_dtel_event" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = dtel_api->remove_dtel_event((sai_object_id_t)dtel_event_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_dtel_event_attribute(const sai_thrift_object_id_t dtel_event_oid, const sai_thrift_attribute_t& attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t sai_attr;

    sai_dtel_api_t *dtel_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_DTEL), (void **)&dtel_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);

    sai_thrift_parse_dtel_event_attributes(attr_vec, &sai_attr);

    if (dtel_api->set_dtel_event_attribute == (void *)0) {
        std::cerr << "NULL ptr: dtel_api->set_dtel_event_attribute" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = dtel_api->set_dtel_event_attribute((sai_object_id_t)dtel_event_oid, &sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_get_dtel_event_attribute(sai_thrift_attribute_list_t& attr_list_out, const sai_thrift_object_id_t dtel_event_oid, const sai_thrift_attribute_list_t& attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_dtel_api_t *dtel_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_DTEL), (void **)&dtel_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    else {
      return;
    }


    const std::vector<sai_thrift_attribute_t> &attr_list_vec = attr_list.attr_list;

    sai_thrift_parse_dtel_event_attributes(attr_list_vec, sai_attr_list);

    if (dtel_api->get_dtel_event_attribute == (void *)0) {
        std::cerr << "NULL ptr: dtel_api->get_dtel_event_attribute" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = dtel_api->get_dtel_event_attribute((sai_object_id_t)dtel_event_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_dtel_event_attributes(sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  void sai_thrift_create_fdb_entry(const sai_thrift_fdb_entry_t& fdb_entry, const std::vector<sai_thrift_attribute_t> & attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_fdb_entry_t sai_fdb_entry;

    sai_fdb_api_t *fdb_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_FDB), (void **)&fdb_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_parse_fdb_entry(fdb_entry, &sai_fdb_entry);

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_fdb_entry_attributes(attr_list, sai_attr_list);

    if (fdb_api->create_fdb_entry == (void *)0) {
        std::cerr << "NULL ptr: fdb_api->create_fdb_entry" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = fdb_api->create_fdb_entry(&sai_fdb_entry, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);
    return;
  }

  void sai_thrift_remove_fdb_entry(const sai_thrift_fdb_entry_t& fdb_entry) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_fdb_entry_t sai_fdb_entry;

    sai_fdb_api_t *fdb_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_FDB), (void **)&fdb_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_parse_fdb_entry(fdb_entry, &sai_fdb_entry);

    if (fdb_api->remove_fdb_entry == (void *)0) {
        std::cerr << "NULL ptr: fdb_api->remove_fdb_entry" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = fdb_api->remove_fdb_entry(&sai_fdb_entry);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_fdb_entry_attribute(const sai_thrift_fdb_entry_t& fdb_entry, const sai_thrift_attribute_t& attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_fdb_entry_t sai_fdb_entry;
    sai_attribute_t sai_attr;

    sai_fdb_api_t *fdb_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_FDB), (void **)&fdb_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_parse_fdb_entry(fdb_entry, &sai_fdb_entry);

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);

    sai_thrift_parse_fdb_entry_attributes(attr_vec, &sai_attr);

    if (fdb_api->set_fdb_entry_attribute == (void *)0) {
        std::cerr << "NULL ptr: fdb_api->set_fdb_entry_attribute" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = fdb_api->set_fdb_entry_attribute(&sai_fdb_entry, &sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_get_fdb_entry_attribute(sai_thrift_attribute_list_t& attr_list_out, const sai_thrift_fdb_entry_t& fdb_entry, const sai_thrift_attribute_list_t& attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_fdb_entry_t sai_fdb_entry;

    sai_fdb_api_t *fdb_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_FDB), (void **)&fdb_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_parse_fdb_entry(fdb_entry, &sai_fdb_entry);

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    else {
      return;
    }


    const std::vector<sai_thrift_attribute_t> &attr_list_vec = attr_list.attr_list;

    sai_thrift_parse_fdb_entry_attributes(attr_list_vec, sai_attr_list);

    if (fdb_api->get_fdb_entry_attribute == (void *)0) {
        std::cerr << "NULL ptr: fdb_api->get_fdb_entry_attribute" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = fdb_api->get_fdb_entry_attribute(&sai_fdb_entry, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_fdb_entry_attributes(sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  void sai_thrift_flush_fdb_entries(const std::vector<sai_thrift_attribute_t> & attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_fdb_api_t *fdb_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_FDB), (void **)&fdb_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    else {
      return;
    }

    sai_thrift_parse_fdb_flush_attributes(attr_list, sai_attr_list);

    if (fdb_api->flush_fdb_entries == (void *)0) {
        std::cerr << "NULL ptr: fdb_api->flush_fdb_entries" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = fdb_api->flush_fdb_entries(switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);
    return;
  }

  void sai_thrift_bulk_create_fdb_entry(std::vector<sai_thrift_status_t> & object_statuses_out, const std::vector<sai_thrift_fdb_entry_t> & fdb_entry, const std::vector<sai_thrift_uint32_t> & attr_count, const std::vector<sai_thrift_attribute_t> & attr_list, const sai_thrift_bulk_op_error_mode_t mode) {

    // This function is UNSUPPORTED
    return;
  }

  void sai_thrift_bulk_remove_fdb_entry(std::vector<sai_thrift_status_t> & object_statuses_out, const std::vector<sai_thrift_fdb_entry_t> & fdb_entry, const sai_thrift_bulk_op_error_mode_t mode) {

    // This function is UNSUPPORTED
    return;
  }

  void sai_thrift_bulk_set_fdb_entry_attribute(std::vector<sai_thrift_status_t> & object_statuses_out, const std::vector<sai_thrift_fdb_entry_t> & fdb_entry, const std::vector<sai_thrift_attribute_t> & attr_list, const sai_thrift_bulk_op_error_mode_t mode) {

    // This function is UNSUPPORTED
    return;
  }

  void sai_thrift_bulk_get_fdb_entry_attribute(sai_thrift_attribute_list_t& attr_list_out, const std::vector<sai_thrift_fdb_entry_t> & fdb_entry, const std::vector<sai_thrift_uint32_t> & attr_count, const sai_thrift_attribute_list_t& attr_list, const sai_thrift_bulk_op_error_mode_t mode, const std::vector<sai_thrift_status_t> & object_statuses) {

    // This function is UNSUPPORTED
    return;
  }

  sai_thrift_object_id_t sai_thrift_create_generic_programmable(const std::vector<sai_thrift_attribute_t> & attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t generic_programmable_oid_out = SAI_NULL_OBJECT_ID;

    sai_genericprogrammable_api_t *genericprogrammable_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_GENERICPROGRAMMABLE), (void **)&genericprogrammable_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_generic_programmable_attributes(attr_list, sai_attr_list);

    if (genericprogrammable_api->create_generic_programmable == (void *)0) {
        std::cerr << "NULL ptr: genericprogrammable_api->create_generic_programmable" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = genericprogrammable_api->create_generic_programmable(&generic_programmable_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);    return generic_programmable_oid_out;
  }

  void sai_thrift_remove_generic_programmable(const sai_thrift_object_id_t generic_programmable_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_genericprogrammable_api_t *genericprogrammable_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_GENERICPROGRAMMABLE), (void **)&genericprogrammable_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    if (genericprogrammable_api->remove_generic_programmable == (void *)0) {
        std::cerr << "NULL ptr: genericprogrammable_api->remove_generic_programmable" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = genericprogrammable_api->remove_generic_programmable((sai_object_id_t)generic_programmable_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_generic_programmable_attribute(const sai_thrift_object_id_t generic_programmable_oid, const sai_thrift_attribute_t& attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t sai_attr;

    sai_genericprogrammable_api_t *genericprogrammable_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_GENERICPROGRAMMABLE), (void **)&genericprogrammable_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);

    sai_thrift_parse_generic_programmable_attributes(attr_vec, &sai_attr);

    if (genericprogrammable_api->set_generic_programmable_attribute == (void *)0) {
        std::cerr << "NULL ptr: genericprogrammable_api->set_generic_programmable_attribute" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = genericprogrammable_api->set_generic_programmable_attribute((sai_object_id_t)generic_programmable_oid, &sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_get_generic_programmable_attribute(sai_thrift_attribute_list_t& attr_list_out, const sai_thrift_object_id_t generic_programmable_oid, const sai_thrift_attribute_list_t& attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_genericprogrammable_api_t *genericprogrammable_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_GENERICPROGRAMMABLE), (void **)&genericprogrammable_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    else {
      return;
    }


    const std::vector<sai_thrift_attribute_t> &attr_list_vec = attr_list.attr_list;

    sai_thrift_parse_generic_programmable_attributes(attr_list_vec, sai_attr_list);

    if (genericprogrammable_api->get_generic_programmable_attribute == (void *)0) {
        std::cerr << "NULL ptr: genericprogrammable_api->get_generic_programmable_attribute" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = genericprogrammable_api->get_generic_programmable_attribute((sai_object_id_t)generic_programmable_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_generic_programmable_attributes(sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  sai_thrift_object_id_t sai_thrift_create_fine_grained_hash_field(const std::vector<sai_thrift_attribute_t> & attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t fine_grained_hash_field_oid_out = SAI_NULL_OBJECT_ID;

    sai_hash_api_t *hash_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_HASH), (void **)&hash_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_fine_grained_hash_field_attributes(attr_list, sai_attr_list);

    if (hash_api->create_fine_grained_hash_field == (void *)0) {
        std::cerr << "NULL ptr: hash_api->create_fine_grained_hash_field" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = hash_api->create_fine_grained_hash_field(&fine_grained_hash_field_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);    return fine_grained_hash_field_oid_out;
  }

  void sai_thrift_remove_fine_grained_hash_field(const sai_thrift_object_id_t fine_grained_hash_field_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_hash_api_t *hash_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_HASH), (void **)&hash_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    if (hash_api->remove_fine_grained_hash_field == (void *)0) {
        std::cerr << "NULL ptr: hash_api->remove_fine_grained_hash_field" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = hash_api->remove_fine_grained_hash_field((sai_object_id_t)fine_grained_hash_field_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_fine_grained_hash_field_attribute(const sai_thrift_object_id_t fine_grained_hash_field_oid, const sai_thrift_attribute_t& attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t sai_attr;

    sai_hash_api_t *hash_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_HASH), (void **)&hash_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);

    sai_thrift_parse_fine_grained_hash_field_attributes(attr_vec, &sai_attr);

    if (hash_api->set_fine_grained_hash_field_attribute == (void *)0) {
        std::cerr << "NULL ptr: hash_api->set_fine_grained_hash_field_attribute" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = hash_api->set_fine_grained_hash_field_attribute((sai_object_id_t)fine_grained_hash_field_oid, &sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_get_fine_grained_hash_field_attribute(sai_thrift_attribute_list_t& attr_list_out, const sai_thrift_object_id_t fine_grained_hash_field_oid, const sai_thrift_attribute_list_t& attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_hash_api_t *hash_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_HASH), (void **)&hash_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    else {
      return;
    }


    const std::vector<sai_thrift_attribute_t> &attr_list_vec = attr_list.attr_list;

    sai_thrift_parse_fine_grained_hash_field_attributes(attr_list_vec, sai_attr_list);

    if (hash_api->get_fine_grained_hash_field_attribute == (void *)0) {
        std::cerr << "NULL ptr: hash_api->get_fine_grained_hash_field_attribute" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = hash_api->get_fine_grained_hash_field_attribute((sai_object_id_t)fine_grained_hash_field_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_fine_grained_hash_field_attributes(sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  sai_thrift_object_id_t sai_thrift_create_hash(const std::vector<sai_thrift_attribute_t> & attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t hash_oid_out = SAI_NULL_OBJECT_ID;

    sai_hash_api_t *hash_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_HASH), (void **)&hash_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_hash_attributes(attr_list, sai_attr_list);

    if (hash_api->create_hash == (void *)0) {
        std::cerr << "NULL ptr: hash_api->create_hash" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = hash_api->create_hash(&hash_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);    return hash_oid_out;
  }

  void sai_thrift_remove_hash(const sai_thrift_object_id_t hash_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_hash_api_t *hash_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_HASH), (void **)&hash_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    if (hash_api->remove_hash == (void *)0) {
        std::cerr << "NULL ptr: hash_api->remove_hash" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = hash_api->remove_hash((sai_object_id_t)hash_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_hash_attribute(const sai_thrift_object_id_t hash_oid, const sai_thrift_attribute_t& attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t sai_attr;

    sai_hash_api_t *hash_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_HASH), (void **)&hash_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);

    sai_thrift_parse_hash_attributes(attr_vec, &sai_attr);

    if (hash_api->set_hash_attribute == (void *)0) {
        std::cerr << "NULL ptr: hash_api->set_hash_attribute" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = hash_api->set_hash_attribute((sai_object_id_t)hash_oid, &sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_get_hash_attribute(sai_thrift_attribute_list_t& attr_list_out, const sai_thrift_object_id_t hash_oid, const sai_thrift_attribute_list_t& attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_hash_api_t *hash_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_HASH), (void **)&hash_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    else {
      return;
    }


    const std::vector<sai_thrift_attribute_t> &attr_list_vec = attr_list.attr_list;

    sai_thrift_parse_hash_attributes(attr_list_vec, sai_attr_list);

    if (hash_api->get_hash_attribute == (void *)0) {
        std::cerr << "NULL ptr: hash_api->get_hash_attribute" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = hash_api->get_hash_attribute((sai_object_id_t)hash_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_hash_attributes(sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  sai_thrift_object_id_t sai_thrift_create_hostif_trap_group(const std::vector<sai_thrift_attribute_t> & attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t hostif_trap_group_oid_out = SAI_NULL_OBJECT_ID;

    sai_hostif_api_t *hostif_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_HOSTIF), (void **)&hostif_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_hostif_trap_group_attributes(attr_list, sai_attr_list);

    if (hostif_api->create_hostif_trap_group == (void *)0) {
        std::cerr << "NULL ptr: hostif_api->create_hostif_trap_group" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = hostif_api->create_hostif_trap_group(&hostif_trap_group_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);    return hostif_trap_group_oid_out;
  }

  void sai_thrift_remove_hostif_trap_group(const sai_thrift_object_id_t hostif_trap_group_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_hostif_api_t *hostif_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_HOSTIF), (void **)&hostif_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    if (hostif_api->remove_hostif_trap_group == (void *)0) {
        std::cerr << "NULL ptr: hostif_api->remove_hostif_trap_group" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = hostif_api->remove_hostif_trap_group((sai_object_id_t)hostif_trap_group_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_hostif_trap_group_attribute(const sai_thrift_object_id_t hostif_trap_group_oid, const sai_thrift_attribute_t& attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t sai_attr;

    sai_hostif_api_t *hostif_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_HOSTIF), (void **)&hostif_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);

    sai_thrift_parse_hostif_trap_group_attributes(attr_vec, &sai_attr);

    if (hostif_api->set_hostif_trap_group_attribute == (void *)0) {
        std::cerr << "NULL ptr: hostif_api->set_hostif_trap_group_attribute" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = hostif_api->set_hostif_trap_group_attribute((sai_object_id_t)hostif_trap_group_oid, &sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_get_hostif_trap_group_attribute(sai_thrift_attribute_list_t& attr_list_out, const sai_thrift_object_id_t hostif_trap_group_oid, const sai_thrift_attribute_list_t& attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_hostif_api_t *hostif_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_HOSTIF), (void **)&hostif_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    else {
      return;
    }


    const std::vector<sai_thrift_attribute_t> &attr_list_vec = attr_list.attr_list;

    sai_thrift_parse_hostif_trap_group_attributes(attr_list_vec, sai_attr_list);

    if (hostif_api->get_hostif_trap_group_attribute == (void *)0) {
        std::cerr << "NULL ptr: hostif_api->get_hostif_trap_group_attribute" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = hostif_api->get_hostif_trap_group_attribute((sai_object_id_t)hostif_trap_group_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_hostif_trap_group_attributes(sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  sai_thrift_object_id_t sai_thrift_create_hostif_trap(const std::vector<sai_thrift_attribute_t> & attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t hostif_trap_oid_out = SAI_NULL_OBJECT_ID;

    sai_hostif_api_t *hostif_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_HOSTIF), (void **)&hostif_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_hostif_trap_attributes(attr_list, sai_attr_list);

    if (hostif_api->create_hostif_trap == (void *)0) {
        std::cerr << "NULL ptr: hostif_api->create_hostif_trap" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = hostif_api->create_hostif_trap(&hostif_trap_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);    return hostif_trap_oid_out;
  }

  void sai_thrift_remove_hostif_trap(const sai_thrift_object_id_t hostif_trap_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_hostif_api_t *hostif_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_HOSTIF), (void **)&hostif_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    if (hostif_api->remove_hostif_trap == (void *)0) {
        std::cerr << "NULL ptr: hostif_api->remove_hostif_trap" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = hostif_api->remove_hostif_trap((sai_object_id_t)hostif_trap_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_hostif_trap_attribute(const sai_thrift_object_id_t hostif_trap_oid, const sai_thrift_attribute_t& attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t sai_attr;

    sai_hostif_api_t *hostif_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_HOSTIF), (void **)&hostif_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);

    sai_thrift_parse_hostif_trap_attributes(attr_vec, &sai_attr);

    if (hostif_api->set_hostif_trap_attribute == (void *)0) {
        std::cerr << "NULL ptr: hostif_api->set_hostif_trap_attribute" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = hostif_api->set_hostif_trap_attribute((sai_object_id_t)hostif_trap_oid, &sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_get_hostif_trap_attribute(sai_thrift_attribute_list_t& attr_list_out, const sai_thrift_object_id_t hostif_trap_oid, const sai_thrift_attribute_list_t& attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_hostif_api_t *hostif_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_HOSTIF), (void **)&hostif_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    else {
      return;
    }


    const std::vector<sai_thrift_attribute_t> &attr_list_vec = attr_list.attr_list;

    sai_thrift_parse_hostif_trap_attributes(attr_list_vec, sai_attr_list);

    if (hostif_api->get_hostif_trap_attribute == (void *)0) {
        std::cerr << "NULL ptr: hostif_api->get_hostif_trap_attribute" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = hostif_api->get_hostif_trap_attribute((sai_object_id_t)hostif_trap_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_hostif_trap_attributes(sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  sai_thrift_object_id_t sai_thrift_create_hostif_user_defined_trap(const std::vector<sai_thrift_attribute_t> & attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t hostif_user_defined_trap_oid_out = SAI_NULL_OBJECT_ID;

    sai_hostif_api_t *hostif_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_HOSTIF), (void **)&hostif_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_hostif_user_defined_trap_attributes(attr_list, sai_attr_list);

    if (hostif_api->create_hostif_user_defined_trap == (void *)0) {
        std::cerr << "NULL ptr: hostif_api->create_hostif_user_defined_trap" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = hostif_api->create_hostif_user_defined_trap(&hostif_user_defined_trap_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);    return hostif_user_defined_trap_oid_out;
  }

  void sai_thrift_remove_hostif_user_defined_trap(const sai_thrift_object_id_t hostif_user_defined_trap_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_hostif_api_t *hostif_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_HOSTIF), (void **)&hostif_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    if (hostif_api->remove_hostif_user_defined_trap == (void *)0) {
        std::cerr << "NULL ptr: hostif_api->remove_hostif_user_defined_trap" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = hostif_api->remove_hostif_user_defined_trap((sai_object_id_t)hostif_user_defined_trap_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_hostif_user_defined_trap_attribute(const sai_thrift_object_id_t hostif_user_defined_trap_oid, const sai_thrift_attribute_t& attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t sai_attr;

    sai_hostif_api_t *hostif_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_HOSTIF), (void **)&hostif_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);

    sai_thrift_parse_hostif_user_defined_trap_attributes(attr_vec, &sai_attr);

    if (hostif_api->set_hostif_user_defined_trap_attribute == (void *)0) {
        std::cerr << "NULL ptr: hostif_api->set_hostif_user_defined_trap_attribute" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = hostif_api->set_hostif_user_defined_trap_attribute((sai_object_id_t)hostif_user_defined_trap_oid, &sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_get_hostif_user_defined_trap_attribute(sai_thrift_attribute_list_t& attr_list_out, const sai_thrift_object_id_t hostif_user_defined_trap_oid, const sai_thrift_attribute_list_t& attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_hostif_api_t *hostif_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_HOSTIF), (void **)&hostif_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    else {
      return;
    }


    const std::vector<sai_thrift_attribute_t> &attr_list_vec = attr_list.attr_list;

    sai_thrift_parse_hostif_user_defined_trap_attributes(attr_list_vec, sai_attr_list);

    if (hostif_api->get_hostif_user_defined_trap_attribute == (void *)0) {
        std::cerr << "NULL ptr: hostif_api->get_hostif_user_defined_trap_attribute" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = hostif_api->get_hostif_user_defined_trap_attribute((sai_object_id_t)hostif_user_defined_trap_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_hostif_user_defined_trap_attributes(sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  sai_thrift_object_id_t sai_thrift_create_hostif(const std::vector<sai_thrift_attribute_t> & attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t hostif_oid_out = SAI_NULL_OBJECT_ID;

    sai_hostif_api_t *hostif_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_HOSTIF), (void **)&hostif_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_hostif_attributes(attr_list, sai_attr_list);

    if (hostif_api->create_hostif == (void *)0) {
        std::cerr << "NULL ptr: hostif_api->create_hostif" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = hostif_api->create_hostif(&hostif_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);    return hostif_oid_out;
  }

  void sai_thrift_remove_hostif(const sai_thrift_object_id_t hostif_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_hostif_api_t *hostif_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_HOSTIF), (void **)&hostif_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    if (hostif_api->remove_hostif == (void *)0) {
        std::cerr << "NULL ptr: hostif_api->remove_hostif" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = hostif_api->remove_hostif((sai_object_id_t)hostif_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_hostif_attribute(const sai_thrift_object_id_t hostif_oid, const sai_thrift_attribute_t& attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t sai_attr;

    sai_hostif_api_t *hostif_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_HOSTIF), (void **)&hostif_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);

    sai_thrift_parse_hostif_attributes(attr_vec, &sai_attr);

    if (hostif_api->set_hostif_attribute == (void *)0) {
        std::cerr << "NULL ptr: hostif_api->set_hostif_attribute" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = hostif_api->set_hostif_attribute((sai_object_id_t)hostif_oid, &sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_get_hostif_attribute(sai_thrift_attribute_list_t& attr_list_out, const sai_thrift_object_id_t hostif_oid, const sai_thrift_attribute_list_t& attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_hostif_api_t *hostif_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_HOSTIF), (void **)&hostif_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    else {
      return;
    }


    const std::vector<sai_thrift_attribute_t> &attr_list_vec = attr_list.attr_list;

    sai_thrift_parse_hostif_attributes(attr_list_vec, sai_attr_list);

    if (hostif_api->get_hostif_attribute == (void *)0) {
        std::cerr << "NULL ptr: hostif_api->get_hostif_attribute" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = hostif_api->get_hostif_attribute((sai_object_id_t)hostif_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_hostif_attributes(sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  sai_thrift_object_id_t sai_thrift_create_hostif_table_entry(const std::vector<sai_thrift_attribute_t> & attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t hostif_table_entry_oid_out = SAI_NULL_OBJECT_ID;

    sai_hostif_api_t *hostif_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_HOSTIF), (void **)&hostif_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_hostif_table_entry_attributes(attr_list, sai_attr_list);

    if (hostif_api->create_hostif_table_entry == (void *)0) {
        std::cerr << "NULL ptr: hostif_api->create_hostif_table_entry" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = hostif_api->create_hostif_table_entry(&hostif_table_entry_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);    return hostif_table_entry_oid_out;
  }

  void sai_thrift_remove_hostif_table_entry(const sai_thrift_object_id_t hostif_table_entry_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_hostif_api_t *hostif_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_HOSTIF), (void **)&hostif_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    if (hostif_api->remove_hostif_table_entry == (void *)0) {
        std::cerr << "NULL ptr: hostif_api->remove_hostif_table_entry" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = hostif_api->remove_hostif_table_entry((sai_object_id_t)hostif_table_entry_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_hostif_table_entry_attribute(const sai_thrift_object_id_t hostif_table_entry_oid, const sai_thrift_attribute_t& attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t sai_attr;

    sai_hostif_api_t *hostif_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_HOSTIF), (void **)&hostif_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);

    sai_thrift_parse_hostif_table_entry_attributes(attr_vec, &sai_attr);

    if (hostif_api->set_hostif_table_entry_attribute == (void *)0) {
        std::cerr << "NULL ptr: hostif_api->set_hostif_table_entry_attribute" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = hostif_api->set_hostif_table_entry_attribute((sai_object_id_t)hostif_table_entry_oid, &sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_get_hostif_table_entry_attribute(sai_thrift_attribute_list_t& attr_list_out, const sai_thrift_object_id_t hostif_table_entry_oid, const sai_thrift_attribute_list_t& attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_hostif_api_t *hostif_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_HOSTIF), (void **)&hostif_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    else {
      return;
    }


    const std::vector<sai_thrift_attribute_t> &attr_list_vec = attr_list.attr_list;

    sai_thrift_parse_hostif_table_entry_attributes(attr_list_vec, sai_attr_list);

    if (hostif_api->get_hostif_table_entry_attribute == (void *)0) {
        std::cerr << "NULL ptr: hostif_api->get_hostif_table_entry_attribute" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = hostif_api->get_hostif_table_entry_attribute((sai_object_id_t)hostif_table_entry_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_hostif_table_entry_attributes(sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  sai_thrift_size_t sai_thrift_recv_hostif_packet(const sai_thrift_object_id_t hostif_oid, const sai_thrift_size_t buffer_size, const std::string& buffer, const std::vector<sai_thrift_attribute_t> & attr_list) {

    // This function is UNSUPPORTED
    return 0ULL;
  }

  void sai_thrift_send_hostif_packet(const sai_thrift_object_id_t hostif_oid, const sai_thrift_size_t buffer_size, const std::string& buffer, const std::vector<sai_thrift_attribute_t> & attr_list) {

    // This function is UNSUPPORTED
    return;
  }

  void sai_thrift_allocate_hostif_packet(std::string& buffer_out, const sai_thrift_object_id_t hostif_oid, const sai_thrift_size_t buffer_size, const std::vector<sai_thrift_attribute_t> & attr_list) {

    // This function is UNSUPPORTED
    return;
  }

  void sai_thrift_free_hostif_packet(std::string& buffer_out, const sai_thrift_object_id_t hostif_oid, const std::string& buffer) {

    // This function is UNSUPPORTED
    return;
  }

  void sai_thrift_create_ipmc_entry(const sai_thrift_ipmc_entry_t& ipmc_entry, const std::vector<sai_thrift_attribute_t> & attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_ipmc_entry_t sai_ipmc_entry;

    sai_ipmc_api_t *ipmc_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_IPMC), (void **)&ipmc_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_parse_ipmc_entry(ipmc_entry, &sai_ipmc_entry);

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_ipmc_entry_attributes(attr_list, sai_attr_list);

    if (ipmc_api->create_ipmc_entry == (void *)0) {
        std::cerr << "NULL ptr: ipmc_api->create_ipmc_entry" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = ipmc_api->create_ipmc_entry(&sai_ipmc_entry, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);
    return;
  }

  void sai_thrift_remove_ipmc_entry(const sai_thrift_ipmc_entry_t& ipmc_entry) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_ipmc_entry_t sai_ipmc_entry;

    sai_ipmc_api_t *ipmc_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_IPMC), (void **)&ipmc_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_parse_ipmc_entry(ipmc_entry, &sai_ipmc_entry);

    if (ipmc_api->remove_ipmc_entry == (void *)0) {
        std::cerr << "NULL ptr: ipmc_api->remove_ipmc_entry" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = ipmc_api->remove_ipmc_entry(&sai_ipmc_entry);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_ipmc_entry_attribute(const sai_thrift_ipmc_entry_t& ipmc_entry, const sai_thrift_attribute_t& attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_ipmc_entry_t sai_ipmc_entry;
    sai_attribute_t sai_attr;

    sai_ipmc_api_t *ipmc_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_IPMC), (void **)&ipmc_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_parse_ipmc_entry(ipmc_entry, &sai_ipmc_entry);

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);

    sai_thrift_parse_ipmc_entry_attributes(attr_vec, &sai_attr);

    if (ipmc_api->set_ipmc_entry_attribute == (void *)0) {
        std::cerr << "NULL ptr: ipmc_api->set_ipmc_entry_attribute" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = ipmc_api->set_ipmc_entry_attribute(&sai_ipmc_entry, &sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_get_ipmc_entry_attribute(sai_thrift_attribute_list_t& attr_list_out, const sai_thrift_ipmc_entry_t& ipmc_entry, const sai_thrift_attribute_list_t& attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_ipmc_entry_t sai_ipmc_entry;

    sai_ipmc_api_t *ipmc_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_IPMC), (void **)&ipmc_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_parse_ipmc_entry(ipmc_entry, &sai_ipmc_entry);

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    else {
      return;
    }


    const std::vector<sai_thrift_attribute_t> &attr_list_vec = attr_list.attr_list;

    sai_thrift_parse_ipmc_entry_attributes(attr_list_vec, sai_attr_list);

    if (ipmc_api->get_ipmc_entry_attribute == (void *)0) {
        std::cerr << "NULL ptr: ipmc_api->get_ipmc_entry_attribute" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = ipmc_api->get_ipmc_entry_attribute(&sai_ipmc_entry, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_ipmc_entry_attributes(sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  sai_thrift_object_id_t sai_thrift_create_ipmc_group(const std::vector<sai_thrift_attribute_t> & attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t ipmc_group_oid_out = SAI_NULL_OBJECT_ID;

    sai_ipmcgroup_api_t *ipmcgroup_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_IPMCGROUP), (void **)&ipmcgroup_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_ipmc_group_attributes(attr_list, sai_attr_list);

    if (ipmcgroup_api->create_ipmc_group == (void *)0) {
        std::cerr << "NULL ptr: ipmcgroup_api->create_ipmc_group" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = ipmcgroup_api->create_ipmc_group(&ipmc_group_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);    return ipmc_group_oid_out;
  }

  void sai_thrift_remove_ipmc_group(const sai_thrift_object_id_t ipmc_group_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_ipmcgroup_api_t *ipmcgroup_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_IPMCGROUP), (void **)&ipmcgroup_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    if (ipmcgroup_api->remove_ipmc_group == (void *)0) {
        std::cerr << "NULL ptr: ipmcgroup_api->remove_ipmc_group" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = ipmcgroup_api->remove_ipmc_group((sai_object_id_t)ipmc_group_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_ipmc_group_attribute(const sai_thrift_object_id_t ipmc_group_oid, const sai_thrift_attribute_t& attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t sai_attr;

    sai_ipmcgroup_api_t *ipmcgroup_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_IPMCGROUP), (void **)&ipmcgroup_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);

    sai_thrift_parse_ipmc_group_attributes(attr_vec, &sai_attr);

    if (ipmcgroup_api->set_ipmc_group_attribute == (void *)0) {
        std::cerr << "NULL ptr: ipmcgroup_api->set_ipmc_group_attribute" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = ipmcgroup_api->set_ipmc_group_attribute((sai_object_id_t)ipmc_group_oid, &sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_get_ipmc_group_attribute(sai_thrift_attribute_list_t& attr_list_out, const sai_thrift_object_id_t ipmc_group_oid, const sai_thrift_attribute_list_t& attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_ipmcgroup_api_t *ipmcgroup_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_IPMCGROUP), (void **)&ipmcgroup_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    else {
      return;
    }


    const std::vector<sai_thrift_attribute_t> &attr_list_vec = attr_list.attr_list;

    sai_thrift_parse_ipmc_group_attributes(attr_list_vec, sai_attr_list);

    if (ipmcgroup_api->get_ipmc_group_attribute == (void *)0) {
        std::cerr << "NULL ptr: ipmcgroup_api->get_ipmc_group_attribute" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = ipmcgroup_api->get_ipmc_group_attribute((sai_object_id_t)ipmc_group_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_ipmc_group_attributes(sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  sai_thrift_object_id_t sai_thrift_create_ipmc_group_member(const std::vector<sai_thrift_attribute_t> & attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t ipmc_group_member_oid_out = SAI_NULL_OBJECT_ID;

    sai_ipmcgroup_api_t *ipmcgroup_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_IPMCGROUP), (void **)&ipmcgroup_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_ipmc_group_member_attributes(attr_list, sai_attr_list);

    if (ipmcgroup_api->create_ipmc_group_member == (void *)0) {
        std::cerr << "NULL ptr: ipmcgroup_api->create_ipmc_group_member" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = ipmcgroup_api->create_ipmc_group_member(&ipmc_group_member_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);    return ipmc_group_member_oid_out;
  }

  void sai_thrift_remove_ipmc_group_member(const sai_thrift_object_id_t ipmc_group_member_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_ipmcgroup_api_t *ipmcgroup_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_IPMCGROUP), (void **)&ipmcgroup_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    if (ipmcgroup_api->remove_ipmc_group_member == (void *)0) {
        std::cerr << "NULL ptr: ipmcgroup_api->remove_ipmc_group_member" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = ipmcgroup_api->remove_ipmc_group_member((sai_object_id_t)ipmc_group_member_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_ipmc_group_member_attribute(const sai_thrift_object_id_t ipmc_group_member_oid, const sai_thrift_attribute_t& attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t sai_attr;

    sai_ipmcgroup_api_t *ipmcgroup_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_IPMCGROUP), (void **)&ipmcgroup_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);

    sai_thrift_parse_ipmc_group_member_attributes(attr_vec, &sai_attr);

    if (ipmcgroup_api->set_ipmc_group_member_attribute == (void *)0) {
        std::cerr << "NULL ptr: ipmcgroup_api->set_ipmc_group_member_attribute" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = ipmcgroup_api->set_ipmc_group_member_attribute((sai_object_id_t)ipmc_group_member_oid, &sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_get_ipmc_group_member_attribute(sai_thrift_attribute_list_t& attr_list_out, const sai_thrift_object_id_t ipmc_group_member_oid, const sai_thrift_attribute_list_t& attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_ipmcgroup_api_t *ipmcgroup_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_IPMCGROUP), (void **)&ipmcgroup_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    else {
      return;
    }


    const std::vector<sai_thrift_attribute_t> &attr_list_vec = attr_list.attr_list;

    sai_thrift_parse_ipmc_group_member_attributes(attr_list_vec, sai_attr_list);

    if (ipmcgroup_api->get_ipmc_group_member_attribute == (void *)0) {
        std::cerr << "NULL ptr: ipmcgroup_api->get_ipmc_group_member_attribute" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = ipmcgroup_api->get_ipmc_group_member_attribute((sai_object_id_t)ipmc_group_member_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_ipmc_group_member_attributes(sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  sai_thrift_object_id_t sai_thrift_create_ipsec(const std::vector<sai_thrift_attribute_t> & attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t ipsec_oid_out = SAI_NULL_OBJECT_ID;

    sai_ipsec_api_t *ipsec_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_IPSEC), (void **)&ipsec_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_ipsec_attributes(attr_list, sai_attr_list);

    if (ipsec_api->create_ipsec == (void *)0) {
        std::cerr << "NULL ptr: ipsec_api->create_ipsec" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = ipsec_api->create_ipsec(&ipsec_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);    return ipsec_oid_out;
  }

  void sai_thrift_remove_ipsec(const sai_thrift_object_id_t ipsec_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_ipsec_api_t *ipsec_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_IPSEC), (void **)&ipsec_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    if (ipsec_api->remove_ipsec == (void *)0) {
        std::cerr << "NULL ptr: ipsec_api->remove_ipsec" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = ipsec_api->remove_ipsec((sai_object_id_t)ipsec_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_ipsec_attribute(const sai_thrift_object_id_t ipsec_oid, const sai_thrift_attribute_t& attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t sai_attr;

    sai_ipsec_api_t *ipsec_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_IPSEC), (void **)&ipsec_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);

    sai_thrift_parse_ipsec_attributes(attr_vec, &sai_attr);

    if (ipsec_api->set_ipsec_attribute == (void *)0) {
        std::cerr << "NULL ptr: ipsec_api->set_ipsec_attribute" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = ipsec_api->set_ipsec_attribute((sai_object_id_t)ipsec_oid, &sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_get_ipsec_attribute(sai_thrift_attribute_list_t& attr_list_out, const sai_thrift_object_id_t ipsec_oid, const sai_thrift_attribute_list_t& attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_ipsec_api_t *ipsec_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_IPSEC), (void **)&ipsec_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    else {
      return;
    }


    const std::vector<sai_thrift_attribute_t> &attr_list_vec = attr_list.attr_list;

    sai_thrift_parse_ipsec_attributes(attr_list_vec, sai_attr_list);

    if (ipsec_api->get_ipsec_attribute == (void *)0) {
        std::cerr << "NULL ptr: ipsec_api->get_ipsec_attribute" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = ipsec_api->get_ipsec_attribute((sai_object_id_t)ipsec_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_ipsec_attributes(sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  sai_thrift_object_id_t sai_thrift_create_ipsec_port(const std::vector<sai_thrift_attribute_t> & attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t ipsec_port_oid_out = SAI_NULL_OBJECT_ID;

    sai_ipsec_api_t *ipsec_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_IPSEC), (void **)&ipsec_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_ipsec_port_attributes(attr_list, sai_attr_list);

    if (ipsec_api->create_ipsec_port == (void *)0) {
        std::cerr << "NULL ptr: ipsec_api->create_ipsec_port" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = ipsec_api->create_ipsec_port(&ipsec_port_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);    return ipsec_port_oid_out;
  }

  void sai_thrift_remove_ipsec_port(const sai_thrift_object_id_t ipsec_port_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_ipsec_api_t *ipsec_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_IPSEC), (void **)&ipsec_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    if (ipsec_api->remove_ipsec_port == (void *)0) {
        std::cerr << "NULL ptr: ipsec_api->remove_ipsec_port" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = ipsec_api->remove_ipsec_port((sai_object_id_t)ipsec_port_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_ipsec_port_attribute(const sai_thrift_object_id_t ipsec_port_oid, const sai_thrift_attribute_t& attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t sai_attr;

    sai_ipsec_api_t *ipsec_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_IPSEC), (void **)&ipsec_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);

    sai_thrift_parse_ipsec_port_attributes(attr_vec, &sai_attr);

    if (ipsec_api->set_ipsec_port_attribute == (void *)0) {
        std::cerr << "NULL ptr: ipsec_api->set_ipsec_port_attribute" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = ipsec_api->set_ipsec_port_attribute((sai_object_id_t)ipsec_port_oid, &sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_get_ipsec_port_attribute(sai_thrift_attribute_list_t& attr_list_out, const sai_thrift_object_id_t ipsec_port_oid, const sai_thrift_attribute_list_t& attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_ipsec_api_t *ipsec_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_IPSEC), (void **)&ipsec_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    else {
      return;
    }


    const std::vector<sai_thrift_attribute_t> &attr_list_vec = attr_list.attr_list;

    sai_thrift_parse_ipsec_port_attributes(attr_list_vec, sai_attr_list);

    if (ipsec_api->get_ipsec_port_attribute == (void *)0) {
        std::cerr << "NULL ptr: ipsec_api->get_ipsec_port_attribute" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = ipsec_api->get_ipsec_port_attribute((sai_object_id_t)ipsec_port_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_ipsec_port_attributes(sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  void sai_thrift_get_ipsec_port_stats(std::vector<sai_thrift_uint64_t> & counters_out, const sai_thrift_object_id_t ipsec_port_oid, const std::vector<sai_thrift_stat_id_t> & counter_ids) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_ipsec_api_t *ipsec_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_IPSEC), (void **)&ipsec_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_stat_id_t *sai_counter_ids = NULL;
    uint32_t number_of_counters = counter_ids.size();

    if (number_of_counters != 0) {
      sai_counter_ids = (sai_stat_id_t *)malloc(sizeof(sai_stat_id_t) * number_of_counters);
    }
    else {
      return;
    }


    std::vector<sai_thrift_stat_id_t>::const_iterator it = counter_ids.begin();
    for (uint32_t i = 0; i < counter_ids.size(); i++, it++) {
      sai_counter_ids[i] = (sai_stat_id_t)*it;
    }

    uint64_t *sai_counters = NULL;
    if (number_of_counters != 0) {
      sai_counters = (uint64_t *)malloc(sizeof(uint64_t) * number_of_counters);
    }

    if (ipsec_api->get_ipsec_port_stats == (void *)0) {
        std::cerr << "NULL ptr: ipsec_api->get_ipsec_port_stats" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = ipsec_api->get_ipsec_port_stats((sai_object_id_t)ipsec_port_oid, number_of_counters, sai_counter_ids, sai_counters);

    // sai_adapter always takes all ipsec stats. Since some of them may be
    // not supported, SAI_STATUS_INVALID_PARAMETER should not be raised.
    if (status != SAI_STATUS_SUCCESS && status != SAI_STATUS_INVALID_PARAMETER) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_counter_ids);
    for (uint32_t i = 0; i < (uint32_t)number_of_counters; i++) {
      counters_out.push_back((sai_thrift_uint64_t)sai_counters[i]);
    }
    free(sai_counters);
    return;
  }

  void sai_thrift_get_ipsec_port_stats_ext(std::vector<sai_thrift_uint64_t> & counters_out, const sai_thrift_object_id_t ipsec_port_oid, const std::vector<sai_thrift_stat_id_t> & counter_ids, const sai_thrift_stats_mode_t mode) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_ipsec_api_t *ipsec_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_IPSEC), (void **)&ipsec_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_stat_id_t *sai_counter_ids = NULL;
    uint32_t number_of_counters = counter_ids.size();

    if (number_of_counters != 0) {
      sai_counter_ids = (sai_stat_id_t *)malloc(sizeof(sai_stat_id_t) * number_of_counters);
    }
    else {
      return;
    }


    std::vector<sai_thrift_stat_id_t>::const_iterator it = counter_ids.begin();
    for (uint32_t i = 0; i < counter_ids.size(); i++, it++) {
      sai_counter_ids[i] = (sai_stat_id_t)*it;
    }

    uint64_t *sai_counters = NULL;
    if (number_of_counters != 0) {
      sai_counters = (uint64_t *)malloc(sizeof(uint64_t) * number_of_counters);
    }

    if (ipsec_api->get_ipsec_port_stats_ext == (void *)0) {
        std::cerr << "NULL ptr: ipsec_api->get_ipsec_port_stats_ext" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = ipsec_api->get_ipsec_port_stats_ext((sai_object_id_t)ipsec_port_oid, number_of_counters, sai_counter_ids, (sai_stats_mode_t)mode, sai_counters);

    // sai_adapter always takes all ipsec stats. Since some of them may be
    // not supported, SAI_STATUS_INVALID_PARAMETER should not be raised.
    if (status != SAI_STATUS_SUCCESS && status != SAI_STATUS_INVALID_PARAMETER) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_counter_ids);
    for (uint32_t i = 0; i < (uint32_t)number_of_counters; i++) {
      counters_out.push_back((sai_thrift_uint64_t)sai_counters[i]);
    }
    free(sai_counters);
    return;
  }

  void sai_thrift_clear_ipsec_port_stats(const sai_thrift_object_id_t ipsec_port_oid, const std::vector<sai_thrift_stat_id_t> & counter_ids) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_ipsec_api_t *ipsec_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_IPSEC), (void **)&ipsec_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_stat_id_t *sai_counter_ids = NULL;
    uint32_t number_of_counters = counter_ids.size();

    if (number_of_counters != 0) {
      sai_counter_ids = (sai_stat_id_t *)malloc(sizeof(sai_stat_id_t) * number_of_counters);
    }
    else {
      return;
    }


    std::vector<sai_thrift_stat_id_t>::const_iterator it = counter_ids.begin();
    for (uint32_t i = 0; i < counter_ids.size(); i++, it++) {
      sai_counter_ids[i] = (sai_stat_id_t)*it;
    }

    if (ipsec_api->clear_ipsec_port_stats == (void *)0) {
        std::cerr << "NULL ptr: ipsec_api->clear_ipsec_port_stats" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = ipsec_api->clear_ipsec_port_stats((sai_object_id_t)ipsec_port_oid, number_of_counters, sai_counter_ids);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_counter_ids);
    return;
  }

  sai_thrift_object_id_t sai_thrift_create_ipsec_sa(const std::vector<sai_thrift_attribute_t> & attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t ipsec_sa_oid_out = SAI_NULL_OBJECT_ID;

    sai_ipsec_api_t *ipsec_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_IPSEC), (void **)&ipsec_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_ipsec_sa_attributes(attr_list, sai_attr_list);

    if (ipsec_api->create_ipsec_sa == (void *)0) {
        std::cerr << "NULL ptr: ipsec_api->create_ipsec_sa" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = ipsec_api->create_ipsec_sa(&ipsec_sa_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);    return ipsec_sa_oid_out;
  }

  void sai_thrift_remove_ipsec_sa(const sai_thrift_object_id_t ipsec_sa_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_ipsec_api_t *ipsec_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_IPSEC), (void **)&ipsec_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    if (ipsec_api->remove_ipsec_sa == (void *)0) {
        std::cerr << "NULL ptr: ipsec_api->remove_ipsec_sa" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = ipsec_api->remove_ipsec_sa((sai_object_id_t)ipsec_sa_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_ipsec_sa_attribute(const sai_thrift_object_id_t ipsec_sa_oid, const sai_thrift_attribute_t& attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t sai_attr;

    sai_ipsec_api_t *ipsec_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_IPSEC), (void **)&ipsec_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);

    sai_thrift_parse_ipsec_sa_attributes(attr_vec, &sai_attr);

    if (ipsec_api->set_ipsec_sa_attribute == (void *)0) {
        std::cerr << "NULL ptr: ipsec_api->set_ipsec_sa_attribute" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = ipsec_api->set_ipsec_sa_attribute((sai_object_id_t)ipsec_sa_oid, &sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_get_ipsec_sa_attribute(sai_thrift_attribute_list_t& attr_list_out, const sai_thrift_object_id_t ipsec_sa_oid, const sai_thrift_attribute_list_t& attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_ipsec_api_t *ipsec_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_IPSEC), (void **)&ipsec_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    else {
      return;
    }


    const std::vector<sai_thrift_attribute_t> &attr_list_vec = attr_list.attr_list;

    sai_thrift_parse_ipsec_sa_attributes(attr_list_vec, sai_attr_list);

    if (ipsec_api->get_ipsec_sa_attribute == (void *)0) {
        std::cerr << "NULL ptr: ipsec_api->get_ipsec_sa_attribute" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = ipsec_api->get_ipsec_sa_attribute((sai_object_id_t)ipsec_sa_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_ipsec_sa_attributes(sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  void sai_thrift_get_ipsec_sa_stats(std::vector<sai_thrift_uint64_t> & counters_out, const sai_thrift_object_id_t ipsec_sa_oid, const std::vector<sai_thrift_stat_id_t> & counter_ids) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_ipsec_api_t *ipsec_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_IPSEC), (void **)&ipsec_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_stat_id_t *sai_counter_ids = NULL;
    uint32_t number_of_counters = counter_ids.size();

    if (number_of_counters != 0) {
      sai_counter_ids = (sai_stat_id_t *)malloc(sizeof(sai_stat_id_t) * number_of_counters);
    }
    else {
      return;
    }


    std::vector<sai_thrift_stat_id_t>::const_iterator it = counter_ids.begin();
    for (uint32_t i = 0; i < counter_ids.size(); i++, it++) {
      sai_counter_ids[i] = (sai_stat_id_t)*it;
    }

    uint64_t *sai_counters = NULL;
    if (number_of_counters != 0) {
      sai_counters = (uint64_t *)malloc(sizeof(uint64_t) * number_of_counters);
    }

    if (ipsec_api->get_ipsec_sa_stats == (void *)0) {
        std::cerr << "NULL ptr: ipsec_api->get_ipsec_sa_stats" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = ipsec_api->get_ipsec_sa_stats((sai_object_id_t)ipsec_sa_oid, number_of_counters, sai_counter_ids, sai_counters);

    // sai_adapter always takes all ipsec stats. Since some of them may be
    // not supported, SAI_STATUS_INVALID_PARAMETER should not be raised.
    if (status != SAI_STATUS_SUCCESS && status != SAI_STATUS_INVALID_PARAMETER) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_counter_ids);
    for (uint32_t i = 0; i < (uint32_t)number_of_counters; i++) {
      counters_out.push_back((sai_thrift_uint64_t)sai_counters[i]);
    }
    free(sai_counters);
    return;
  }

  void sai_thrift_get_ipsec_sa_stats_ext(std::vector<sai_thrift_uint64_t> & counters_out, const sai_thrift_object_id_t ipsec_sa_oid, const std::vector<sai_thrift_stat_id_t> & counter_ids, const sai_thrift_stats_mode_t mode) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_ipsec_api_t *ipsec_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_IPSEC), (void **)&ipsec_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_stat_id_t *sai_counter_ids = NULL;
    uint32_t number_of_counters = counter_ids.size();

    if (number_of_counters != 0) {
      sai_counter_ids = (sai_stat_id_t *)malloc(sizeof(sai_stat_id_t) * number_of_counters);
    }
    else {
      return;
    }


    std::vector<sai_thrift_stat_id_t>::const_iterator it = counter_ids.begin();
    for (uint32_t i = 0; i < counter_ids.size(); i++, it++) {
      sai_counter_ids[i] = (sai_stat_id_t)*it;
    }

    uint64_t *sai_counters = NULL;
    if (number_of_counters != 0) {
      sai_counters = (uint64_t *)malloc(sizeof(uint64_t) * number_of_counters);
    }

    if (ipsec_api->get_ipsec_sa_stats_ext == (void *)0) {
        std::cerr << "NULL ptr: ipsec_api->get_ipsec_sa_stats_ext" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = ipsec_api->get_ipsec_sa_stats_ext((sai_object_id_t)ipsec_sa_oid, number_of_counters, sai_counter_ids, (sai_stats_mode_t)mode, sai_counters);

    // sai_adapter always takes all ipsec stats. Since some of them may be
    // not supported, SAI_STATUS_INVALID_PARAMETER should not be raised.
    if (status != SAI_STATUS_SUCCESS && status != SAI_STATUS_INVALID_PARAMETER) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_counter_ids);
    for (uint32_t i = 0; i < (uint32_t)number_of_counters; i++) {
      counters_out.push_back((sai_thrift_uint64_t)sai_counters[i]);
    }
    free(sai_counters);
    return;
  }

  void sai_thrift_clear_ipsec_sa_stats(const sai_thrift_object_id_t ipsec_sa_oid, const std::vector<sai_thrift_stat_id_t> & counter_ids) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_ipsec_api_t *ipsec_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_IPSEC), (void **)&ipsec_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_stat_id_t *sai_counter_ids = NULL;
    uint32_t number_of_counters = counter_ids.size();

    if (number_of_counters != 0) {
      sai_counter_ids = (sai_stat_id_t *)malloc(sizeof(sai_stat_id_t) * number_of_counters);
    }
    else {
      return;
    }


    std::vector<sai_thrift_stat_id_t>::const_iterator it = counter_ids.begin();
    for (uint32_t i = 0; i < counter_ids.size(); i++, it++) {
      sai_counter_ids[i] = (sai_stat_id_t)*it;
    }

    if (ipsec_api->clear_ipsec_sa_stats == (void *)0) {
        std::cerr << "NULL ptr: ipsec_api->clear_ipsec_sa_stats" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = ipsec_api->clear_ipsec_sa_stats((sai_object_id_t)ipsec_sa_oid, number_of_counters, sai_counter_ids);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_counter_ids);
    return;
  }

  sai_thrift_object_id_t sai_thrift_create_isolation_group(const std::vector<sai_thrift_attribute_t> & attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t isolation_group_oid_out = SAI_NULL_OBJECT_ID;

    sai_isolationgroup_api_t *isolationgroup_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_ISOLATIONGROUP), (void **)&isolationgroup_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_isolation_group_attributes(attr_list, sai_attr_list);

    if (isolationgroup_api->create_isolation_group == (void *)0) {
        std::cerr << "NULL ptr: isolationgroup_api->create_isolation_group" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = isolationgroup_api->create_isolation_group(&isolation_group_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);    return isolation_group_oid_out;
  }

  void sai_thrift_remove_isolation_group(const sai_thrift_object_id_t isolation_group_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_isolationgroup_api_t *isolationgroup_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_ISOLATIONGROUP), (void **)&isolationgroup_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    if (isolationgroup_api->remove_isolation_group == (void *)0) {
        std::cerr << "NULL ptr: isolationgroup_api->remove_isolation_group" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = isolationgroup_api->remove_isolation_group((sai_object_id_t)isolation_group_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_isolation_group_attribute(const sai_thrift_object_id_t isolation_group_oid, const sai_thrift_attribute_t& attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t sai_attr;

    sai_isolationgroup_api_t *isolationgroup_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_ISOLATIONGROUP), (void **)&isolationgroup_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);

    sai_thrift_parse_isolation_group_attributes(attr_vec, &sai_attr);

    if (isolationgroup_api->set_isolation_group_attribute == (void *)0) {
        std::cerr << "NULL ptr: isolationgroup_api->set_isolation_group_attribute" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = isolationgroup_api->set_isolation_group_attribute((sai_object_id_t)isolation_group_oid, &sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_get_isolation_group_attribute(sai_thrift_attribute_list_t& attr_list_out, const sai_thrift_object_id_t isolation_group_oid, const sai_thrift_attribute_list_t& attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_isolationgroup_api_t *isolationgroup_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_ISOLATIONGROUP), (void **)&isolationgroup_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    else {
      return;
    }


    const std::vector<sai_thrift_attribute_t> &attr_list_vec = attr_list.attr_list;

    sai_thrift_parse_isolation_group_attributes(attr_list_vec, sai_attr_list);

    if (isolationgroup_api->get_isolation_group_attribute == (void *)0) {
        std::cerr << "NULL ptr: isolationgroup_api->get_isolation_group_attribute" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = isolationgroup_api->get_isolation_group_attribute((sai_object_id_t)isolation_group_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_isolation_group_attributes(sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  sai_thrift_object_id_t sai_thrift_create_isolation_group_member(const std::vector<sai_thrift_attribute_t> & attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t isolation_group_member_oid_out = SAI_NULL_OBJECT_ID;

    sai_isolationgroup_api_t *isolationgroup_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_ISOLATIONGROUP), (void **)&isolationgroup_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_isolation_group_member_attributes(attr_list, sai_attr_list);

    if (isolationgroup_api->create_isolation_group_member == (void *)0) {
        std::cerr << "NULL ptr: isolationgroup_api->create_isolation_group_member" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = isolationgroup_api->create_isolation_group_member(&isolation_group_member_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);    return isolation_group_member_oid_out;
  }

  void sai_thrift_remove_isolation_group_member(const sai_thrift_object_id_t isolation_group_member_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_isolationgroup_api_t *isolationgroup_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_ISOLATIONGROUP), (void **)&isolationgroup_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    if (isolationgroup_api->remove_isolation_group_member == (void *)0) {
        std::cerr << "NULL ptr: isolationgroup_api->remove_isolation_group_member" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = isolationgroup_api->remove_isolation_group_member((sai_object_id_t)isolation_group_member_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_isolation_group_member_attribute(const sai_thrift_object_id_t isolation_group_member_oid, const sai_thrift_attribute_t& attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t sai_attr;

    sai_isolationgroup_api_t *isolationgroup_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_ISOLATIONGROUP), (void **)&isolationgroup_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);

    sai_thrift_parse_isolation_group_member_attributes(attr_vec, &sai_attr);

    if (isolationgroup_api->set_isolation_group_member_attribute == (void *)0) {
        std::cerr << "NULL ptr: isolationgroup_api->set_isolation_group_member_attribute" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = isolationgroup_api->set_isolation_group_member_attribute((sai_object_id_t)isolation_group_member_oid, &sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_get_isolation_group_member_attribute(sai_thrift_attribute_list_t& attr_list_out, const sai_thrift_object_id_t isolation_group_member_oid, const sai_thrift_attribute_list_t& attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_isolationgroup_api_t *isolationgroup_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_ISOLATIONGROUP), (void **)&isolationgroup_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    else {
      return;
    }


    const std::vector<sai_thrift_attribute_t> &attr_list_vec = attr_list.attr_list;

    sai_thrift_parse_isolation_group_member_attributes(attr_list_vec, sai_attr_list);

    if (isolationgroup_api->get_isolation_group_member_attribute == (void *)0) {
        std::cerr << "NULL ptr: isolationgroup_api->get_isolation_group_member_attribute" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = isolationgroup_api->get_isolation_group_member_attribute((sai_object_id_t)isolation_group_member_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_isolation_group_member_attributes(sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  void sai_thrift_create_l2mc_entry(const sai_thrift_l2mc_entry_t& l2mc_entry, const std::vector<sai_thrift_attribute_t> & attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_l2mc_entry_t sai_l2mc_entry;

    sai_l2mc_api_t *l2mc_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_L2MC), (void **)&l2mc_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_parse_l2mc_entry(l2mc_entry, &sai_l2mc_entry);

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_l2mc_entry_attributes(attr_list, sai_attr_list);

    if (l2mc_api->create_l2mc_entry == (void *)0) {
        std::cerr << "NULL ptr: l2mc_api->create_l2mc_entry" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = l2mc_api->create_l2mc_entry(&sai_l2mc_entry, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);
    return;
  }

  void sai_thrift_remove_l2mc_entry(const sai_thrift_l2mc_entry_t& l2mc_entry) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_l2mc_entry_t sai_l2mc_entry;

    sai_l2mc_api_t *l2mc_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_L2MC), (void **)&l2mc_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_parse_l2mc_entry(l2mc_entry, &sai_l2mc_entry);

    if (l2mc_api->remove_l2mc_entry == (void *)0) {
        std::cerr << "NULL ptr: l2mc_api->remove_l2mc_entry" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = l2mc_api->remove_l2mc_entry(&sai_l2mc_entry);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_l2mc_entry_attribute(const sai_thrift_l2mc_entry_t& l2mc_entry, const sai_thrift_attribute_t& attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_l2mc_entry_t sai_l2mc_entry;
    sai_attribute_t sai_attr;

    sai_l2mc_api_t *l2mc_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_L2MC), (void **)&l2mc_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_parse_l2mc_entry(l2mc_entry, &sai_l2mc_entry);

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);

    sai_thrift_parse_l2mc_entry_attributes(attr_vec, &sai_attr);

    if (l2mc_api->set_l2mc_entry_attribute == (void *)0) {
        std::cerr << "NULL ptr: l2mc_api->set_l2mc_entry_attribute" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = l2mc_api->set_l2mc_entry_attribute(&sai_l2mc_entry, &sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_get_l2mc_entry_attribute(sai_thrift_attribute_list_t& attr_list_out, const sai_thrift_l2mc_entry_t& l2mc_entry, const sai_thrift_attribute_list_t& attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_l2mc_entry_t sai_l2mc_entry;

    sai_l2mc_api_t *l2mc_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_L2MC), (void **)&l2mc_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_parse_l2mc_entry(l2mc_entry, &sai_l2mc_entry);

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    else {
      return;
    }


    const std::vector<sai_thrift_attribute_t> &attr_list_vec = attr_list.attr_list;

    sai_thrift_parse_l2mc_entry_attributes(attr_list_vec, sai_attr_list);

    if (l2mc_api->get_l2mc_entry_attribute == (void *)0) {
        std::cerr << "NULL ptr: l2mc_api->get_l2mc_entry_attribute" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = l2mc_api->get_l2mc_entry_attribute(&sai_l2mc_entry, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_l2mc_entry_attributes(sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  sai_thrift_object_id_t sai_thrift_create_l2mc_group(const std::vector<sai_thrift_attribute_t> & attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t l2mc_group_oid_out = SAI_NULL_OBJECT_ID;

    sai_l2mcgroup_api_t *l2mcgroup_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_L2MCGROUP), (void **)&l2mcgroup_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_l2mc_group_attributes(attr_list, sai_attr_list);

    if (l2mcgroup_api->create_l2mc_group == (void *)0) {
        std::cerr << "NULL ptr: l2mcgroup_api->create_l2mc_group" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = l2mcgroup_api->create_l2mc_group(&l2mc_group_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);    return l2mc_group_oid_out;
  }

  void sai_thrift_remove_l2mc_group(const sai_thrift_object_id_t l2mc_group_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_l2mcgroup_api_t *l2mcgroup_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_L2MCGROUP), (void **)&l2mcgroup_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    if (l2mcgroup_api->remove_l2mc_group == (void *)0) {
        std::cerr << "NULL ptr: l2mcgroup_api->remove_l2mc_group" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = l2mcgroup_api->remove_l2mc_group((sai_object_id_t)l2mc_group_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_l2mc_group_attribute(const sai_thrift_object_id_t l2mc_group_oid, const sai_thrift_attribute_t& attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t sai_attr;

    sai_l2mcgroup_api_t *l2mcgroup_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_L2MCGROUP), (void **)&l2mcgroup_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);

    sai_thrift_parse_l2mc_group_attributes(attr_vec, &sai_attr);

    if (l2mcgroup_api->set_l2mc_group_attribute == (void *)0) {
        std::cerr << "NULL ptr: l2mcgroup_api->set_l2mc_group_attribute" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = l2mcgroup_api->set_l2mc_group_attribute((sai_object_id_t)l2mc_group_oid, &sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_get_l2mc_group_attribute(sai_thrift_attribute_list_t& attr_list_out, const sai_thrift_object_id_t l2mc_group_oid, const sai_thrift_attribute_list_t& attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_l2mcgroup_api_t *l2mcgroup_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_L2MCGROUP), (void **)&l2mcgroup_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    else {
      return;
    }


    const std::vector<sai_thrift_attribute_t> &attr_list_vec = attr_list.attr_list;

    sai_thrift_parse_l2mc_group_attributes(attr_list_vec, sai_attr_list);

    if (l2mcgroup_api->get_l2mc_group_attribute == (void *)0) {
        std::cerr << "NULL ptr: l2mcgroup_api->get_l2mc_group_attribute" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = l2mcgroup_api->get_l2mc_group_attribute((sai_object_id_t)l2mc_group_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_l2mc_group_attributes(sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  sai_thrift_object_id_t sai_thrift_create_l2mc_group_member(const std::vector<sai_thrift_attribute_t> & attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t l2mc_group_member_oid_out = SAI_NULL_OBJECT_ID;

    sai_l2mcgroup_api_t *l2mcgroup_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_L2MCGROUP), (void **)&l2mcgroup_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_l2mc_group_member_attributes(attr_list, sai_attr_list);

    if (l2mcgroup_api->create_l2mc_group_member == (void *)0) {
        std::cerr << "NULL ptr: l2mcgroup_api->create_l2mc_group_member" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = l2mcgroup_api->create_l2mc_group_member(&l2mc_group_member_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);    return l2mc_group_member_oid_out;
  }

  void sai_thrift_remove_l2mc_group_member(const sai_thrift_object_id_t l2mc_group_member_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_l2mcgroup_api_t *l2mcgroup_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_L2MCGROUP), (void **)&l2mcgroup_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    if (l2mcgroup_api->remove_l2mc_group_member == (void *)0) {
        std::cerr << "NULL ptr: l2mcgroup_api->remove_l2mc_group_member" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = l2mcgroup_api->remove_l2mc_group_member((sai_object_id_t)l2mc_group_member_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_l2mc_group_member_attribute(const sai_thrift_object_id_t l2mc_group_member_oid, const sai_thrift_attribute_t& attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t sai_attr;

    sai_l2mcgroup_api_t *l2mcgroup_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_L2MCGROUP), (void **)&l2mcgroup_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);

    sai_thrift_parse_l2mc_group_member_attributes(attr_vec, &sai_attr);

    if (l2mcgroup_api->set_l2mc_group_member_attribute == (void *)0) {
        std::cerr << "NULL ptr: l2mcgroup_api->set_l2mc_group_member_attribute" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = l2mcgroup_api->set_l2mc_group_member_attribute((sai_object_id_t)l2mc_group_member_oid, &sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_get_l2mc_group_member_attribute(sai_thrift_attribute_list_t& attr_list_out, const sai_thrift_object_id_t l2mc_group_member_oid, const sai_thrift_attribute_list_t& attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_l2mcgroup_api_t *l2mcgroup_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_L2MCGROUP), (void **)&l2mcgroup_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    else {
      return;
    }


    const std::vector<sai_thrift_attribute_t> &attr_list_vec = attr_list.attr_list;

    sai_thrift_parse_l2mc_group_member_attributes(attr_list_vec, sai_attr_list);

    if (l2mcgroup_api->get_l2mc_group_member_attribute == (void *)0) {
        std::cerr << "NULL ptr: l2mcgroup_api->get_l2mc_group_member_attribute" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = l2mcgroup_api->get_l2mc_group_member_attribute((sai_object_id_t)l2mc_group_member_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_l2mc_group_member_attributes(sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  sai_thrift_object_id_t sai_thrift_create_lag(const std::vector<sai_thrift_attribute_t> & attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t lag_oid_out = SAI_NULL_OBJECT_ID;

    sai_lag_api_t *lag_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_LAG), (void **)&lag_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_lag_attributes(attr_list, sai_attr_list);

    if (lag_api->create_lag == (void *)0) {
        std::cerr << "NULL ptr: lag_api->create_lag" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = lag_api->create_lag(&lag_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);    return lag_oid_out;
  }

  void sai_thrift_remove_lag(const sai_thrift_object_id_t lag_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_lag_api_t *lag_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_LAG), (void **)&lag_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    if (lag_api->remove_lag == (void *)0) {
        std::cerr << "NULL ptr: lag_api->remove_lag" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = lag_api->remove_lag((sai_object_id_t)lag_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_lag_attribute(const sai_thrift_object_id_t lag_oid, const sai_thrift_attribute_t& attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t sai_attr;

    sai_lag_api_t *lag_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_LAG), (void **)&lag_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);

    sai_thrift_parse_lag_attributes(attr_vec, &sai_attr);

    if (lag_api->set_lag_attribute == (void *)0) {
        std::cerr << "NULL ptr: lag_api->set_lag_attribute" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = lag_api->set_lag_attribute((sai_object_id_t)lag_oid, &sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_get_lag_attribute(sai_thrift_attribute_list_t& attr_list_out, const sai_thrift_object_id_t lag_oid, const sai_thrift_attribute_list_t& attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_lag_api_t *lag_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_LAG), (void **)&lag_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    else {
      return;
    }


    const std::vector<sai_thrift_attribute_t> &attr_list_vec = attr_list.attr_list;

    sai_thrift_parse_lag_attributes(attr_list_vec, sai_attr_list);

    if (lag_api->get_lag_attribute == (void *)0) {
        std::cerr << "NULL ptr: lag_api->get_lag_attribute" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = lag_api->get_lag_attribute((sai_object_id_t)lag_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_lag_attributes(sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  sai_thrift_object_id_t sai_thrift_create_lag_member(const std::vector<sai_thrift_attribute_t> & attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t lag_member_oid_out = SAI_NULL_OBJECT_ID;

    sai_lag_api_t *lag_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_LAG), (void **)&lag_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_lag_member_attributes(attr_list, sai_attr_list);

    if (lag_api->create_lag_member == (void *)0) {
        std::cerr << "NULL ptr: lag_api->create_lag_member" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = lag_api->create_lag_member(&lag_member_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);    return lag_member_oid_out;
  }

  void sai_thrift_remove_lag_member(const sai_thrift_object_id_t lag_member_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_lag_api_t *lag_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_LAG), (void **)&lag_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    if (lag_api->remove_lag_member == (void *)0) {
        std::cerr << "NULL ptr: lag_api->remove_lag_member" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = lag_api->remove_lag_member((sai_object_id_t)lag_member_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_lag_member_attribute(const sai_thrift_object_id_t lag_member_oid, const sai_thrift_attribute_t& attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t sai_attr;

    sai_lag_api_t *lag_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_LAG), (void **)&lag_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);

    sai_thrift_parse_lag_member_attributes(attr_vec, &sai_attr);

    if (lag_api->set_lag_member_attribute == (void *)0) {
        std::cerr << "NULL ptr: lag_api->set_lag_member_attribute" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = lag_api->set_lag_member_attribute((sai_object_id_t)lag_member_oid, &sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_get_lag_member_attribute(sai_thrift_attribute_list_t& attr_list_out, const sai_thrift_object_id_t lag_member_oid, const sai_thrift_attribute_list_t& attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_lag_api_t *lag_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_LAG), (void **)&lag_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    else {
      return;
    }


    const std::vector<sai_thrift_attribute_t> &attr_list_vec = attr_list.attr_list;

    sai_thrift_parse_lag_member_attributes(attr_list_vec, sai_attr_list);

    if (lag_api->get_lag_member_attribute == (void *)0) {
        std::cerr << "NULL ptr: lag_api->get_lag_member_attribute" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = lag_api->get_lag_member_attribute((sai_object_id_t)lag_member_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_lag_member_attributes(sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  sai_thrift_object_id_t sai_thrift_create_macsec(const std::vector<sai_thrift_attribute_t> & attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t macsec_oid_out = SAI_NULL_OBJECT_ID;

    sai_macsec_api_t *macsec_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_MACSEC), (void **)&macsec_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_macsec_attributes(attr_list, sai_attr_list);

    if (macsec_api->create_macsec == (void *)0) {
        std::cerr << "NULL ptr: macsec_api->create_macsec" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = macsec_api->create_macsec(&macsec_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);    return macsec_oid_out;
  }

  void sai_thrift_remove_macsec(const sai_thrift_object_id_t macsec_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_macsec_api_t *macsec_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_MACSEC), (void **)&macsec_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    if (macsec_api->remove_macsec == (void *)0) {
        std::cerr << "NULL ptr: macsec_api->remove_macsec" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = macsec_api->remove_macsec((sai_object_id_t)macsec_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_macsec_attribute(const sai_thrift_object_id_t macsec_oid, const sai_thrift_attribute_t& attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t sai_attr;

    sai_macsec_api_t *macsec_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_MACSEC), (void **)&macsec_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);

    sai_thrift_parse_macsec_attributes(attr_vec, &sai_attr);

    if (macsec_api->set_macsec_attribute == (void *)0) {
        std::cerr << "NULL ptr: macsec_api->set_macsec_attribute" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = macsec_api->set_macsec_attribute((sai_object_id_t)macsec_oid, &sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_get_macsec_attribute(sai_thrift_attribute_list_t& attr_list_out, const sai_thrift_object_id_t macsec_oid, const sai_thrift_attribute_list_t& attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_macsec_api_t *macsec_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_MACSEC), (void **)&macsec_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    else {
      return;
    }


    const std::vector<sai_thrift_attribute_t> &attr_list_vec = attr_list.attr_list;

    sai_thrift_parse_macsec_attributes(attr_list_vec, sai_attr_list);

    if (macsec_api->get_macsec_attribute == (void *)0) {
        std::cerr << "NULL ptr: macsec_api->get_macsec_attribute" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = macsec_api->get_macsec_attribute((sai_object_id_t)macsec_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_macsec_attributes(sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  sai_thrift_object_id_t sai_thrift_create_macsec_port(const std::vector<sai_thrift_attribute_t> & attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t macsec_port_oid_out = SAI_NULL_OBJECT_ID;

    sai_macsec_api_t *macsec_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_MACSEC), (void **)&macsec_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_macsec_port_attributes(attr_list, sai_attr_list);

    if (macsec_api->create_macsec_port == (void *)0) {
        std::cerr << "NULL ptr: macsec_api->create_macsec_port" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = macsec_api->create_macsec_port(&macsec_port_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);    return macsec_port_oid_out;
  }

  void sai_thrift_remove_macsec_port(const sai_thrift_object_id_t macsec_port_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_macsec_api_t *macsec_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_MACSEC), (void **)&macsec_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    if (macsec_api->remove_macsec_port == (void *)0) {
        std::cerr << "NULL ptr: macsec_api->remove_macsec_port" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = macsec_api->remove_macsec_port((sai_object_id_t)macsec_port_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_macsec_port_attribute(const sai_thrift_object_id_t macsec_port_oid, const sai_thrift_attribute_t& attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t sai_attr;

    sai_macsec_api_t *macsec_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_MACSEC), (void **)&macsec_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);

    sai_thrift_parse_macsec_port_attributes(attr_vec, &sai_attr);

    if (macsec_api->set_macsec_port_attribute == (void *)0) {
        std::cerr << "NULL ptr: macsec_api->set_macsec_port_attribute" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = macsec_api->set_macsec_port_attribute((sai_object_id_t)macsec_port_oid, &sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_get_macsec_port_attribute(sai_thrift_attribute_list_t& attr_list_out, const sai_thrift_object_id_t macsec_port_oid, const sai_thrift_attribute_list_t& attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_macsec_api_t *macsec_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_MACSEC), (void **)&macsec_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    else {
      return;
    }


    const std::vector<sai_thrift_attribute_t> &attr_list_vec = attr_list.attr_list;

    sai_thrift_parse_macsec_port_attributes(attr_list_vec, sai_attr_list);

    if (macsec_api->get_macsec_port_attribute == (void *)0) {
        std::cerr << "NULL ptr: macsec_api->get_macsec_port_attribute" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = macsec_api->get_macsec_port_attribute((sai_object_id_t)macsec_port_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_macsec_port_attributes(sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  void sai_thrift_get_macsec_port_stats(std::vector<sai_thrift_uint64_t> & counters_out, const sai_thrift_object_id_t macsec_port_oid, const std::vector<sai_thrift_stat_id_t> & counter_ids) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_macsec_api_t *macsec_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_MACSEC), (void **)&macsec_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_stat_id_t *sai_counter_ids = NULL;
    uint32_t number_of_counters = counter_ids.size();

    if (number_of_counters != 0) {
      sai_counter_ids = (sai_stat_id_t *)malloc(sizeof(sai_stat_id_t) * number_of_counters);
    }
    else {
      return;
    }


    std::vector<sai_thrift_stat_id_t>::const_iterator it = counter_ids.begin();
    for (uint32_t i = 0; i < counter_ids.size(); i++, it++) {
      sai_counter_ids[i] = (sai_stat_id_t)*it;
    }

    uint64_t *sai_counters = NULL;
    if (number_of_counters != 0) {
      sai_counters = (uint64_t *)malloc(sizeof(uint64_t) * number_of_counters);
    }

    if (macsec_api->get_macsec_port_stats == (void *)0) {
        std::cerr << "NULL ptr: macsec_api->get_macsec_port_stats" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = macsec_api->get_macsec_port_stats((sai_object_id_t)macsec_port_oid, number_of_counters, sai_counter_ids, sai_counters);

    // sai_adapter always takes all macsec stats. Since some of them may be
    // not supported, SAI_STATUS_INVALID_PARAMETER should not be raised.
    if (status != SAI_STATUS_SUCCESS && status != SAI_STATUS_INVALID_PARAMETER) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_counter_ids);
    for (uint32_t i = 0; i < (uint32_t)number_of_counters; i++) {
      counters_out.push_back((sai_thrift_uint64_t)sai_counters[i]);
    }
    free(sai_counters);
    return;
  }

  void sai_thrift_get_macsec_port_stats_ext(std::vector<sai_thrift_uint64_t> & counters_out, const sai_thrift_object_id_t macsec_port_oid, const std::vector<sai_thrift_stat_id_t> & counter_ids, const sai_thrift_stats_mode_t mode) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_macsec_api_t *macsec_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_MACSEC), (void **)&macsec_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_stat_id_t *sai_counter_ids = NULL;
    uint32_t number_of_counters = counter_ids.size();

    if (number_of_counters != 0) {
      sai_counter_ids = (sai_stat_id_t *)malloc(sizeof(sai_stat_id_t) * number_of_counters);
    }
    else {
      return;
    }


    std::vector<sai_thrift_stat_id_t>::const_iterator it = counter_ids.begin();
    for (uint32_t i = 0; i < counter_ids.size(); i++, it++) {
      sai_counter_ids[i] = (sai_stat_id_t)*it;
    }

    uint64_t *sai_counters = NULL;
    if (number_of_counters != 0) {
      sai_counters = (uint64_t *)malloc(sizeof(uint64_t) * number_of_counters);
    }

    if (macsec_api->get_macsec_port_stats_ext == (void *)0) {
        std::cerr << "NULL ptr: macsec_api->get_macsec_port_stats_ext" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = macsec_api->get_macsec_port_stats_ext((sai_object_id_t)macsec_port_oid, number_of_counters, sai_counter_ids, (sai_stats_mode_t)mode, sai_counters);

    // sai_adapter always takes all macsec stats. Since some of them may be
    // not supported, SAI_STATUS_INVALID_PARAMETER should not be raised.
    if (status != SAI_STATUS_SUCCESS && status != SAI_STATUS_INVALID_PARAMETER) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_counter_ids);
    for (uint32_t i = 0; i < (uint32_t)number_of_counters; i++) {
      counters_out.push_back((sai_thrift_uint64_t)sai_counters[i]);
    }
    free(sai_counters);
    return;
  }

  void sai_thrift_clear_macsec_port_stats(const sai_thrift_object_id_t macsec_port_oid, const std::vector<sai_thrift_stat_id_t> & counter_ids) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_macsec_api_t *macsec_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_MACSEC), (void **)&macsec_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_stat_id_t *sai_counter_ids = NULL;
    uint32_t number_of_counters = counter_ids.size();

    if (number_of_counters != 0) {
      sai_counter_ids = (sai_stat_id_t *)malloc(sizeof(sai_stat_id_t) * number_of_counters);
    }
    else {
      return;
    }


    std::vector<sai_thrift_stat_id_t>::const_iterator it = counter_ids.begin();
    for (uint32_t i = 0; i < counter_ids.size(); i++, it++) {
      sai_counter_ids[i] = (sai_stat_id_t)*it;
    }

    if (macsec_api->clear_macsec_port_stats == (void *)0) {
        std::cerr << "NULL ptr: macsec_api->clear_macsec_port_stats" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = macsec_api->clear_macsec_port_stats((sai_object_id_t)macsec_port_oid, number_of_counters, sai_counter_ids);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_counter_ids);
    return;
  }

  sai_thrift_object_id_t sai_thrift_create_macsec_flow(const std::vector<sai_thrift_attribute_t> & attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t macsec_flow_oid_out = SAI_NULL_OBJECT_ID;

    sai_macsec_api_t *macsec_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_MACSEC), (void **)&macsec_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_macsec_flow_attributes(attr_list, sai_attr_list);

    if (macsec_api->create_macsec_flow == (void *)0) {
        std::cerr << "NULL ptr: macsec_api->create_macsec_flow" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = macsec_api->create_macsec_flow(&macsec_flow_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);    return macsec_flow_oid_out;
  }

  void sai_thrift_remove_macsec_flow(const sai_thrift_object_id_t macsec_flow_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_macsec_api_t *macsec_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_MACSEC), (void **)&macsec_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    if (macsec_api->remove_macsec_flow == (void *)0) {
        std::cerr << "NULL ptr: macsec_api->remove_macsec_flow" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = macsec_api->remove_macsec_flow((sai_object_id_t)macsec_flow_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_macsec_flow_attribute(const sai_thrift_object_id_t macsec_flow_oid, const sai_thrift_attribute_t& attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t sai_attr;

    sai_macsec_api_t *macsec_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_MACSEC), (void **)&macsec_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);

    sai_thrift_parse_macsec_flow_attributes(attr_vec, &sai_attr);

    if (macsec_api->set_macsec_flow_attribute == (void *)0) {
        std::cerr << "NULL ptr: macsec_api->set_macsec_flow_attribute" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = macsec_api->set_macsec_flow_attribute((sai_object_id_t)macsec_flow_oid, &sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_get_macsec_flow_attribute(sai_thrift_attribute_list_t& attr_list_out, const sai_thrift_object_id_t macsec_flow_oid, const sai_thrift_attribute_list_t& attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_macsec_api_t *macsec_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_MACSEC), (void **)&macsec_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    else {
      return;
    }


    const std::vector<sai_thrift_attribute_t> &attr_list_vec = attr_list.attr_list;

    sai_thrift_parse_macsec_flow_attributes(attr_list_vec, sai_attr_list);

    if (macsec_api->get_macsec_flow_attribute == (void *)0) {
        std::cerr << "NULL ptr: macsec_api->get_macsec_flow_attribute" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = macsec_api->get_macsec_flow_attribute((sai_object_id_t)macsec_flow_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_macsec_flow_attributes(sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  void sai_thrift_get_macsec_flow_stats(std::vector<sai_thrift_uint64_t> & counters_out, const sai_thrift_object_id_t macsec_flow_oid, const std::vector<sai_thrift_stat_id_t> & counter_ids) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_macsec_api_t *macsec_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_MACSEC), (void **)&macsec_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_stat_id_t *sai_counter_ids = NULL;
    uint32_t number_of_counters = counter_ids.size();

    if (number_of_counters != 0) {
      sai_counter_ids = (sai_stat_id_t *)malloc(sizeof(sai_stat_id_t) * number_of_counters);
    }
    else {
      return;
    }


    std::vector<sai_thrift_stat_id_t>::const_iterator it = counter_ids.begin();
    for (uint32_t i = 0; i < counter_ids.size(); i++, it++) {
      sai_counter_ids[i] = (sai_stat_id_t)*it;
    }

    uint64_t *sai_counters = NULL;
    if (number_of_counters != 0) {
      sai_counters = (uint64_t *)malloc(sizeof(uint64_t) * number_of_counters);
    }

    if (macsec_api->get_macsec_flow_stats == (void *)0) {
        std::cerr << "NULL ptr: macsec_api->get_macsec_flow_stats" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = macsec_api->get_macsec_flow_stats((sai_object_id_t)macsec_flow_oid, number_of_counters, sai_counter_ids, sai_counters);

    // sai_adapter always takes all macsec stats. Since some of them may be
    // not supported, SAI_STATUS_INVALID_PARAMETER should not be raised.
    if (status != SAI_STATUS_SUCCESS && status != SAI_STATUS_INVALID_PARAMETER) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_counter_ids);
    for (uint32_t i = 0; i < (uint32_t)number_of_counters; i++) {
      counters_out.push_back((sai_thrift_uint64_t)sai_counters[i]);
    }
    free(sai_counters);
    return;
  }

  void sai_thrift_get_macsec_flow_stats_ext(std::vector<sai_thrift_uint64_t> & counters_out, const sai_thrift_object_id_t macsec_flow_oid, const std::vector<sai_thrift_stat_id_t> & counter_ids, const sai_thrift_stats_mode_t mode) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_macsec_api_t *macsec_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_MACSEC), (void **)&macsec_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_stat_id_t *sai_counter_ids = NULL;
    uint32_t number_of_counters = counter_ids.size();

    if (number_of_counters != 0) {
      sai_counter_ids = (sai_stat_id_t *)malloc(sizeof(sai_stat_id_t) * number_of_counters);
    }
    else {
      return;
    }


    std::vector<sai_thrift_stat_id_t>::const_iterator it = counter_ids.begin();
    for (uint32_t i = 0; i < counter_ids.size(); i++, it++) {
      sai_counter_ids[i] = (sai_stat_id_t)*it;
    }

    uint64_t *sai_counters = NULL;
    if (number_of_counters != 0) {
      sai_counters = (uint64_t *)malloc(sizeof(uint64_t) * number_of_counters);
    }

    if (macsec_api->get_macsec_flow_stats_ext == (void *)0) {
        std::cerr << "NULL ptr: macsec_api->get_macsec_flow_stats_ext" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = macsec_api->get_macsec_flow_stats_ext((sai_object_id_t)macsec_flow_oid, number_of_counters, sai_counter_ids, (sai_stats_mode_t)mode, sai_counters);

    // sai_adapter always takes all macsec stats. Since some of them may be
    // not supported, SAI_STATUS_INVALID_PARAMETER should not be raised.
    if (status != SAI_STATUS_SUCCESS && status != SAI_STATUS_INVALID_PARAMETER) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_counter_ids);
    for (uint32_t i = 0; i < (uint32_t)number_of_counters; i++) {
      counters_out.push_back((sai_thrift_uint64_t)sai_counters[i]);
    }
    free(sai_counters);
    return;
  }

  void sai_thrift_clear_macsec_flow_stats(const sai_thrift_object_id_t macsec_flow_oid, const std::vector<sai_thrift_stat_id_t> & counter_ids) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_macsec_api_t *macsec_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_MACSEC), (void **)&macsec_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_stat_id_t *sai_counter_ids = NULL;
    uint32_t number_of_counters = counter_ids.size();

    if (number_of_counters != 0) {
      sai_counter_ids = (sai_stat_id_t *)malloc(sizeof(sai_stat_id_t) * number_of_counters);
    }
    else {
      return;
    }


    std::vector<sai_thrift_stat_id_t>::const_iterator it = counter_ids.begin();
    for (uint32_t i = 0; i < counter_ids.size(); i++, it++) {
      sai_counter_ids[i] = (sai_stat_id_t)*it;
    }

    if (macsec_api->clear_macsec_flow_stats == (void *)0) {
        std::cerr << "NULL ptr: macsec_api->clear_macsec_flow_stats" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = macsec_api->clear_macsec_flow_stats((sai_object_id_t)macsec_flow_oid, number_of_counters, sai_counter_ids);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_counter_ids);
    return;
  }

  sai_thrift_object_id_t sai_thrift_create_macsec_sc(const std::vector<sai_thrift_attribute_t> & attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t macsec_sc_oid_out = SAI_NULL_OBJECT_ID;

    sai_macsec_api_t *macsec_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_MACSEC), (void **)&macsec_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_macsec_sc_attributes(attr_list, sai_attr_list);

    if (macsec_api->create_macsec_sc == (void *)0) {
        std::cerr << "NULL ptr: macsec_api->create_macsec_sc" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = macsec_api->create_macsec_sc(&macsec_sc_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);    return macsec_sc_oid_out;
  }

  void sai_thrift_remove_macsec_sc(const sai_thrift_object_id_t macsec_sc_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_macsec_api_t *macsec_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_MACSEC), (void **)&macsec_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    if (macsec_api->remove_macsec_sc == (void *)0) {
        std::cerr << "NULL ptr: macsec_api->remove_macsec_sc" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = macsec_api->remove_macsec_sc((sai_object_id_t)macsec_sc_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_macsec_sc_attribute(const sai_thrift_object_id_t macsec_sc_oid, const sai_thrift_attribute_t& attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t sai_attr;

    sai_macsec_api_t *macsec_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_MACSEC), (void **)&macsec_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);

    sai_thrift_parse_macsec_sc_attributes(attr_vec, &sai_attr);

    if (macsec_api->set_macsec_sc_attribute == (void *)0) {
        std::cerr << "NULL ptr: macsec_api->set_macsec_sc_attribute" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = macsec_api->set_macsec_sc_attribute((sai_object_id_t)macsec_sc_oid, &sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_get_macsec_sc_attribute(sai_thrift_attribute_list_t& attr_list_out, const sai_thrift_object_id_t macsec_sc_oid, const sai_thrift_attribute_list_t& attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_macsec_api_t *macsec_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_MACSEC), (void **)&macsec_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    else {
      return;
    }


    const std::vector<sai_thrift_attribute_t> &attr_list_vec = attr_list.attr_list;

    sai_thrift_parse_macsec_sc_attributes(attr_list_vec, sai_attr_list);

    if (macsec_api->get_macsec_sc_attribute == (void *)0) {
        std::cerr << "NULL ptr: macsec_api->get_macsec_sc_attribute" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = macsec_api->get_macsec_sc_attribute((sai_object_id_t)macsec_sc_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_macsec_sc_attributes(sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  void sai_thrift_get_macsec_sc_stats(std::vector<sai_thrift_uint64_t> & counters_out, const sai_thrift_object_id_t macsec_sc_oid, const std::vector<sai_thrift_stat_id_t> & counter_ids) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_macsec_api_t *macsec_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_MACSEC), (void **)&macsec_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_stat_id_t *sai_counter_ids = NULL;
    uint32_t number_of_counters = counter_ids.size();

    if (number_of_counters != 0) {
      sai_counter_ids = (sai_stat_id_t *)malloc(sizeof(sai_stat_id_t) * number_of_counters);
    }
    else {
      return;
    }


    std::vector<sai_thrift_stat_id_t>::const_iterator it = counter_ids.begin();
    for (uint32_t i = 0; i < counter_ids.size(); i++, it++) {
      sai_counter_ids[i] = (sai_stat_id_t)*it;
    }

    uint64_t *sai_counters = NULL;
    if (number_of_counters != 0) {
      sai_counters = (uint64_t *)malloc(sizeof(uint64_t) * number_of_counters);
    }

    if (macsec_api->get_macsec_sc_stats == (void *)0) {
        std::cerr << "NULL ptr: macsec_api->get_macsec_sc_stats" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = macsec_api->get_macsec_sc_stats((sai_object_id_t)macsec_sc_oid, number_of_counters, sai_counter_ids, sai_counters);

    // sai_adapter always takes all macsec stats. Since some of them may be
    // not supported, SAI_STATUS_INVALID_PARAMETER should not be raised.
    if (status != SAI_STATUS_SUCCESS && status != SAI_STATUS_INVALID_PARAMETER) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_counter_ids);
    for (uint32_t i = 0; i < (uint32_t)number_of_counters; i++) {
      counters_out.push_back((sai_thrift_uint64_t)sai_counters[i]);
    }
    free(sai_counters);
    return;
  }

  void sai_thrift_get_macsec_sc_stats_ext(std::vector<sai_thrift_uint64_t> & counters_out, const sai_thrift_object_id_t macsec_sc_oid, const std::vector<sai_thrift_stat_id_t> & counter_ids, const sai_thrift_stats_mode_t mode) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_macsec_api_t *macsec_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_MACSEC), (void **)&macsec_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_stat_id_t *sai_counter_ids = NULL;
    uint32_t number_of_counters = counter_ids.size();

    if (number_of_counters != 0) {
      sai_counter_ids = (sai_stat_id_t *)malloc(sizeof(sai_stat_id_t) * number_of_counters);
    }
    else {
      return;
    }


    std::vector<sai_thrift_stat_id_t>::const_iterator it = counter_ids.begin();
    for (uint32_t i = 0; i < counter_ids.size(); i++, it++) {
      sai_counter_ids[i] = (sai_stat_id_t)*it;
    }

    uint64_t *sai_counters = NULL;
    if (number_of_counters != 0) {
      sai_counters = (uint64_t *)malloc(sizeof(uint64_t) * number_of_counters);
    }

    if (macsec_api->get_macsec_sc_stats_ext == (void *)0) {
        std::cerr << "NULL ptr: macsec_api->get_macsec_sc_stats_ext" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = macsec_api->get_macsec_sc_stats_ext((sai_object_id_t)macsec_sc_oid, number_of_counters, sai_counter_ids, (sai_stats_mode_t)mode, sai_counters);

    // sai_adapter always takes all macsec stats. Since some of them may be
    // not supported, SAI_STATUS_INVALID_PARAMETER should not be raised.
    if (status != SAI_STATUS_SUCCESS && status != SAI_STATUS_INVALID_PARAMETER) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_counter_ids);
    for (uint32_t i = 0; i < (uint32_t)number_of_counters; i++) {
      counters_out.push_back((sai_thrift_uint64_t)sai_counters[i]);
    }
    free(sai_counters);
    return;
  }

  void sai_thrift_clear_macsec_sc_stats(const sai_thrift_object_id_t macsec_sc_oid, const std::vector<sai_thrift_stat_id_t> & counter_ids) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_macsec_api_t *macsec_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_MACSEC), (void **)&macsec_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_stat_id_t *sai_counter_ids = NULL;
    uint32_t number_of_counters = counter_ids.size();

    if (number_of_counters != 0) {
      sai_counter_ids = (sai_stat_id_t *)malloc(sizeof(sai_stat_id_t) * number_of_counters);
    }
    else {
      return;
    }


    std::vector<sai_thrift_stat_id_t>::const_iterator it = counter_ids.begin();
    for (uint32_t i = 0; i < counter_ids.size(); i++, it++) {
      sai_counter_ids[i] = (sai_stat_id_t)*it;
    }

    if (macsec_api->clear_macsec_sc_stats == (void *)0) {
        std::cerr << "NULL ptr: macsec_api->clear_macsec_sc_stats" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = macsec_api->clear_macsec_sc_stats((sai_object_id_t)macsec_sc_oid, number_of_counters, sai_counter_ids);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_counter_ids);
    return;
  }

  sai_thrift_object_id_t sai_thrift_create_macsec_sa(const std::vector<sai_thrift_attribute_t> & attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t macsec_sa_oid_out = SAI_NULL_OBJECT_ID;

    sai_macsec_api_t *macsec_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_MACSEC), (void **)&macsec_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_macsec_sa_attributes(attr_list, sai_attr_list);

    if (macsec_api->create_macsec_sa == (void *)0) {
        std::cerr << "NULL ptr: macsec_api->create_macsec_sa" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = macsec_api->create_macsec_sa(&macsec_sa_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);    return macsec_sa_oid_out;
  }

  void sai_thrift_remove_macsec_sa(const sai_thrift_object_id_t macsec_sa_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_macsec_api_t *macsec_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_MACSEC), (void **)&macsec_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    if (macsec_api->remove_macsec_sa == (void *)0) {
        std::cerr << "NULL ptr: macsec_api->remove_macsec_sa" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = macsec_api->remove_macsec_sa((sai_object_id_t)macsec_sa_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_macsec_sa_attribute(const sai_thrift_object_id_t macsec_sa_oid, const sai_thrift_attribute_t& attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t sai_attr;

    sai_macsec_api_t *macsec_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_MACSEC), (void **)&macsec_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);

    sai_thrift_parse_macsec_sa_attributes(attr_vec, &sai_attr);

    if (macsec_api->set_macsec_sa_attribute == (void *)0) {
        std::cerr << "NULL ptr: macsec_api->set_macsec_sa_attribute" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = macsec_api->set_macsec_sa_attribute((sai_object_id_t)macsec_sa_oid, &sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_get_macsec_sa_attribute(sai_thrift_attribute_list_t& attr_list_out, const sai_thrift_object_id_t macsec_sa_oid, const sai_thrift_attribute_list_t& attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_macsec_api_t *macsec_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_MACSEC), (void **)&macsec_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    else {
      return;
    }


    const std::vector<sai_thrift_attribute_t> &attr_list_vec = attr_list.attr_list;

    sai_thrift_parse_macsec_sa_attributes(attr_list_vec, sai_attr_list);

    if (macsec_api->get_macsec_sa_attribute == (void *)0) {
        std::cerr << "NULL ptr: macsec_api->get_macsec_sa_attribute" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = macsec_api->get_macsec_sa_attribute((sai_object_id_t)macsec_sa_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_macsec_sa_attributes(sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  void sai_thrift_get_macsec_sa_stats(std::vector<sai_thrift_uint64_t> & counters_out, const sai_thrift_object_id_t macsec_sa_oid, const std::vector<sai_thrift_stat_id_t> & counter_ids) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_macsec_api_t *macsec_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_MACSEC), (void **)&macsec_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_stat_id_t *sai_counter_ids = NULL;
    uint32_t number_of_counters = counter_ids.size();

    if (number_of_counters != 0) {
      sai_counter_ids = (sai_stat_id_t *)malloc(sizeof(sai_stat_id_t) * number_of_counters);
    }
    else {
      return;
    }


    std::vector<sai_thrift_stat_id_t>::const_iterator it = counter_ids.begin();
    for (uint32_t i = 0; i < counter_ids.size(); i++, it++) {
      sai_counter_ids[i] = (sai_stat_id_t)*it;
    }

    uint64_t *sai_counters = NULL;
    if (number_of_counters != 0) {
      sai_counters = (uint64_t *)malloc(sizeof(uint64_t) * number_of_counters);
    }

    if (macsec_api->get_macsec_sa_stats == (void *)0) {
        std::cerr << "NULL ptr: macsec_api->get_macsec_sa_stats" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = macsec_api->get_macsec_sa_stats((sai_object_id_t)macsec_sa_oid, number_of_counters, sai_counter_ids, sai_counters);

    // sai_adapter always takes all macsec stats. Since some of them may be
    // not supported, SAI_STATUS_INVALID_PARAMETER should not be raised.
    if (status != SAI_STATUS_SUCCESS && status != SAI_STATUS_INVALID_PARAMETER) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_counter_ids);
    for (uint32_t i = 0; i < (uint32_t)number_of_counters; i++) {
      counters_out.push_back((sai_thrift_uint64_t)sai_counters[i]);
    }
    free(sai_counters);
    return;
  }

  void sai_thrift_get_macsec_sa_stats_ext(std::vector<sai_thrift_uint64_t> & counters_out, const sai_thrift_object_id_t macsec_sa_oid, const std::vector<sai_thrift_stat_id_t> & counter_ids, const sai_thrift_stats_mode_t mode) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_macsec_api_t *macsec_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_MACSEC), (void **)&macsec_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_stat_id_t *sai_counter_ids = NULL;
    uint32_t number_of_counters = counter_ids.size();

    if (number_of_counters != 0) {
      sai_counter_ids = (sai_stat_id_t *)malloc(sizeof(sai_stat_id_t) * number_of_counters);
    }
    else {
      return;
    }


    std::vector<sai_thrift_stat_id_t>::const_iterator it = counter_ids.begin();
    for (uint32_t i = 0; i < counter_ids.size(); i++, it++) {
      sai_counter_ids[i] = (sai_stat_id_t)*it;
    }

    uint64_t *sai_counters = NULL;
    if (number_of_counters != 0) {
      sai_counters = (uint64_t *)malloc(sizeof(uint64_t) * number_of_counters);
    }

    if (macsec_api->get_macsec_sa_stats_ext == (void *)0) {
        std::cerr << "NULL ptr: macsec_api->get_macsec_sa_stats_ext" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = macsec_api->get_macsec_sa_stats_ext((sai_object_id_t)macsec_sa_oid, number_of_counters, sai_counter_ids, (sai_stats_mode_t)mode, sai_counters);

    // sai_adapter always takes all macsec stats. Since some of them may be
    // not supported, SAI_STATUS_INVALID_PARAMETER should not be raised.
    if (status != SAI_STATUS_SUCCESS && status != SAI_STATUS_INVALID_PARAMETER) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_counter_ids);
    for (uint32_t i = 0; i < (uint32_t)number_of_counters; i++) {
      counters_out.push_back((sai_thrift_uint64_t)sai_counters[i]);
    }
    free(sai_counters);
    return;
  }

  void sai_thrift_clear_macsec_sa_stats(const sai_thrift_object_id_t macsec_sa_oid, const std::vector<sai_thrift_stat_id_t> & counter_ids) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_macsec_api_t *macsec_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_MACSEC), (void **)&macsec_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_stat_id_t *sai_counter_ids = NULL;
    uint32_t number_of_counters = counter_ids.size();

    if (number_of_counters != 0) {
      sai_counter_ids = (sai_stat_id_t *)malloc(sizeof(sai_stat_id_t) * number_of_counters);
    }
    else {
      return;
    }


    std::vector<sai_thrift_stat_id_t>::const_iterator it = counter_ids.begin();
    for (uint32_t i = 0; i < counter_ids.size(); i++, it++) {
      sai_counter_ids[i] = (sai_stat_id_t)*it;
    }

    if (macsec_api->clear_macsec_sa_stats == (void *)0) {
        std::cerr << "NULL ptr: macsec_api->clear_macsec_sa_stats" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = macsec_api->clear_macsec_sa_stats((sai_object_id_t)macsec_sa_oid, number_of_counters, sai_counter_ids);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_counter_ids);
    return;
  }

  void sai_thrift_create_mcast_fdb_entry(const sai_thrift_mcast_fdb_entry_t& mcast_fdb_entry, const std::vector<sai_thrift_attribute_t> & attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_mcast_fdb_entry_t sai_mcast_fdb_entry;

    sai_mcastfdb_api_t *mcastfdb_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_MCASTFDB), (void **)&mcastfdb_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_parse_mcast_fdb_entry(mcast_fdb_entry, &sai_mcast_fdb_entry);

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_mcast_fdb_entry_attributes(attr_list, sai_attr_list);

    if (mcastfdb_api->create_mcast_fdb_entry == (void *)0) {
        std::cerr << "NULL ptr: mcastfdb_api->create_mcast_fdb_entry" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = mcastfdb_api->create_mcast_fdb_entry(&sai_mcast_fdb_entry, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);
    return;
  }

  void sai_thrift_remove_mcast_fdb_entry(const sai_thrift_mcast_fdb_entry_t& mcast_fdb_entry) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_mcast_fdb_entry_t sai_mcast_fdb_entry;

    sai_mcastfdb_api_t *mcastfdb_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_MCASTFDB), (void **)&mcastfdb_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_parse_mcast_fdb_entry(mcast_fdb_entry, &sai_mcast_fdb_entry);

    if (mcastfdb_api->remove_mcast_fdb_entry == (void *)0) {
        std::cerr << "NULL ptr: mcastfdb_api->remove_mcast_fdb_entry" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = mcastfdb_api->remove_mcast_fdb_entry(&sai_mcast_fdb_entry);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_mcast_fdb_entry_attribute(const sai_thrift_mcast_fdb_entry_t& mcast_fdb_entry, const sai_thrift_attribute_t& attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_mcast_fdb_entry_t sai_mcast_fdb_entry;
    sai_attribute_t sai_attr;

    sai_mcastfdb_api_t *mcastfdb_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_MCASTFDB), (void **)&mcastfdb_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_parse_mcast_fdb_entry(mcast_fdb_entry, &sai_mcast_fdb_entry);

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);

    sai_thrift_parse_mcast_fdb_entry_attributes(attr_vec, &sai_attr);

    if (mcastfdb_api->set_mcast_fdb_entry_attribute == (void *)0) {
        std::cerr << "NULL ptr: mcastfdb_api->set_mcast_fdb_entry_attribute" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = mcastfdb_api->set_mcast_fdb_entry_attribute(&sai_mcast_fdb_entry, &sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_get_mcast_fdb_entry_attribute(sai_thrift_attribute_list_t& attr_list_out, const sai_thrift_mcast_fdb_entry_t& mcast_fdb_entry, const sai_thrift_attribute_list_t& attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_mcast_fdb_entry_t sai_mcast_fdb_entry;

    sai_mcastfdb_api_t *mcastfdb_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_MCASTFDB), (void **)&mcastfdb_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_parse_mcast_fdb_entry(mcast_fdb_entry, &sai_mcast_fdb_entry);

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    else {
      return;
    }


    const std::vector<sai_thrift_attribute_t> &attr_list_vec = attr_list.attr_list;

    sai_thrift_parse_mcast_fdb_entry_attributes(attr_list_vec, sai_attr_list);

    if (mcastfdb_api->get_mcast_fdb_entry_attribute == (void *)0) {
        std::cerr << "NULL ptr: mcastfdb_api->get_mcast_fdb_entry_attribute" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = mcastfdb_api->get_mcast_fdb_entry_attribute(&sai_mcast_fdb_entry, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_mcast_fdb_entry_attributes(sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  sai_thrift_object_id_t sai_thrift_create_mirror_session(const std::vector<sai_thrift_attribute_t> & attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t mirror_session_oid_out = SAI_NULL_OBJECT_ID;

    sai_mirror_api_t *mirror_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_MIRROR), (void **)&mirror_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_mirror_session_attributes(attr_list, sai_attr_list);

    if (mirror_api->create_mirror_session == (void *)0) {
        std::cerr << "NULL ptr: mirror_api->create_mirror_session" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = mirror_api->create_mirror_session(&mirror_session_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);    return mirror_session_oid_out;
  }

  void sai_thrift_remove_mirror_session(const sai_thrift_object_id_t mirror_session_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_mirror_api_t *mirror_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_MIRROR), (void **)&mirror_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    if (mirror_api->remove_mirror_session == (void *)0) {
        std::cerr << "NULL ptr: mirror_api->remove_mirror_session" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = mirror_api->remove_mirror_session((sai_object_id_t)mirror_session_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_mirror_session_attribute(const sai_thrift_object_id_t mirror_session_oid, const sai_thrift_attribute_t& attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t sai_attr;

    sai_mirror_api_t *mirror_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_MIRROR), (void **)&mirror_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);

    sai_thrift_parse_mirror_session_attributes(attr_vec, &sai_attr);

    if (mirror_api->set_mirror_session_attribute == (void *)0) {
        std::cerr << "NULL ptr: mirror_api->set_mirror_session_attribute" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = mirror_api->set_mirror_session_attribute((sai_object_id_t)mirror_session_oid, &sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_get_mirror_session_attribute(sai_thrift_attribute_list_t& attr_list_out, const sai_thrift_object_id_t mirror_session_oid, const sai_thrift_attribute_list_t& attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_mirror_api_t *mirror_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_MIRROR), (void **)&mirror_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    else {
      return;
    }


    const std::vector<sai_thrift_attribute_t> &attr_list_vec = attr_list.attr_list;

    sai_thrift_parse_mirror_session_attributes(attr_list_vec, sai_attr_list);

    if (mirror_api->get_mirror_session_attribute == (void *)0) {
        std::cerr << "NULL ptr: mirror_api->get_mirror_session_attribute" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = mirror_api->get_mirror_session_attribute((sai_object_id_t)mirror_session_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_mirror_session_attributes(sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  void sai_thrift_create_inseg_entry(const sai_thrift_inseg_entry_t& inseg_entry, const std::vector<sai_thrift_attribute_t> & attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_inseg_entry_t sai_inseg_entry;

    sai_mpls_api_t *mpls_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_MPLS), (void **)&mpls_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_parse_inseg_entry(inseg_entry, &sai_inseg_entry);

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_inseg_entry_attributes(attr_list, sai_attr_list);

    if (mpls_api->create_inseg_entry == (void *)0) {
        std::cerr << "NULL ptr: mpls_api->create_inseg_entry" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = mpls_api->create_inseg_entry(&sai_inseg_entry, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);
    return;
  }

  void sai_thrift_remove_inseg_entry(const sai_thrift_inseg_entry_t& inseg_entry) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_inseg_entry_t sai_inseg_entry;

    sai_mpls_api_t *mpls_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_MPLS), (void **)&mpls_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_parse_inseg_entry(inseg_entry, &sai_inseg_entry);

    if (mpls_api->remove_inseg_entry == (void *)0) {
        std::cerr << "NULL ptr: mpls_api->remove_inseg_entry" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = mpls_api->remove_inseg_entry(&sai_inseg_entry);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_inseg_entry_attribute(const sai_thrift_inseg_entry_t& inseg_entry, const sai_thrift_attribute_t& attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_inseg_entry_t sai_inseg_entry;
    sai_attribute_t sai_attr;

    sai_mpls_api_t *mpls_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_MPLS), (void **)&mpls_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_parse_inseg_entry(inseg_entry, &sai_inseg_entry);

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);

    sai_thrift_parse_inseg_entry_attributes(attr_vec, &sai_attr);

    if (mpls_api->set_inseg_entry_attribute == (void *)0) {
        std::cerr << "NULL ptr: mpls_api->set_inseg_entry_attribute" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = mpls_api->set_inseg_entry_attribute(&sai_inseg_entry, &sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_get_inseg_entry_attribute(sai_thrift_attribute_list_t& attr_list_out, const sai_thrift_inseg_entry_t& inseg_entry, const sai_thrift_attribute_list_t& attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_inseg_entry_t sai_inseg_entry;

    sai_mpls_api_t *mpls_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_MPLS), (void **)&mpls_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_parse_inseg_entry(inseg_entry, &sai_inseg_entry);

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    else {
      return;
    }


    const std::vector<sai_thrift_attribute_t> &attr_list_vec = attr_list.attr_list;

    sai_thrift_parse_inseg_entry_attributes(attr_list_vec, sai_attr_list);

    if (mpls_api->get_inseg_entry_attribute == (void *)0) {
        std::cerr << "NULL ptr: mpls_api->get_inseg_entry_attribute" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = mpls_api->get_inseg_entry_attribute(&sai_inseg_entry, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_inseg_entry_attributes(sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  void sai_thrift_bulk_create_inseg_entry(std::vector<sai_thrift_status_t> & object_statuses_out, const std::vector<sai_thrift_inseg_entry_t> & inseg_entry, const std::vector<sai_thrift_uint32_t> & attr_count, const std::vector<sai_thrift_attribute_t> & attr_list, const sai_thrift_bulk_op_error_mode_t mode) {

    // This function is UNSUPPORTED
    return;
  }

  void sai_thrift_bulk_remove_inseg_entry(std::vector<sai_thrift_status_t> & object_statuses_out, const std::vector<sai_thrift_inseg_entry_t> & inseg_entry, const sai_thrift_bulk_op_error_mode_t mode) {

    // This function is UNSUPPORTED
    return;
  }

  void sai_thrift_bulk_set_inseg_entry_attribute(std::vector<sai_thrift_status_t> & object_statuses_out, const std::vector<sai_thrift_inseg_entry_t> & inseg_entry, const std::vector<sai_thrift_attribute_t> & attr_list, const sai_thrift_bulk_op_error_mode_t mode) {

    // This function is UNSUPPORTED
    return;
  }

  void sai_thrift_bulk_get_inseg_entry_attribute(sai_thrift_attribute_list_t& attr_list_out, const std::vector<sai_thrift_inseg_entry_t> & inseg_entry, const std::vector<sai_thrift_uint32_t> & attr_count, const sai_thrift_attribute_list_t& attr_list, const sai_thrift_bulk_op_error_mode_t mode, const std::vector<sai_thrift_status_t> & object_statuses) {

    // This function is UNSUPPORTED
    return;
  }

  sai_thrift_object_id_t sai_thrift_create_my_mac(const std::vector<sai_thrift_attribute_t> & attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t my_mac_oid_out = SAI_NULL_OBJECT_ID;

    sai_mymac_api_t *mymac_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_MYMAC), (void **)&mymac_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_my_mac_attributes(attr_list, sai_attr_list);

    if (mymac_api->create_my_mac == (void *)0) {
        std::cerr << "NULL ptr: mymac_api->create_my_mac" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = mymac_api->create_my_mac(&my_mac_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);    return my_mac_oid_out;
  }

  void sai_thrift_remove_my_mac(const sai_thrift_object_id_t my_mac_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_mymac_api_t *mymac_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_MYMAC), (void **)&mymac_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    if (mymac_api->remove_my_mac == (void *)0) {
        std::cerr << "NULL ptr: mymac_api->remove_my_mac" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = mymac_api->remove_my_mac((sai_object_id_t)my_mac_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_my_mac_attribute(const sai_thrift_object_id_t my_mac_oid, const sai_thrift_attribute_t& attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t sai_attr;

    sai_mymac_api_t *mymac_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_MYMAC), (void **)&mymac_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);

    sai_thrift_parse_my_mac_attributes(attr_vec, &sai_attr);

    if (mymac_api->set_my_mac_attribute == (void *)0) {
        std::cerr << "NULL ptr: mymac_api->set_my_mac_attribute" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = mymac_api->set_my_mac_attribute((sai_object_id_t)my_mac_oid, &sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_get_my_mac_attribute(sai_thrift_attribute_list_t& attr_list_out, const sai_thrift_object_id_t my_mac_oid, const sai_thrift_attribute_list_t& attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_mymac_api_t *mymac_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_MYMAC), (void **)&mymac_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    else {
      return;
    }


    const std::vector<sai_thrift_attribute_t> &attr_list_vec = attr_list.attr_list;

    sai_thrift_parse_my_mac_attributes(attr_list_vec, sai_attr_list);

    if (mymac_api->get_my_mac_attribute == (void *)0) {
        std::cerr << "NULL ptr: mymac_api->get_my_mac_attribute" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = mymac_api->get_my_mac_attribute((sai_object_id_t)my_mac_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_my_mac_attributes(sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  void sai_thrift_create_nat_entry(const sai_thrift_nat_entry_t& nat_entry, const std::vector<sai_thrift_attribute_t> & attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_nat_entry_t sai_nat_entry;

    sai_nat_api_t *nat_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_NAT), (void **)&nat_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_parse_nat_entry(nat_entry, &sai_nat_entry);

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_nat_entry_attributes(attr_list, sai_attr_list);

    if (nat_api->create_nat_entry == (void *)0) {
        std::cerr << "NULL ptr: nat_api->create_nat_entry" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = nat_api->create_nat_entry(&sai_nat_entry, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);
    return;
  }

  void sai_thrift_remove_nat_entry(const sai_thrift_nat_entry_t& nat_entry) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_nat_entry_t sai_nat_entry;

    sai_nat_api_t *nat_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_NAT), (void **)&nat_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_parse_nat_entry(nat_entry, &sai_nat_entry);

    if (nat_api->remove_nat_entry == (void *)0) {
        std::cerr << "NULL ptr: nat_api->remove_nat_entry" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = nat_api->remove_nat_entry(&sai_nat_entry);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_nat_entry_attribute(const sai_thrift_nat_entry_t& nat_entry, const sai_thrift_attribute_t& attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_nat_entry_t sai_nat_entry;
    sai_attribute_t sai_attr;

    sai_nat_api_t *nat_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_NAT), (void **)&nat_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_parse_nat_entry(nat_entry, &sai_nat_entry);

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);

    sai_thrift_parse_nat_entry_attributes(attr_vec, &sai_attr);

    if (nat_api->set_nat_entry_attribute == (void *)0) {
        std::cerr << "NULL ptr: nat_api->set_nat_entry_attribute" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = nat_api->set_nat_entry_attribute(&sai_nat_entry, &sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_get_nat_entry_attribute(sai_thrift_attribute_list_t& attr_list_out, const sai_thrift_nat_entry_t& nat_entry, const sai_thrift_attribute_list_t& attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_nat_entry_t sai_nat_entry;

    sai_nat_api_t *nat_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_NAT), (void **)&nat_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_parse_nat_entry(nat_entry, &sai_nat_entry);

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    else {
      return;
    }


    const std::vector<sai_thrift_attribute_t> &attr_list_vec = attr_list.attr_list;

    sai_thrift_parse_nat_entry_attributes(attr_list_vec, sai_attr_list);

    if (nat_api->get_nat_entry_attribute == (void *)0) {
        std::cerr << "NULL ptr: nat_api->get_nat_entry_attribute" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = nat_api->get_nat_entry_attribute(&sai_nat_entry, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_nat_entry_attributes(sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  void sai_thrift_bulk_create_nat_entry(std::vector<sai_thrift_status_t> & object_statuses_out, const std::vector<sai_thrift_nat_entry_t> & nat_entry, const std::vector<sai_thrift_uint32_t> & attr_count, const std::vector<sai_thrift_attribute_t> & attr_list, const sai_thrift_bulk_op_error_mode_t mode) {

    // This function is UNSUPPORTED
    return;
  }

  void sai_thrift_bulk_remove_nat_entry(std::vector<sai_thrift_status_t> & object_statuses_out, const std::vector<sai_thrift_nat_entry_t> & nat_entry, const sai_thrift_bulk_op_error_mode_t mode) {

    // This function is UNSUPPORTED
    return;
  }

  void sai_thrift_bulk_set_nat_entry_attribute(std::vector<sai_thrift_status_t> & object_statuses_out, const std::vector<sai_thrift_nat_entry_t> & nat_entry, const std::vector<sai_thrift_attribute_t> & attr_list, const sai_thrift_bulk_op_error_mode_t mode) {

    // This function is UNSUPPORTED
    return;
  }

  void sai_thrift_bulk_get_nat_entry_attribute(sai_thrift_attribute_list_t& attr_list_out, const std::vector<sai_thrift_nat_entry_t> & nat_entry, const std::vector<sai_thrift_uint32_t> & attr_count, const sai_thrift_attribute_list_t& attr_list, const sai_thrift_bulk_op_error_mode_t mode, const std::vector<sai_thrift_status_t> & object_statuses) {

    // This function is UNSUPPORTED
    return;
  }

  sai_thrift_object_id_t sai_thrift_create_nat_zone_counter(const std::vector<sai_thrift_attribute_t> & attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t nat_zone_counter_oid_out = SAI_NULL_OBJECT_ID;

    sai_nat_api_t *nat_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_NAT), (void **)&nat_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_nat_zone_counter_attributes(attr_list, sai_attr_list);

    if (nat_api->create_nat_zone_counter == (void *)0) {
        std::cerr << "NULL ptr: nat_api->create_nat_zone_counter" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = nat_api->create_nat_zone_counter(&nat_zone_counter_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);    return nat_zone_counter_oid_out;
  }

  void sai_thrift_remove_nat_zone_counter(const sai_thrift_object_id_t nat_zone_counter_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_nat_api_t *nat_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_NAT), (void **)&nat_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    if (nat_api->remove_nat_zone_counter == (void *)0) {
        std::cerr << "NULL ptr: nat_api->remove_nat_zone_counter" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = nat_api->remove_nat_zone_counter((sai_object_id_t)nat_zone_counter_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_nat_zone_counter_attribute(const sai_thrift_object_id_t nat_zone_counter_oid, const sai_thrift_attribute_t& attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t sai_attr;

    sai_nat_api_t *nat_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_NAT), (void **)&nat_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);

    sai_thrift_parse_nat_zone_counter_attributes(attr_vec, &sai_attr);

    if (nat_api->set_nat_zone_counter_attribute == (void *)0) {
        std::cerr << "NULL ptr: nat_api->set_nat_zone_counter_attribute" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = nat_api->set_nat_zone_counter_attribute((sai_object_id_t)nat_zone_counter_oid, &sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_get_nat_zone_counter_attribute(sai_thrift_attribute_list_t& attr_list_out, const sai_thrift_object_id_t nat_zone_counter_oid, const sai_thrift_attribute_list_t& attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_nat_api_t *nat_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_NAT), (void **)&nat_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    else {
      return;
    }


    const std::vector<sai_thrift_attribute_t> &attr_list_vec = attr_list.attr_list;

    sai_thrift_parse_nat_zone_counter_attributes(attr_list_vec, sai_attr_list);

    if (nat_api->get_nat_zone_counter_attribute == (void *)0) {
        std::cerr << "NULL ptr: nat_api->get_nat_zone_counter_attribute" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = nat_api->get_nat_zone_counter_attribute((sai_object_id_t)nat_zone_counter_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_nat_zone_counter_attributes(sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  void sai_thrift_create_neighbor_entry(const sai_thrift_neighbor_entry_t& neighbor_entry, const std::vector<sai_thrift_attribute_t> & attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_neighbor_entry_t sai_neighbor_entry;

    sai_neighbor_api_t *neighbor_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_NEIGHBOR), (void **)&neighbor_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_parse_neighbor_entry(neighbor_entry, &sai_neighbor_entry);

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_neighbor_entry_attributes(attr_list, sai_attr_list);

    if (neighbor_api->create_neighbor_entry == (void *)0) {
        std::cerr << "NULL ptr: neighbor_api->create_neighbor_entry" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = neighbor_api->create_neighbor_entry(&sai_neighbor_entry, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);
    return;
  }

  void sai_thrift_remove_neighbor_entry(const sai_thrift_neighbor_entry_t& neighbor_entry) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_neighbor_entry_t sai_neighbor_entry;

    sai_neighbor_api_t *neighbor_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_NEIGHBOR), (void **)&neighbor_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_parse_neighbor_entry(neighbor_entry, &sai_neighbor_entry);

    if (neighbor_api->remove_neighbor_entry == (void *)0) {
        std::cerr << "NULL ptr: neighbor_api->remove_neighbor_entry" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = neighbor_api->remove_neighbor_entry(&sai_neighbor_entry);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_neighbor_entry_attribute(const sai_thrift_neighbor_entry_t& neighbor_entry, const sai_thrift_attribute_t& attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_neighbor_entry_t sai_neighbor_entry;
    sai_attribute_t sai_attr;

    sai_neighbor_api_t *neighbor_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_NEIGHBOR), (void **)&neighbor_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_parse_neighbor_entry(neighbor_entry, &sai_neighbor_entry);

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);

    sai_thrift_parse_neighbor_entry_attributes(attr_vec, &sai_attr);

    if (neighbor_api->set_neighbor_entry_attribute == (void *)0) {
        std::cerr << "NULL ptr: neighbor_api->set_neighbor_entry_attribute" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = neighbor_api->set_neighbor_entry_attribute(&sai_neighbor_entry, &sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_get_neighbor_entry_attribute(sai_thrift_attribute_list_t& attr_list_out, const sai_thrift_neighbor_entry_t& neighbor_entry, const sai_thrift_attribute_list_t& attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_neighbor_entry_t sai_neighbor_entry;

    sai_neighbor_api_t *neighbor_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_NEIGHBOR), (void **)&neighbor_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_parse_neighbor_entry(neighbor_entry, &sai_neighbor_entry);

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    else {
      return;
    }


    const std::vector<sai_thrift_attribute_t> &attr_list_vec = attr_list.attr_list;

    sai_thrift_parse_neighbor_entry_attributes(attr_list_vec, sai_attr_list);

    if (neighbor_api->get_neighbor_entry_attribute == (void *)0) {
        std::cerr << "NULL ptr: neighbor_api->get_neighbor_entry_attribute" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = neighbor_api->get_neighbor_entry_attribute(&sai_neighbor_entry, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_neighbor_entry_attributes(sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  void sai_thrift_remove_all_neighbor_entries() {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_neighbor_api_t *neighbor_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_NEIGHBOR), (void **)&neighbor_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    if (neighbor_api->remove_all_neighbor_entries == (void *)0) {
        std::cerr << "NULL ptr: neighbor_api->remove_all_neighbor_entries" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = neighbor_api->remove_all_neighbor_entries(switch_id);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_bulk_create_neighbor_entry(std::vector<sai_thrift_status_t> & object_statuses_out, const std::vector<sai_thrift_neighbor_entry_t> & neighbor_entry, const std::vector<sai_thrift_uint32_t> & attr_count, const std::vector<sai_thrift_attribute_t> & attr_list, const sai_thrift_bulk_op_error_mode_t mode) {

    // This function is UNSUPPORTED
    return;
  }

  void sai_thrift_bulk_remove_neighbor_entry(std::vector<sai_thrift_status_t> & object_statuses_out, const std::vector<sai_thrift_neighbor_entry_t> & neighbor_entry, const sai_thrift_bulk_op_error_mode_t mode) {

    // This function is UNSUPPORTED
    return;
  }

  void sai_thrift_bulk_set_neighbor_entry_attribute(std::vector<sai_thrift_status_t> & object_statuses_out, const std::vector<sai_thrift_neighbor_entry_t> & neighbor_entry, const std::vector<sai_thrift_attribute_t> & attr_list, const sai_thrift_bulk_op_error_mode_t mode) {

    // This function is UNSUPPORTED
    return;
  }

  void sai_thrift_bulk_get_neighbor_entry_attribute(sai_thrift_attribute_list_t& attr_list_out, const std::vector<sai_thrift_neighbor_entry_t> & neighbor_entry, const std::vector<sai_thrift_uint32_t> & attr_count, const sai_thrift_attribute_list_t& attr_list, const sai_thrift_bulk_op_error_mode_t mode, const std::vector<sai_thrift_status_t> & object_statuses) {

    // This function is UNSUPPORTED
    return;
  }

  sai_thrift_object_id_t sai_thrift_create_next_hop(const std::vector<sai_thrift_attribute_t> & attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t next_hop_oid_out = SAI_NULL_OBJECT_ID;

    sai_nexthop_api_t *nexthop_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_NEXTHOP), (void **)&nexthop_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_next_hop_attributes(attr_list, sai_attr_list);

    if (nexthop_api->create_next_hop == (void *)0) {
        std::cerr << "NULL ptr: nexthop_api->create_next_hop" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = nexthop_api->create_next_hop(&next_hop_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);    return next_hop_oid_out;
  }

  void sai_thrift_remove_next_hop(const sai_thrift_object_id_t next_hop_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_nexthop_api_t *nexthop_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_NEXTHOP), (void **)&nexthop_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    if (nexthop_api->remove_next_hop == (void *)0) {
        std::cerr << "NULL ptr: nexthop_api->remove_next_hop" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = nexthop_api->remove_next_hop((sai_object_id_t)next_hop_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_next_hop_attribute(const sai_thrift_object_id_t next_hop_oid, const sai_thrift_attribute_t& attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t sai_attr;

    sai_nexthop_api_t *nexthop_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_NEXTHOP), (void **)&nexthop_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);

    sai_thrift_parse_next_hop_attributes(attr_vec, &sai_attr);

    if (nexthop_api->set_next_hop_attribute == (void *)0) {
        std::cerr << "NULL ptr: nexthop_api->set_next_hop_attribute" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = nexthop_api->set_next_hop_attribute((sai_object_id_t)next_hop_oid, &sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_get_next_hop_attribute(sai_thrift_attribute_list_t& attr_list_out, const sai_thrift_object_id_t next_hop_oid, const sai_thrift_attribute_list_t& attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_nexthop_api_t *nexthop_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_NEXTHOP), (void **)&nexthop_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    else {
      return;
    }


    const std::vector<sai_thrift_attribute_t> &attr_list_vec = attr_list.attr_list;

    sai_thrift_parse_next_hop_attributes(attr_list_vec, sai_attr_list);

    if (nexthop_api->get_next_hop_attribute == (void *)0) {
        std::cerr << "NULL ptr: nexthop_api->get_next_hop_attribute" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = nexthop_api->get_next_hop_attribute((sai_object_id_t)next_hop_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_next_hop_attributes(sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  sai_thrift_object_id_t sai_thrift_create_next_hop_group(const std::vector<sai_thrift_attribute_t> & attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t next_hop_group_oid_out = SAI_NULL_OBJECT_ID;

    sai_nexthopgroup_api_t *nexthopgroup_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_NEXTHOPGROUP), (void **)&nexthopgroup_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_next_hop_group_attributes(attr_list, sai_attr_list);

    if (nexthopgroup_api->create_next_hop_group == (void *)0) {
        std::cerr << "NULL ptr: nexthopgroup_api->create_next_hop_group" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = nexthopgroup_api->create_next_hop_group(&next_hop_group_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);    return next_hop_group_oid_out;
  }

  void sai_thrift_remove_next_hop_group(const sai_thrift_object_id_t next_hop_group_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_nexthopgroup_api_t *nexthopgroup_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_NEXTHOPGROUP), (void **)&nexthopgroup_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    if (nexthopgroup_api->remove_next_hop_group == (void *)0) {
        std::cerr << "NULL ptr: nexthopgroup_api->remove_next_hop_group" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = nexthopgroup_api->remove_next_hop_group((sai_object_id_t)next_hop_group_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_next_hop_group_attribute(const sai_thrift_object_id_t next_hop_group_oid, const sai_thrift_attribute_t& attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t sai_attr;

    sai_nexthopgroup_api_t *nexthopgroup_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_NEXTHOPGROUP), (void **)&nexthopgroup_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);

    sai_thrift_parse_next_hop_group_attributes(attr_vec, &sai_attr);

    if (nexthopgroup_api->set_next_hop_group_attribute == (void *)0) {
        std::cerr << "NULL ptr: nexthopgroup_api->set_next_hop_group_attribute" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = nexthopgroup_api->set_next_hop_group_attribute((sai_object_id_t)next_hop_group_oid, &sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_get_next_hop_group_attribute(sai_thrift_attribute_list_t& attr_list_out, const sai_thrift_object_id_t next_hop_group_oid, const sai_thrift_attribute_list_t& attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_nexthopgroup_api_t *nexthopgroup_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_NEXTHOPGROUP), (void **)&nexthopgroup_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    else {
      return;
    }


    const std::vector<sai_thrift_attribute_t> &attr_list_vec = attr_list.attr_list;

    sai_thrift_parse_next_hop_group_attributes(attr_list_vec, sai_attr_list);

    if (nexthopgroup_api->get_next_hop_group_attribute == (void *)0) {
        std::cerr << "NULL ptr: nexthopgroup_api->get_next_hop_group_attribute" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = nexthopgroup_api->get_next_hop_group_attribute((sai_object_id_t)next_hop_group_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_next_hop_group_attributes(sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  sai_thrift_object_id_t sai_thrift_create_next_hop_group_member(const std::vector<sai_thrift_attribute_t> & attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t next_hop_group_member_oid_out = SAI_NULL_OBJECT_ID;

    sai_nexthopgroup_api_t *nexthopgroup_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_NEXTHOPGROUP), (void **)&nexthopgroup_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_next_hop_group_member_attributes(attr_list, sai_attr_list);

    if (nexthopgroup_api->create_next_hop_group_member == (void *)0) {
        std::cerr << "NULL ptr: nexthopgroup_api->create_next_hop_group_member" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = nexthopgroup_api->create_next_hop_group_member(&next_hop_group_member_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);    return next_hop_group_member_oid_out;
  }

  void sai_thrift_remove_next_hop_group_member(const sai_thrift_object_id_t next_hop_group_member_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_nexthopgroup_api_t *nexthopgroup_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_NEXTHOPGROUP), (void **)&nexthopgroup_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    if (nexthopgroup_api->remove_next_hop_group_member == (void *)0) {
        std::cerr << "NULL ptr: nexthopgroup_api->remove_next_hop_group_member" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = nexthopgroup_api->remove_next_hop_group_member((sai_object_id_t)next_hop_group_member_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_next_hop_group_member_attribute(const sai_thrift_object_id_t next_hop_group_member_oid, const sai_thrift_attribute_t& attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t sai_attr;

    sai_nexthopgroup_api_t *nexthopgroup_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_NEXTHOPGROUP), (void **)&nexthopgroup_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);

    sai_thrift_parse_next_hop_group_member_attributes(attr_vec, &sai_attr);

    if (nexthopgroup_api->set_next_hop_group_member_attribute == (void *)0) {
        std::cerr << "NULL ptr: nexthopgroup_api->set_next_hop_group_member_attribute" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = nexthopgroup_api->set_next_hop_group_member_attribute((sai_object_id_t)next_hop_group_member_oid, &sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_get_next_hop_group_member_attribute(sai_thrift_attribute_list_t& attr_list_out, const sai_thrift_object_id_t next_hop_group_member_oid, const sai_thrift_attribute_list_t& attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_nexthopgroup_api_t *nexthopgroup_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_NEXTHOPGROUP), (void **)&nexthopgroup_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    else {
      return;
    }


    const std::vector<sai_thrift_attribute_t> &attr_list_vec = attr_list.attr_list;

    sai_thrift_parse_next_hop_group_member_attributes(attr_list_vec, sai_attr_list);

    if (nexthopgroup_api->get_next_hop_group_member_attribute == (void *)0) {
        std::cerr << "NULL ptr: nexthopgroup_api->get_next_hop_group_member_attribute" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = nexthopgroup_api->get_next_hop_group_member_attribute((sai_object_id_t)next_hop_group_member_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_next_hop_group_member_attributes(sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  sai_thrift_object_id_t sai_thrift_create_next_hop_group_map(const std::vector<sai_thrift_attribute_t> & attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t next_hop_group_map_oid_out = SAI_NULL_OBJECT_ID;

    sai_nexthopgroup_api_t *nexthopgroup_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_NEXTHOPGROUP), (void **)&nexthopgroup_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_next_hop_group_map_attributes(attr_list, sai_attr_list);

    if (nexthopgroup_api->create_next_hop_group_map == (void *)0) {
        std::cerr << "NULL ptr: nexthopgroup_api->create_next_hop_group_map" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = nexthopgroup_api->create_next_hop_group_map(&next_hop_group_map_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);    return next_hop_group_map_oid_out;
  }

  void sai_thrift_remove_next_hop_group_map(const sai_thrift_object_id_t next_hop_group_map_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_nexthopgroup_api_t *nexthopgroup_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_NEXTHOPGROUP), (void **)&nexthopgroup_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    if (nexthopgroup_api->remove_next_hop_group_map == (void *)0) {
        std::cerr << "NULL ptr: nexthopgroup_api->remove_next_hop_group_map" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = nexthopgroup_api->remove_next_hop_group_map((sai_object_id_t)next_hop_group_map_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_next_hop_group_map_attribute(const sai_thrift_object_id_t next_hop_group_map_oid, const sai_thrift_attribute_t& attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t sai_attr;

    sai_nexthopgroup_api_t *nexthopgroup_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_NEXTHOPGROUP), (void **)&nexthopgroup_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);

    sai_thrift_parse_next_hop_group_map_attributes(attr_vec, &sai_attr);

    if (nexthopgroup_api->set_next_hop_group_map_attribute == (void *)0) {
        std::cerr << "NULL ptr: nexthopgroup_api->set_next_hop_group_map_attribute" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = nexthopgroup_api->set_next_hop_group_map_attribute((sai_object_id_t)next_hop_group_map_oid, &sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_get_next_hop_group_map_attribute(sai_thrift_attribute_list_t& attr_list_out, const sai_thrift_object_id_t next_hop_group_map_oid, const sai_thrift_attribute_list_t& attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_nexthopgroup_api_t *nexthopgroup_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_NEXTHOPGROUP), (void **)&nexthopgroup_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    else {
      return;
    }


    const std::vector<sai_thrift_attribute_t> &attr_list_vec = attr_list.attr_list;

    sai_thrift_parse_next_hop_group_map_attributes(attr_list_vec, sai_attr_list);

    if (nexthopgroup_api->get_next_hop_group_map_attribute == (void *)0) {
        std::cerr << "NULL ptr: nexthopgroup_api->get_next_hop_group_map_attribute" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = nexthopgroup_api->get_next_hop_group_map_attribute((sai_object_id_t)next_hop_group_map_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_next_hop_group_map_attributes(sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  sai_thrift_object_id_t sai_thrift_create_policer(const std::vector<sai_thrift_attribute_t> & attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t policer_oid_out = SAI_NULL_OBJECT_ID;

    sai_policer_api_t *policer_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_POLICER), (void **)&policer_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_policer_attributes(attr_list, sai_attr_list);

    if (policer_api->create_policer == (void *)0) {
        std::cerr << "NULL ptr: policer_api->create_policer" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = policer_api->create_policer(&policer_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);    return policer_oid_out;
  }

  void sai_thrift_remove_policer(const sai_thrift_object_id_t policer_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_policer_api_t *policer_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_POLICER), (void **)&policer_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    if (policer_api->remove_policer == (void *)0) {
        std::cerr << "NULL ptr: policer_api->remove_policer" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = policer_api->remove_policer((sai_object_id_t)policer_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_policer_attribute(const sai_thrift_object_id_t policer_oid, const sai_thrift_attribute_t& attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t sai_attr;

    sai_policer_api_t *policer_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_POLICER), (void **)&policer_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);

    sai_thrift_parse_policer_attributes(attr_vec, &sai_attr);

    if (policer_api->set_policer_attribute == (void *)0) {
        std::cerr << "NULL ptr: policer_api->set_policer_attribute" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = policer_api->set_policer_attribute((sai_object_id_t)policer_oid, &sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_get_policer_attribute(sai_thrift_attribute_list_t& attr_list_out, const sai_thrift_object_id_t policer_oid, const sai_thrift_attribute_list_t& attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_policer_api_t *policer_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_POLICER), (void **)&policer_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    else {
      return;
    }


    const std::vector<sai_thrift_attribute_t> &attr_list_vec = attr_list.attr_list;

    sai_thrift_parse_policer_attributes(attr_list_vec, sai_attr_list);

    if (policer_api->get_policer_attribute == (void *)0) {
        std::cerr << "NULL ptr: policer_api->get_policer_attribute" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = policer_api->get_policer_attribute((sai_object_id_t)policer_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_policer_attributes(sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  void sai_thrift_get_policer_stats(std::vector<sai_thrift_uint64_t> & counters_out, const sai_thrift_object_id_t policer_oid, const std::vector<sai_thrift_stat_id_t> & counter_ids) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_policer_api_t *policer_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_POLICER), (void **)&policer_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_stat_id_t *sai_counter_ids = NULL;
    uint32_t number_of_counters = counter_ids.size();

    if (number_of_counters != 0) {
      sai_counter_ids = (sai_stat_id_t *)malloc(sizeof(sai_stat_id_t) * number_of_counters);
    }
    else {
      return;
    }


    std::vector<sai_thrift_stat_id_t>::const_iterator it = counter_ids.begin();
    for (uint32_t i = 0; i < counter_ids.size(); i++, it++) {
      sai_counter_ids[i] = (sai_stat_id_t)*it;
    }

    uint64_t *sai_counters = NULL;
    if (number_of_counters != 0) {
      sai_counters = (uint64_t *)malloc(sizeof(uint64_t) * number_of_counters);
    }

    if (policer_api->get_policer_stats == (void *)0) {
        std::cerr << "NULL ptr: policer_api->get_policer_stats" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = policer_api->get_policer_stats((sai_object_id_t)policer_oid, number_of_counters, sai_counter_ids, sai_counters);

    // sai_adapter always takes all policer stats. Since some of them may be
    // not supported, SAI_STATUS_INVALID_PARAMETER should not be raised.
    if (status != SAI_STATUS_SUCCESS && status != SAI_STATUS_INVALID_PARAMETER) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_counter_ids);
    for (uint32_t i = 0; i < (uint32_t)number_of_counters; i++) {
      counters_out.push_back((sai_thrift_uint64_t)sai_counters[i]);
    }
    free(sai_counters);
    return;
  }

  void sai_thrift_get_policer_stats_ext(std::vector<sai_thrift_uint64_t> & counters_out, const sai_thrift_object_id_t policer_oid, const std::vector<sai_thrift_stat_id_t> & counter_ids, const sai_thrift_stats_mode_t mode) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_policer_api_t *policer_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_POLICER), (void **)&policer_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_stat_id_t *sai_counter_ids = NULL;
    uint32_t number_of_counters = counter_ids.size();

    if (number_of_counters != 0) {
      sai_counter_ids = (sai_stat_id_t *)malloc(sizeof(sai_stat_id_t) * number_of_counters);
    }
    else {
      return;
    }


    std::vector<sai_thrift_stat_id_t>::const_iterator it = counter_ids.begin();
    for (uint32_t i = 0; i < counter_ids.size(); i++, it++) {
      sai_counter_ids[i] = (sai_stat_id_t)*it;
    }

    uint64_t *sai_counters = NULL;
    if (number_of_counters != 0) {
      sai_counters = (uint64_t *)malloc(sizeof(uint64_t) * number_of_counters);
    }

    if (policer_api->get_policer_stats_ext == (void *)0) {
        std::cerr << "NULL ptr: policer_api->get_policer_stats_ext" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = policer_api->get_policer_stats_ext((sai_object_id_t)policer_oid, number_of_counters, sai_counter_ids, (sai_stats_mode_t)mode, sai_counters);

    // sai_adapter always takes all policer stats. Since some of them may be
    // not supported, SAI_STATUS_INVALID_PARAMETER should not be raised.
    if (status != SAI_STATUS_SUCCESS && status != SAI_STATUS_INVALID_PARAMETER) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_counter_ids);
    for (uint32_t i = 0; i < (uint32_t)number_of_counters; i++) {
      counters_out.push_back((sai_thrift_uint64_t)sai_counters[i]);
    }
    free(sai_counters);
    return;
  }

  void sai_thrift_clear_policer_stats(const sai_thrift_object_id_t policer_oid, const std::vector<sai_thrift_stat_id_t> & counter_ids) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_policer_api_t *policer_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_POLICER), (void **)&policer_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_stat_id_t *sai_counter_ids = NULL;
    uint32_t number_of_counters = counter_ids.size();

    if (number_of_counters != 0) {
      sai_counter_ids = (sai_stat_id_t *)malloc(sizeof(sai_stat_id_t) * number_of_counters);
    }
    else {
      return;
    }


    std::vector<sai_thrift_stat_id_t>::const_iterator it = counter_ids.begin();
    for (uint32_t i = 0; i < counter_ids.size(); i++, it++) {
      sai_counter_ids[i] = (sai_stat_id_t)*it;
    }

    if (policer_api->clear_policer_stats == (void *)0) {
        std::cerr << "NULL ptr: policer_api->clear_policer_stats" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = policer_api->clear_policer_stats((sai_object_id_t)policer_oid, number_of_counters, sai_counter_ids);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_counter_ids);
    return;
  }

  sai_thrift_object_id_t sai_thrift_create_port(const std::vector<sai_thrift_attribute_t> & attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t port_oid_out = SAI_NULL_OBJECT_ID;

    sai_port_api_t *port_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_PORT), (void **)&port_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_port_attributes(attr_list, sai_attr_list);

    if (port_api->create_port == (void *)0) {
        std::cerr << "NULL ptr: port_api->create_port" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = port_api->create_port(&port_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);    return port_oid_out;
  }

  void sai_thrift_remove_port(const sai_thrift_object_id_t port_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_port_api_t *port_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_PORT), (void **)&port_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    if (port_api->remove_port == (void *)0) {
        std::cerr << "NULL ptr: port_api->remove_port" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = port_api->remove_port((sai_object_id_t)port_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_port_attribute(const sai_thrift_object_id_t port_oid, const sai_thrift_attribute_t& attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t sai_attr;

    sai_port_api_t *port_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_PORT), (void **)&port_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);

    sai_thrift_parse_port_attributes(attr_vec, &sai_attr);

    if (port_api->set_port_attribute == (void *)0) {
        std::cerr << "NULL ptr: port_api->set_port_attribute" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = port_api->set_port_attribute((sai_object_id_t)port_oid, &sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_get_port_attribute(sai_thrift_attribute_list_t& attr_list_out, const sai_thrift_object_id_t port_oid, const sai_thrift_attribute_list_t& attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_port_api_t *port_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_PORT), (void **)&port_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    else {
      return;
    }


    const std::vector<sai_thrift_attribute_t> &attr_list_vec = attr_list.attr_list;

    sai_thrift_parse_port_attributes(attr_list_vec, sai_attr_list);

    if (port_api->get_port_attribute == (void *)0) {
        std::cerr << "NULL ptr: port_api->get_port_attribute" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = port_api->get_port_attribute((sai_object_id_t)port_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_port_attributes(sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  void sai_thrift_get_port_stats(std::vector<sai_thrift_uint64_t> & counters_out, const sai_thrift_object_id_t port_oid, const std::vector<sai_thrift_stat_id_t> & counter_ids) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_port_api_t *port_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_PORT), (void **)&port_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_stat_id_t *sai_counter_ids = NULL;
    uint32_t number_of_counters = counter_ids.size();

    if (number_of_counters != 0) {
      sai_counter_ids = (sai_stat_id_t *)malloc(sizeof(sai_stat_id_t) * number_of_counters);
    }
    else {
      return;
    }


    std::vector<sai_thrift_stat_id_t>::const_iterator it = counter_ids.begin();
    for (uint32_t i = 0; i < counter_ids.size(); i++, it++) {
      sai_counter_ids[i] = (sai_stat_id_t)*it;
    }

    uint64_t *sai_counters = NULL;
    if (number_of_counters != 0) {
      sai_counters = (uint64_t *)malloc(sizeof(uint64_t) * number_of_counters);
    }

    if (port_api->get_port_stats == (void *)0) {
        std::cerr << "NULL ptr: port_api->get_port_stats" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = port_api->get_port_stats((sai_object_id_t)port_oid, number_of_counters, sai_counter_ids, sai_counters);

    // sai_adapter always takes all port stats. Since some of them may be
    // not supported, SAI_STATUS_INVALID_PARAMETER should not be raised.
    if (status != SAI_STATUS_SUCCESS && status != SAI_STATUS_INVALID_PARAMETER) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_counter_ids);
    for (uint32_t i = 0; i < (uint32_t)number_of_counters; i++) {
      counters_out.push_back((sai_thrift_uint64_t)sai_counters[i]);
    }
    free(sai_counters);
    return;
  }

  void sai_thrift_get_port_stats_ext(std::vector<sai_thrift_uint64_t> & counters_out, const sai_thrift_object_id_t port_oid, const std::vector<sai_thrift_stat_id_t> & counter_ids, const sai_thrift_stats_mode_t mode) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_port_api_t *port_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_PORT), (void **)&port_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_stat_id_t *sai_counter_ids = NULL;
    uint32_t number_of_counters = counter_ids.size();

    if (number_of_counters != 0) {
      sai_counter_ids = (sai_stat_id_t *)malloc(sizeof(sai_stat_id_t) * number_of_counters);
    }
    else {
      return;
    }


    std::vector<sai_thrift_stat_id_t>::const_iterator it = counter_ids.begin();
    for (uint32_t i = 0; i < counter_ids.size(); i++, it++) {
      sai_counter_ids[i] = (sai_stat_id_t)*it;
    }

    uint64_t *sai_counters = NULL;
    if (number_of_counters != 0) {
      sai_counters = (uint64_t *)malloc(sizeof(uint64_t) * number_of_counters);
    }

    if (port_api->get_port_stats_ext == (void *)0) {
        std::cerr << "NULL ptr: port_api->get_port_stats_ext" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = port_api->get_port_stats_ext((sai_object_id_t)port_oid, number_of_counters, sai_counter_ids, (sai_stats_mode_t)mode, sai_counters);

    // sai_adapter always takes all port stats. Since some of them may be
    // not supported, SAI_STATUS_INVALID_PARAMETER should not be raised.
    if (status != SAI_STATUS_SUCCESS && status != SAI_STATUS_INVALID_PARAMETER) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_counter_ids);
    for (uint32_t i = 0; i < (uint32_t)number_of_counters; i++) {
      counters_out.push_back((sai_thrift_uint64_t)sai_counters[i]);
    }
    free(sai_counters);
    return;
  }

  void sai_thrift_clear_port_stats(const sai_thrift_object_id_t port_oid, const std::vector<sai_thrift_stat_id_t> & counter_ids) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_port_api_t *port_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_PORT), (void **)&port_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_stat_id_t *sai_counter_ids = NULL;
    uint32_t number_of_counters = counter_ids.size();

    if (number_of_counters != 0) {
      sai_counter_ids = (sai_stat_id_t *)malloc(sizeof(sai_stat_id_t) * number_of_counters);
    }
    else {
      return;
    }


    std::vector<sai_thrift_stat_id_t>::const_iterator it = counter_ids.begin();
    for (uint32_t i = 0; i < counter_ids.size(); i++, it++) {
      sai_counter_ids[i] = (sai_stat_id_t)*it;
    }

    if (port_api->clear_port_stats == (void *)0) {
        std::cerr << "NULL ptr: port_api->clear_port_stats" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = port_api->clear_port_stats((sai_object_id_t)port_oid, number_of_counters, sai_counter_ids);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_counter_ids);
    return;
  }

  void sai_thrift_clear_port_all_stats(const sai_thrift_object_id_t port_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_port_api_t *port_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_PORT), (void **)&port_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    if (port_api->clear_port_all_stats == (void *)0) {
        std::cerr << "NULL ptr: port_api->clear_port_all_stats" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = port_api->clear_port_all_stats((sai_object_id_t)port_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  sai_thrift_object_id_t sai_thrift_create_port_pool(const std::vector<sai_thrift_attribute_t> & attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t port_pool_oid_out = SAI_NULL_OBJECT_ID;

    sai_port_api_t *port_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_PORT), (void **)&port_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_port_pool_attributes(attr_list, sai_attr_list);

    if (port_api->create_port_pool == (void *)0) {
        std::cerr << "NULL ptr: port_api->create_port_pool" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = port_api->create_port_pool(&port_pool_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);    return port_pool_oid_out;
  }

  void sai_thrift_remove_port_pool(const sai_thrift_object_id_t port_pool_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_port_api_t *port_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_PORT), (void **)&port_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    if (port_api->remove_port_pool == (void *)0) {
        std::cerr << "NULL ptr: port_api->remove_port_pool" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = port_api->remove_port_pool((sai_object_id_t)port_pool_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_port_pool_attribute(const sai_thrift_object_id_t port_pool_oid, const sai_thrift_attribute_t& attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t sai_attr;

    sai_port_api_t *port_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_PORT), (void **)&port_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);

    sai_thrift_parse_port_pool_attributes(attr_vec, &sai_attr);

    if (port_api->set_port_pool_attribute == (void *)0) {
        std::cerr << "NULL ptr: port_api->set_port_pool_attribute" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = port_api->set_port_pool_attribute((sai_object_id_t)port_pool_oid, &sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_get_port_pool_attribute(sai_thrift_attribute_list_t& attr_list_out, const sai_thrift_object_id_t port_pool_oid, const sai_thrift_attribute_list_t& attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_port_api_t *port_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_PORT), (void **)&port_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    else {
      return;
    }


    const std::vector<sai_thrift_attribute_t> &attr_list_vec = attr_list.attr_list;

    sai_thrift_parse_port_pool_attributes(attr_list_vec, sai_attr_list);

    if (port_api->get_port_pool_attribute == (void *)0) {
        std::cerr << "NULL ptr: port_api->get_port_pool_attribute" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = port_api->get_port_pool_attribute((sai_object_id_t)port_pool_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_port_pool_attributes(sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  void sai_thrift_get_port_pool_stats(std::vector<sai_thrift_uint64_t> & counters_out, const sai_thrift_object_id_t port_pool_oid, const std::vector<sai_thrift_stat_id_t> & counter_ids) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_port_api_t *port_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_PORT), (void **)&port_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_stat_id_t *sai_counter_ids = NULL;
    uint32_t number_of_counters = counter_ids.size();

    if (number_of_counters != 0) {
      sai_counter_ids = (sai_stat_id_t *)malloc(sizeof(sai_stat_id_t) * number_of_counters);
    }
    else {
      return;
    }


    std::vector<sai_thrift_stat_id_t>::const_iterator it = counter_ids.begin();
    for (uint32_t i = 0; i < counter_ids.size(); i++, it++) {
      sai_counter_ids[i] = (sai_stat_id_t)*it;
    }

    uint64_t *sai_counters = NULL;
    if (number_of_counters != 0) {
      sai_counters = (uint64_t *)malloc(sizeof(uint64_t) * number_of_counters);
    }

    if (port_api->get_port_pool_stats == (void *)0) {
        std::cerr << "NULL ptr: port_api->get_port_pool_stats" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = port_api->get_port_pool_stats((sai_object_id_t)port_pool_oid, number_of_counters, sai_counter_ids, sai_counters);

    // sai_adapter always takes all port stats. Since some of them may be
    // not supported, SAI_STATUS_INVALID_PARAMETER should not be raised.
    if (status != SAI_STATUS_SUCCESS && status != SAI_STATUS_INVALID_PARAMETER) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_counter_ids);
    for (uint32_t i = 0; i < (uint32_t)number_of_counters; i++) {
      counters_out.push_back((sai_thrift_uint64_t)sai_counters[i]);
    }
    free(sai_counters);
    return;
  }

  void sai_thrift_get_port_pool_stats_ext(std::vector<sai_thrift_uint64_t> & counters_out, const sai_thrift_object_id_t port_pool_oid, const std::vector<sai_thrift_stat_id_t> & counter_ids, const sai_thrift_stats_mode_t mode) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_port_api_t *port_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_PORT), (void **)&port_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_stat_id_t *sai_counter_ids = NULL;
    uint32_t number_of_counters = counter_ids.size();

    if (number_of_counters != 0) {
      sai_counter_ids = (sai_stat_id_t *)malloc(sizeof(sai_stat_id_t) * number_of_counters);
    }
    else {
      return;
    }


    std::vector<sai_thrift_stat_id_t>::const_iterator it = counter_ids.begin();
    for (uint32_t i = 0; i < counter_ids.size(); i++, it++) {
      sai_counter_ids[i] = (sai_stat_id_t)*it;
    }

    uint64_t *sai_counters = NULL;
    if (number_of_counters != 0) {
      sai_counters = (uint64_t *)malloc(sizeof(uint64_t) * number_of_counters);
    }

    if (port_api->get_port_pool_stats_ext == (void *)0) {
        std::cerr << "NULL ptr: port_api->get_port_pool_stats_ext" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = port_api->get_port_pool_stats_ext((sai_object_id_t)port_pool_oid, number_of_counters, sai_counter_ids, (sai_stats_mode_t)mode, sai_counters);

    // sai_adapter always takes all port stats. Since some of them may be
    // not supported, SAI_STATUS_INVALID_PARAMETER should not be raised.
    if (status != SAI_STATUS_SUCCESS && status != SAI_STATUS_INVALID_PARAMETER) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_counter_ids);
    for (uint32_t i = 0; i < (uint32_t)number_of_counters; i++) {
      counters_out.push_back((sai_thrift_uint64_t)sai_counters[i]);
    }
    free(sai_counters);
    return;
  }

  void sai_thrift_clear_port_pool_stats(const sai_thrift_object_id_t port_pool_oid, const std::vector<sai_thrift_stat_id_t> & counter_ids) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_port_api_t *port_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_PORT), (void **)&port_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_stat_id_t *sai_counter_ids = NULL;
    uint32_t number_of_counters = counter_ids.size();

    if (number_of_counters != 0) {
      sai_counter_ids = (sai_stat_id_t *)malloc(sizeof(sai_stat_id_t) * number_of_counters);
    }
    else {
      return;
    }


    std::vector<sai_thrift_stat_id_t>::const_iterator it = counter_ids.begin();
    for (uint32_t i = 0; i < counter_ids.size(); i++, it++) {
      sai_counter_ids[i] = (sai_stat_id_t)*it;
    }

    if (port_api->clear_port_pool_stats == (void *)0) {
        std::cerr << "NULL ptr: port_api->clear_port_pool_stats" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = port_api->clear_port_pool_stats((sai_object_id_t)port_pool_oid, number_of_counters, sai_counter_ids);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_counter_ids);
    return;
  }

  sai_thrift_object_id_t sai_thrift_create_port_serdes(const std::vector<sai_thrift_attribute_t> & attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t port_serdes_oid_out = SAI_NULL_OBJECT_ID;

    sai_port_api_t *port_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_PORT), (void **)&port_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_port_serdes_attributes(attr_list, sai_attr_list);

    if (port_api->create_port_serdes == (void *)0) {
        std::cerr << "NULL ptr: port_api->create_port_serdes" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = port_api->create_port_serdes(&port_serdes_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);    return port_serdes_oid_out;
  }

  void sai_thrift_remove_port_serdes(const sai_thrift_object_id_t port_serdes_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_port_api_t *port_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_PORT), (void **)&port_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    if (port_api->remove_port_serdes == (void *)0) {
        std::cerr << "NULL ptr: port_api->remove_port_serdes" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = port_api->remove_port_serdes((sai_object_id_t)port_serdes_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_port_serdes_attribute(const sai_thrift_object_id_t port_serdes_oid, const sai_thrift_attribute_t& attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t sai_attr;

    sai_port_api_t *port_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_PORT), (void **)&port_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);

    sai_thrift_parse_port_serdes_attributes(attr_vec, &sai_attr);

    if (port_api->set_port_serdes_attribute == (void *)0) {
        std::cerr << "NULL ptr: port_api->set_port_serdes_attribute" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = port_api->set_port_serdes_attribute((sai_object_id_t)port_serdes_oid, &sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_get_port_serdes_attribute(sai_thrift_attribute_list_t& attr_list_out, const sai_thrift_object_id_t port_serdes_oid, const sai_thrift_attribute_list_t& attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_port_api_t *port_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_PORT), (void **)&port_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    else {
      return;
    }


    const std::vector<sai_thrift_attribute_t> &attr_list_vec = attr_list.attr_list;

    sai_thrift_parse_port_serdes_attributes(attr_list_vec, sai_attr_list);

    if (port_api->get_port_serdes_attribute == (void *)0) {
        std::cerr << "NULL ptr: port_api->get_port_serdes_attribute" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = port_api->get_port_serdes_attribute((sai_object_id_t)port_serdes_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_port_serdes_attributes(sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  sai_thrift_object_id_t sai_thrift_create_port_connector(const std::vector<sai_thrift_attribute_t> & attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t port_connector_oid_out = SAI_NULL_OBJECT_ID;

    sai_port_api_t *port_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_PORT), (void **)&port_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_port_connector_attributes(attr_list, sai_attr_list);

    if (port_api->create_port_connector == (void *)0) {
        std::cerr << "NULL ptr: port_api->create_port_connector" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = port_api->create_port_connector(&port_connector_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);    return port_connector_oid_out;
  }

  void sai_thrift_remove_port_connector(const sai_thrift_object_id_t port_connector_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_port_api_t *port_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_PORT), (void **)&port_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    if (port_api->remove_port_connector == (void *)0) {
        std::cerr << "NULL ptr: port_api->remove_port_connector" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = port_api->remove_port_connector((sai_object_id_t)port_connector_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_port_connector_attribute(const sai_thrift_object_id_t port_connector_oid, const sai_thrift_attribute_t& attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t sai_attr;

    sai_port_api_t *port_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_PORT), (void **)&port_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);

    sai_thrift_parse_port_connector_attributes(attr_vec, &sai_attr);

    if (port_api->set_port_connector_attribute == (void *)0) {
        std::cerr << "NULL ptr: port_api->set_port_connector_attribute" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = port_api->set_port_connector_attribute((sai_object_id_t)port_connector_oid, &sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_get_port_connector_attribute(sai_thrift_attribute_list_t& attr_list_out, const sai_thrift_object_id_t port_connector_oid, const sai_thrift_attribute_list_t& attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_port_api_t *port_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_PORT), (void **)&port_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    else {
      return;
    }


    const std::vector<sai_thrift_attribute_t> &attr_list_vec = attr_list.attr_list;

    sai_thrift_parse_port_connector_attributes(attr_list_vec, sai_attr_list);

    if (port_api->get_port_connector_attribute == (void *)0) {
        std::cerr << "NULL ptr: port_api->get_port_connector_attribute" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = port_api->get_port_connector_attribute((sai_object_id_t)port_connector_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_port_connector_attributes(sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  sai_thrift_object_id_t sai_thrift_create_qos_map(const std::vector<sai_thrift_attribute_t> & attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t qos_map_oid_out = SAI_NULL_OBJECT_ID;

    sai_qosmap_api_t *qosmap_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_QOSMAP), (void **)&qosmap_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_qos_map_attributes(attr_list, sai_attr_list);

    if (qosmap_api->create_qos_map == (void *)0) {
        std::cerr << "NULL ptr: qosmap_api->create_qos_map" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = qosmap_api->create_qos_map(&qos_map_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);    return qos_map_oid_out;
  }

  void sai_thrift_remove_qos_map(const sai_thrift_object_id_t qos_map_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_qosmap_api_t *qosmap_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_QOSMAP), (void **)&qosmap_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    if (qosmap_api->remove_qos_map == (void *)0) {
        std::cerr << "NULL ptr: qosmap_api->remove_qos_map" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = qosmap_api->remove_qos_map((sai_object_id_t)qos_map_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_qos_map_attribute(const sai_thrift_object_id_t qos_map_oid, const sai_thrift_attribute_t& attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t sai_attr;

    sai_qosmap_api_t *qosmap_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_QOSMAP), (void **)&qosmap_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);

    sai_thrift_parse_qos_map_attributes(attr_vec, &sai_attr);

    if (qosmap_api->set_qos_map_attribute == (void *)0) {
        std::cerr << "NULL ptr: qosmap_api->set_qos_map_attribute" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = qosmap_api->set_qos_map_attribute((sai_object_id_t)qos_map_oid, &sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_get_qos_map_attribute(sai_thrift_attribute_list_t& attr_list_out, const sai_thrift_object_id_t qos_map_oid, const sai_thrift_attribute_list_t& attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_qosmap_api_t *qosmap_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_QOSMAP), (void **)&qosmap_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    else {
      return;
    }


    const std::vector<sai_thrift_attribute_t> &attr_list_vec = attr_list.attr_list;

    sai_thrift_parse_qos_map_attributes(attr_list_vec, sai_attr_list);

    if (qosmap_api->get_qos_map_attribute == (void *)0) {
        std::cerr << "NULL ptr: qosmap_api->get_qos_map_attribute" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = qosmap_api->get_qos_map_attribute((sai_object_id_t)qos_map_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_qos_map_attributes(sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  sai_thrift_object_id_t sai_thrift_create_queue(const std::vector<sai_thrift_attribute_t> & attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t queue_oid_out = SAI_NULL_OBJECT_ID;

    sai_queue_api_t *queue_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_QUEUE), (void **)&queue_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_queue_attributes(attr_list, sai_attr_list);

    if (queue_api->create_queue == (void *)0) {
        std::cerr << "NULL ptr: queue_api->create_queue" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = queue_api->create_queue(&queue_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);    return queue_oid_out;
  }

  void sai_thrift_remove_queue(const sai_thrift_object_id_t queue_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_queue_api_t *queue_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_QUEUE), (void **)&queue_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    if (queue_api->remove_queue == (void *)0) {
        std::cerr << "NULL ptr: queue_api->remove_queue" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = queue_api->remove_queue((sai_object_id_t)queue_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_queue_attribute(const sai_thrift_object_id_t queue_oid, const sai_thrift_attribute_t& attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t sai_attr;

    sai_queue_api_t *queue_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_QUEUE), (void **)&queue_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);

    sai_thrift_parse_queue_attributes(attr_vec, &sai_attr);

    if (queue_api->set_queue_attribute == (void *)0) {
        std::cerr << "NULL ptr: queue_api->set_queue_attribute" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = queue_api->set_queue_attribute((sai_object_id_t)queue_oid, &sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_get_queue_attribute(sai_thrift_attribute_list_t& attr_list_out, const sai_thrift_object_id_t queue_oid, const sai_thrift_attribute_list_t& attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_queue_api_t *queue_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_QUEUE), (void **)&queue_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    else {
      return;
    }


    const std::vector<sai_thrift_attribute_t> &attr_list_vec = attr_list.attr_list;

    sai_thrift_parse_queue_attributes(attr_list_vec, sai_attr_list);

    if (queue_api->get_queue_attribute == (void *)0) {
        std::cerr << "NULL ptr: queue_api->get_queue_attribute" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = queue_api->get_queue_attribute((sai_object_id_t)queue_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_queue_attributes(sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  void sai_thrift_get_queue_stats(std::vector<sai_thrift_uint64_t> & counters_out, const sai_thrift_object_id_t queue_oid, const std::vector<sai_thrift_stat_id_t> & counter_ids) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_queue_api_t *queue_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_QUEUE), (void **)&queue_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_stat_id_t *sai_counter_ids = NULL;
    uint32_t number_of_counters = counter_ids.size();

    if (number_of_counters != 0) {
      sai_counter_ids = (sai_stat_id_t *)malloc(sizeof(sai_stat_id_t) * number_of_counters);
    }
    else {
      return;
    }


    std::vector<sai_thrift_stat_id_t>::const_iterator it = counter_ids.begin();
    for (uint32_t i = 0; i < counter_ids.size(); i++, it++) {
      sai_counter_ids[i] = (sai_stat_id_t)*it;
    }

    uint64_t *sai_counters = NULL;
    if (number_of_counters != 0) {
      sai_counters = (uint64_t *)malloc(sizeof(uint64_t) * number_of_counters);
    }

    if (queue_api->get_queue_stats == (void *)0) {
        std::cerr << "NULL ptr: queue_api->get_queue_stats" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = queue_api->get_queue_stats((sai_object_id_t)queue_oid, number_of_counters, sai_counter_ids, sai_counters);

    // sai_adapter always takes all queue stats. Since some of them may be
    // not supported, SAI_STATUS_INVALID_PARAMETER should not be raised.
    if (status != SAI_STATUS_SUCCESS && status != SAI_STATUS_INVALID_PARAMETER) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_counter_ids);
    for (uint32_t i = 0; i < (uint32_t)number_of_counters; i++) {
      counters_out.push_back((sai_thrift_uint64_t)sai_counters[i]);
    }
    free(sai_counters);
    return;
  }

  void sai_thrift_get_queue_stats_ext(std::vector<sai_thrift_uint64_t> & counters_out, const sai_thrift_object_id_t queue_oid, const std::vector<sai_thrift_stat_id_t> & counter_ids, const sai_thrift_stats_mode_t mode) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_queue_api_t *queue_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_QUEUE), (void **)&queue_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_stat_id_t *sai_counter_ids = NULL;
    uint32_t number_of_counters = counter_ids.size();

    if (number_of_counters != 0) {
      sai_counter_ids = (sai_stat_id_t *)malloc(sizeof(sai_stat_id_t) * number_of_counters);
    }
    else {
      return;
    }


    std::vector<sai_thrift_stat_id_t>::const_iterator it = counter_ids.begin();
    for (uint32_t i = 0; i < counter_ids.size(); i++, it++) {
      sai_counter_ids[i] = (sai_stat_id_t)*it;
    }

    uint64_t *sai_counters = NULL;
    if (number_of_counters != 0) {
      sai_counters = (uint64_t *)malloc(sizeof(uint64_t) * number_of_counters);
    }

    if (queue_api->get_queue_stats_ext == (void *)0) {
        std::cerr << "NULL ptr: queue_api->get_queue_stats_ext" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = queue_api->get_queue_stats_ext((sai_object_id_t)queue_oid, number_of_counters, sai_counter_ids, (sai_stats_mode_t)mode, sai_counters);

    // sai_adapter always takes all queue stats. Since some of them may be
    // not supported, SAI_STATUS_INVALID_PARAMETER should not be raised.
    if (status != SAI_STATUS_SUCCESS && status != SAI_STATUS_INVALID_PARAMETER) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_counter_ids);
    for (uint32_t i = 0; i < (uint32_t)number_of_counters; i++) {
      counters_out.push_back((sai_thrift_uint64_t)sai_counters[i]);
    }
    free(sai_counters);
    return;
  }

  void sai_thrift_clear_queue_stats(const sai_thrift_object_id_t queue_oid, const std::vector<sai_thrift_stat_id_t> & counter_ids) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_queue_api_t *queue_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_QUEUE), (void **)&queue_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_stat_id_t *sai_counter_ids = NULL;
    uint32_t number_of_counters = counter_ids.size();

    if (number_of_counters != 0) {
      sai_counter_ids = (sai_stat_id_t *)malloc(sizeof(sai_stat_id_t) * number_of_counters);
    }
    else {
      return;
    }


    std::vector<sai_thrift_stat_id_t>::const_iterator it = counter_ids.begin();
    for (uint32_t i = 0; i < counter_ids.size(); i++, it++) {
      sai_counter_ids[i] = (sai_stat_id_t)*it;
    }

    if (queue_api->clear_queue_stats == (void *)0) {
        std::cerr << "NULL ptr: queue_api->clear_queue_stats" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = queue_api->clear_queue_stats((sai_object_id_t)queue_oid, number_of_counters, sai_counter_ids);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_counter_ids);
    return;
  }

  void sai_thrift_create_route_entry(const sai_thrift_route_entry_t& route_entry, const std::vector<sai_thrift_attribute_t> & attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_route_entry_t sai_route_entry;

    sai_route_api_t *route_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_ROUTE), (void **)&route_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_parse_route_entry(route_entry, &sai_route_entry);

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_route_entry_attributes(attr_list, sai_attr_list);

    if (route_api->create_route_entry == (void *)0) {
        std::cerr << "NULL ptr: route_api->create_route_entry" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = route_api->create_route_entry(&sai_route_entry, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);
    return;
  }

  void sai_thrift_remove_route_entry(const sai_thrift_route_entry_t& route_entry) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_route_entry_t sai_route_entry;

    sai_route_api_t *route_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_ROUTE), (void **)&route_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_parse_route_entry(route_entry, &sai_route_entry);

    if (route_api->remove_route_entry == (void *)0) {
        std::cerr << "NULL ptr: route_api->remove_route_entry" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = route_api->remove_route_entry(&sai_route_entry);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_route_entry_attribute(const sai_thrift_route_entry_t& route_entry, const sai_thrift_attribute_t& attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_route_entry_t sai_route_entry;
    sai_attribute_t sai_attr;

    sai_route_api_t *route_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_ROUTE), (void **)&route_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_parse_route_entry(route_entry, &sai_route_entry);

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);

    sai_thrift_parse_route_entry_attributes(attr_vec, &sai_attr);

    if (route_api->set_route_entry_attribute == (void *)0) {
        std::cerr << "NULL ptr: route_api->set_route_entry_attribute" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = route_api->set_route_entry_attribute(&sai_route_entry, &sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_get_route_entry_attribute(sai_thrift_attribute_list_t& attr_list_out, const sai_thrift_route_entry_t& route_entry, const sai_thrift_attribute_list_t& attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_route_entry_t sai_route_entry;

    sai_route_api_t *route_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_ROUTE), (void **)&route_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_parse_route_entry(route_entry, &sai_route_entry);

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    else {
      return;
    }


    const std::vector<sai_thrift_attribute_t> &attr_list_vec = attr_list.attr_list;

    sai_thrift_parse_route_entry_attributes(attr_list_vec, sai_attr_list);

    if (route_api->get_route_entry_attribute == (void *)0) {
        std::cerr << "NULL ptr: route_api->get_route_entry_attribute" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = route_api->get_route_entry_attribute(&sai_route_entry, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_route_entry_attributes(sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  void sai_thrift_bulk_create_route_entry(std::vector<sai_thrift_status_t> & object_statuses_out, const std::vector<sai_thrift_route_entry_t> & route_entry, const std::vector<sai_thrift_uint32_t> & attr_count, const std::vector<sai_thrift_attribute_t> & attr_list, const sai_thrift_bulk_op_error_mode_t mode) {

    // This function is UNSUPPORTED
    return;
  }

  void sai_thrift_bulk_remove_route_entry(std::vector<sai_thrift_status_t> & object_statuses_out, const std::vector<sai_thrift_route_entry_t> & route_entry, const sai_thrift_bulk_op_error_mode_t mode) {

    // This function is UNSUPPORTED
    return;
  }

  void sai_thrift_bulk_set_route_entry_attribute(std::vector<sai_thrift_status_t> & object_statuses_out, const std::vector<sai_thrift_route_entry_t> & route_entry, const std::vector<sai_thrift_attribute_t> & attr_list, const sai_thrift_bulk_op_error_mode_t mode) {

    // This function is UNSUPPORTED
    return;
  }

  void sai_thrift_bulk_get_route_entry_attribute(sai_thrift_attribute_list_t& attr_list_out, const std::vector<sai_thrift_route_entry_t> & route_entry, const std::vector<sai_thrift_uint32_t> & attr_count, const sai_thrift_attribute_list_t& attr_list, const sai_thrift_bulk_op_error_mode_t mode, const std::vector<sai_thrift_status_t> & object_statuses) {

    // This function is UNSUPPORTED
    return;
  }

  sai_thrift_object_id_t sai_thrift_create_router_interface(const std::vector<sai_thrift_attribute_t> & attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t router_interface_oid_out = SAI_NULL_OBJECT_ID;

    sai_routerinterface_api_t *routerinterface_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_ROUTERINTERFACE), (void **)&routerinterface_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_router_interface_attributes(attr_list, sai_attr_list);

    if (routerinterface_api->create_router_interface == (void *)0) {
        std::cerr << "NULL ptr: routerinterface_api->create_router_interface" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = routerinterface_api->create_router_interface(&router_interface_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);    return router_interface_oid_out;
  }

  void sai_thrift_remove_router_interface(const sai_thrift_object_id_t router_interface_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_routerinterface_api_t *routerinterface_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_ROUTERINTERFACE), (void **)&routerinterface_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    if (routerinterface_api->remove_router_interface == (void *)0) {
        std::cerr << "NULL ptr: routerinterface_api->remove_router_interface" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = routerinterface_api->remove_router_interface((sai_object_id_t)router_interface_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_router_interface_attribute(const sai_thrift_object_id_t router_interface_oid, const sai_thrift_attribute_t& attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t sai_attr;

    sai_routerinterface_api_t *routerinterface_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_ROUTERINTERFACE), (void **)&routerinterface_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);

    sai_thrift_parse_router_interface_attributes(attr_vec, &sai_attr);

    if (routerinterface_api->set_router_interface_attribute == (void *)0) {
        std::cerr << "NULL ptr: routerinterface_api->set_router_interface_attribute" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = routerinterface_api->set_router_interface_attribute((sai_object_id_t)router_interface_oid, &sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_get_router_interface_attribute(sai_thrift_attribute_list_t& attr_list_out, const sai_thrift_object_id_t router_interface_oid, const sai_thrift_attribute_list_t& attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_routerinterface_api_t *routerinterface_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_ROUTERINTERFACE), (void **)&routerinterface_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    else {
      return;
    }


    const std::vector<sai_thrift_attribute_t> &attr_list_vec = attr_list.attr_list;

    sai_thrift_parse_router_interface_attributes(attr_list_vec, sai_attr_list);

    if (routerinterface_api->get_router_interface_attribute == (void *)0) {
        std::cerr << "NULL ptr: routerinterface_api->get_router_interface_attribute" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = routerinterface_api->get_router_interface_attribute((sai_object_id_t)router_interface_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_router_interface_attributes(sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  void sai_thrift_get_router_interface_stats(std::vector<sai_thrift_uint64_t> & counters_out, const sai_thrift_object_id_t router_interface_oid, const std::vector<sai_thrift_stat_id_t> & counter_ids) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_routerinterface_api_t *routerinterface_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_ROUTERINTERFACE), (void **)&routerinterface_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_stat_id_t *sai_counter_ids = NULL;
    uint32_t number_of_counters = counter_ids.size();

    if (number_of_counters != 0) {
      sai_counter_ids = (sai_stat_id_t *)malloc(sizeof(sai_stat_id_t) * number_of_counters);
    }
    else {
      return;
    }


    std::vector<sai_thrift_stat_id_t>::const_iterator it = counter_ids.begin();
    for (uint32_t i = 0; i < counter_ids.size(); i++, it++) {
      sai_counter_ids[i] = (sai_stat_id_t)*it;
    }

    uint64_t *sai_counters = NULL;
    if (number_of_counters != 0) {
      sai_counters = (uint64_t *)malloc(sizeof(uint64_t) * number_of_counters);
    }

    if (routerinterface_api->get_router_interface_stats == (void *)0) {
        std::cerr << "NULL ptr: routerinterface_api->get_router_interface_stats" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = routerinterface_api->get_router_interface_stats((sai_object_id_t)router_interface_oid, number_of_counters, sai_counter_ids, sai_counters);

    // sai_adapter always takes all routerinterface stats. Since some of them may be
    // not supported, SAI_STATUS_INVALID_PARAMETER should not be raised.
    if (status != SAI_STATUS_SUCCESS && status != SAI_STATUS_INVALID_PARAMETER) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_counter_ids);
    for (uint32_t i = 0; i < (uint32_t)number_of_counters; i++) {
      counters_out.push_back((sai_thrift_uint64_t)sai_counters[i]);
    }
    free(sai_counters);
    return;
  }

  void sai_thrift_get_router_interface_stats_ext(std::vector<sai_thrift_uint64_t> & counters_out, const sai_thrift_object_id_t router_interface_oid, const std::vector<sai_thrift_stat_id_t> & counter_ids, const sai_thrift_stats_mode_t mode) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_routerinterface_api_t *routerinterface_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_ROUTERINTERFACE), (void **)&routerinterface_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_stat_id_t *sai_counter_ids = NULL;
    uint32_t number_of_counters = counter_ids.size();

    if (number_of_counters != 0) {
      sai_counter_ids = (sai_stat_id_t *)malloc(sizeof(sai_stat_id_t) * number_of_counters);
    }
    else {
      return;
    }


    std::vector<sai_thrift_stat_id_t>::const_iterator it = counter_ids.begin();
    for (uint32_t i = 0; i < counter_ids.size(); i++, it++) {
      sai_counter_ids[i] = (sai_stat_id_t)*it;
    }

    uint64_t *sai_counters = NULL;
    if (number_of_counters != 0) {
      sai_counters = (uint64_t *)malloc(sizeof(uint64_t) * number_of_counters);
    }

    if (routerinterface_api->get_router_interface_stats_ext == (void *)0) {
        std::cerr << "NULL ptr: routerinterface_api->get_router_interface_stats_ext" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = routerinterface_api->get_router_interface_stats_ext((sai_object_id_t)router_interface_oid, number_of_counters, sai_counter_ids, (sai_stats_mode_t)mode, sai_counters);

    // sai_adapter always takes all routerinterface stats. Since some of them may be
    // not supported, SAI_STATUS_INVALID_PARAMETER should not be raised.
    if (status != SAI_STATUS_SUCCESS && status != SAI_STATUS_INVALID_PARAMETER) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_counter_ids);
    for (uint32_t i = 0; i < (uint32_t)number_of_counters; i++) {
      counters_out.push_back((sai_thrift_uint64_t)sai_counters[i]);
    }
    free(sai_counters);
    return;
  }

  void sai_thrift_clear_router_interface_stats(const sai_thrift_object_id_t router_interface_oid, const std::vector<sai_thrift_stat_id_t> & counter_ids) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_routerinterface_api_t *routerinterface_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_ROUTERINTERFACE), (void **)&routerinterface_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_stat_id_t *sai_counter_ids = NULL;
    uint32_t number_of_counters = counter_ids.size();

    if (number_of_counters != 0) {
      sai_counter_ids = (sai_stat_id_t *)malloc(sizeof(sai_stat_id_t) * number_of_counters);
    }
    else {
      return;
    }


    std::vector<sai_thrift_stat_id_t>::const_iterator it = counter_ids.begin();
    for (uint32_t i = 0; i < counter_ids.size(); i++, it++) {
      sai_counter_ids[i] = (sai_stat_id_t)*it;
    }

    if (routerinterface_api->clear_router_interface_stats == (void *)0) {
        std::cerr << "NULL ptr: routerinterface_api->clear_router_interface_stats" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = routerinterface_api->clear_router_interface_stats((sai_object_id_t)router_interface_oid, number_of_counters, sai_counter_ids);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_counter_ids);
    return;
  }

  sai_thrift_object_id_t sai_thrift_create_rpf_group(const std::vector<sai_thrift_attribute_t> & attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t rpf_group_oid_out = SAI_NULL_OBJECT_ID;

    sai_rpfgroup_api_t *rpfgroup_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_RPFGROUP), (void **)&rpfgroup_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_rpf_group_attributes(attr_list, sai_attr_list);

    if (rpfgroup_api->create_rpf_group == (void *)0) {
        std::cerr << "NULL ptr: rpfgroup_api->create_rpf_group" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = rpfgroup_api->create_rpf_group(&rpf_group_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);    return rpf_group_oid_out;
  }

  void sai_thrift_remove_rpf_group(const sai_thrift_object_id_t rpf_group_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_rpfgroup_api_t *rpfgroup_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_RPFGROUP), (void **)&rpfgroup_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    if (rpfgroup_api->remove_rpf_group == (void *)0) {
        std::cerr << "NULL ptr: rpfgroup_api->remove_rpf_group" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = rpfgroup_api->remove_rpf_group((sai_object_id_t)rpf_group_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_rpf_group_attribute(const sai_thrift_object_id_t rpf_group_oid, const sai_thrift_attribute_t& attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t sai_attr;

    sai_rpfgroup_api_t *rpfgroup_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_RPFGROUP), (void **)&rpfgroup_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);

    sai_thrift_parse_rpf_group_attributes(attr_vec, &sai_attr);

    if (rpfgroup_api->set_rpf_group_attribute == (void *)0) {
        std::cerr << "NULL ptr: rpfgroup_api->set_rpf_group_attribute" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = rpfgroup_api->set_rpf_group_attribute((sai_object_id_t)rpf_group_oid, &sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_get_rpf_group_attribute(sai_thrift_attribute_list_t& attr_list_out, const sai_thrift_object_id_t rpf_group_oid, const sai_thrift_attribute_list_t& attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_rpfgroup_api_t *rpfgroup_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_RPFGROUP), (void **)&rpfgroup_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    else {
      return;
    }


    const std::vector<sai_thrift_attribute_t> &attr_list_vec = attr_list.attr_list;

    sai_thrift_parse_rpf_group_attributes(attr_list_vec, sai_attr_list);

    if (rpfgroup_api->get_rpf_group_attribute == (void *)0) {
        std::cerr << "NULL ptr: rpfgroup_api->get_rpf_group_attribute" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = rpfgroup_api->get_rpf_group_attribute((sai_object_id_t)rpf_group_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_rpf_group_attributes(sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  sai_thrift_object_id_t sai_thrift_create_rpf_group_member(const std::vector<sai_thrift_attribute_t> & attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t rpf_group_member_oid_out = SAI_NULL_OBJECT_ID;

    sai_rpfgroup_api_t *rpfgroup_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_RPFGROUP), (void **)&rpfgroup_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_rpf_group_member_attributes(attr_list, sai_attr_list);

    if (rpfgroup_api->create_rpf_group_member == (void *)0) {
        std::cerr << "NULL ptr: rpfgroup_api->create_rpf_group_member" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = rpfgroup_api->create_rpf_group_member(&rpf_group_member_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);    return rpf_group_member_oid_out;
  }

  void sai_thrift_remove_rpf_group_member(const sai_thrift_object_id_t rpf_group_member_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_rpfgroup_api_t *rpfgroup_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_RPFGROUP), (void **)&rpfgroup_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    if (rpfgroup_api->remove_rpf_group_member == (void *)0) {
        std::cerr << "NULL ptr: rpfgroup_api->remove_rpf_group_member" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = rpfgroup_api->remove_rpf_group_member((sai_object_id_t)rpf_group_member_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_rpf_group_member_attribute(const sai_thrift_object_id_t rpf_group_member_oid, const sai_thrift_attribute_t& attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t sai_attr;

    sai_rpfgroup_api_t *rpfgroup_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_RPFGROUP), (void **)&rpfgroup_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);

    sai_thrift_parse_rpf_group_member_attributes(attr_vec, &sai_attr);

    if (rpfgroup_api->set_rpf_group_member_attribute == (void *)0) {
        std::cerr << "NULL ptr: rpfgroup_api->set_rpf_group_member_attribute" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = rpfgroup_api->set_rpf_group_member_attribute((sai_object_id_t)rpf_group_member_oid, &sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_get_rpf_group_member_attribute(sai_thrift_attribute_list_t& attr_list_out, const sai_thrift_object_id_t rpf_group_member_oid, const sai_thrift_attribute_list_t& attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_rpfgroup_api_t *rpfgroup_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_RPFGROUP), (void **)&rpfgroup_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    else {
      return;
    }


    const std::vector<sai_thrift_attribute_t> &attr_list_vec = attr_list.attr_list;

    sai_thrift_parse_rpf_group_member_attributes(attr_list_vec, sai_attr_list);

    if (rpfgroup_api->get_rpf_group_member_attribute == (void *)0) {
        std::cerr << "NULL ptr: rpfgroup_api->get_rpf_group_member_attribute" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = rpfgroup_api->get_rpf_group_member_attribute((sai_object_id_t)rpf_group_member_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_rpf_group_member_attributes(sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  sai_thrift_object_id_t sai_thrift_create_samplepacket(const std::vector<sai_thrift_attribute_t> & attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t samplepacket_oid_out = SAI_NULL_OBJECT_ID;

    sai_samplepacket_api_t *samplepacket_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_SAMPLEPACKET), (void **)&samplepacket_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_samplepacket_attributes(attr_list, sai_attr_list);

    if (samplepacket_api->create_samplepacket == (void *)0) {
        std::cerr << "NULL ptr: samplepacket_api->create_samplepacket" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = samplepacket_api->create_samplepacket(&samplepacket_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);    return samplepacket_oid_out;
  }

  void sai_thrift_remove_samplepacket(const sai_thrift_object_id_t samplepacket_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_samplepacket_api_t *samplepacket_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_SAMPLEPACKET), (void **)&samplepacket_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    if (samplepacket_api->remove_samplepacket == (void *)0) {
        std::cerr << "NULL ptr: samplepacket_api->remove_samplepacket" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = samplepacket_api->remove_samplepacket((sai_object_id_t)samplepacket_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_samplepacket_attribute(const sai_thrift_object_id_t samplepacket_oid, const sai_thrift_attribute_t& attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t sai_attr;

    sai_samplepacket_api_t *samplepacket_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_SAMPLEPACKET), (void **)&samplepacket_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);

    sai_thrift_parse_samplepacket_attributes(attr_vec, &sai_attr);

    if (samplepacket_api->set_samplepacket_attribute == (void *)0) {
        std::cerr << "NULL ptr: samplepacket_api->set_samplepacket_attribute" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = samplepacket_api->set_samplepacket_attribute((sai_object_id_t)samplepacket_oid, &sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_get_samplepacket_attribute(sai_thrift_attribute_list_t& attr_list_out, const sai_thrift_object_id_t samplepacket_oid, const sai_thrift_attribute_list_t& attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_samplepacket_api_t *samplepacket_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_SAMPLEPACKET), (void **)&samplepacket_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    else {
      return;
    }


    const std::vector<sai_thrift_attribute_t> &attr_list_vec = attr_list.attr_list;

    sai_thrift_parse_samplepacket_attributes(attr_list_vec, sai_attr_list);

    if (samplepacket_api->get_samplepacket_attribute == (void *)0) {
        std::cerr << "NULL ptr: samplepacket_api->get_samplepacket_attribute" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = samplepacket_api->get_samplepacket_attribute((sai_object_id_t)samplepacket_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_samplepacket_attributes(sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  sai_thrift_object_id_t sai_thrift_create_scheduler(const std::vector<sai_thrift_attribute_t> & attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t scheduler_oid_out = SAI_NULL_OBJECT_ID;

    sai_scheduler_api_t *scheduler_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_SCHEDULER), (void **)&scheduler_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_scheduler_attributes(attr_list, sai_attr_list);

    if (scheduler_api->create_scheduler == (void *)0) {
        std::cerr << "NULL ptr: scheduler_api->create_scheduler" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = scheduler_api->create_scheduler(&scheduler_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);    return scheduler_oid_out;
  }

  void sai_thrift_remove_scheduler(const sai_thrift_object_id_t scheduler_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_scheduler_api_t *scheduler_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_SCHEDULER), (void **)&scheduler_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    if (scheduler_api->remove_scheduler == (void *)0) {
        std::cerr << "NULL ptr: scheduler_api->remove_scheduler" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = scheduler_api->remove_scheduler((sai_object_id_t)scheduler_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_scheduler_attribute(const sai_thrift_object_id_t scheduler_oid, const sai_thrift_attribute_t& attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t sai_attr;

    sai_scheduler_api_t *scheduler_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_SCHEDULER), (void **)&scheduler_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);

    sai_thrift_parse_scheduler_attributes(attr_vec, &sai_attr);

    if (scheduler_api->set_scheduler_attribute == (void *)0) {
        std::cerr << "NULL ptr: scheduler_api->set_scheduler_attribute" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = scheduler_api->set_scheduler_attribute((sai_object_id_t)scheduler_oid, &sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_get_scheduler_attribute(sai_thrift_attribute_list_t& attr_list_out, const sai_thrift_object_id_t scheduler_oid, const sai_thrift_attribute_list_t& attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_scheduler_api_t *scheduler_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_SCHEDULER), (void **)&scheduler_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    else {
      return;
    }


    const std::vector<sai_thrift_attribute_t> &attr_list_vec = attr_list.attr_list;

    sai_thrift_parse_scheduler_attributes(attr_list_vec, sai_attr_list);

    if (scheduler_api->get_scheduler_attribute == (void *)0) {
        std::cerr << "NULL ptr: scheduler_api->get_scheduler_attribute" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = scheduler_api->get_scheduler_attribute((sai_object_id_t)scheduler_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_scheduler_attributes(sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  sai_thrift_object_id_t sai_thrift_create_scheduler_group(const std::vector<sai_thrift_attribute_t> & attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t scheduler_group_oid_out = SAI_NULL_OBJECT_ID;

    sai_schedulergroup_api_t *schedulergroup_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_SCHEDULERGROUP), (void **)&schedulergroup_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_scheduler_group_attributes(attr_list, sai_attr_list);

    if (schedulergroup_api->create_scheduler_group == (void *)0) {
        std::cerr << "NULL ptr: schedulergroup_api->create_scheduler_group" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = schedulergroup_api->create_scheduler_group(&scheduler_group_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);    return scheduler_group_oid_out;
  }

  void sai_thrift_remove_scheduler_group(const sai_thrift_object_id_t scheduler_group_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_schedulergroup_api_t *schedulergroup_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_SCHEDULERGROUP), (void **)&schedulergroup_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    if (schedulergroup_api->remove_scheduler_group == (void *)0) {
        std::cerr << "NULL ptr: schedulergroup_api->remove_scheduler_group" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = schedulergroup_api->remove_scheduler_group((sai_object_id_t)scheduler_group_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_scheduler_group_attribute(const sai_thrift_object_id_t scheduler_group_oid, const sai_thrift_attribute_t& attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t sai_attr;

    sai_schedulergroup_api_t *schedulergroup_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_SCHEDULERGROUP), (void **)&schedulergroup_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);

    sai_thrift_parse_scheduler_group_attributes(attr_vec, &sai_attr);

    if (schedulergroup_api->set_scheduler_group_attribute == (void *)0) {
        std::cerr << "NULL ptr: schedulergroup_api->set_scheduler_group_attribute" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = schedulergroup_api->set_scheduler_group_attribute((sai_object_id_t)scheduler_group_oid, &sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_get_scheduler_group_attribute(sai_thrift_attribute_list_t& attr_list_out, const sai_thrift_object_id_t scheduler_group_oid, const sai_thrift_attribute_list_t& attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_schedulergroup_api_t *schedulergroup_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_SCHEDULERGROUP), (void **)&schedulergroup_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    else {
      return;
    }


    const std::vector<sai_thrift_attribute_t> &attr_list_vec = attr_list.attr_list;

    sai_thrift_parse_scheduler_group_attributes(attr_list_vec, sai_attr_list);

    if (schedulergroup_api->get_scheduler_group_attribute == (void *)0) {
        std::cerr << "NULL ptr: schedulergroup_api->get_scheduler_group_attribute" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = schedulergroup_api->get_scheduler_group_attribute((sai_object_id_t)scheduler_group_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_scheduler_group_attributes(sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  sai_thrift_object_id_t sai_thrift_create_srv6_sidlist(const std::vector<sai_thrift_attribute_t> & attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t srv6_sidlist_oid_out = SAI_NULL_OBJECT_ID;

    sai_srv6_api_t *srv6_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_SRV6), (void **)&srv6_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_srv6_sidlist_attributes(attr_list, sai_attr_list);

    if (srv6_api->create_srv6_sidlist == (void *)0) {
        std::cerr << "NULL ptr: srv6_api->create_srv6_sidlist" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = srv6_api->create_srv6_sidlist(&srv6_sidlist_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);    return srv6_sidlist_oid_out;
  }

  void sai_thrift_remove_srv6_sidlist(const sai_thrift_object_id_t srv6_sidlist_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_srv6_api_t *srv6_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_SRV6), (void **)&srv6_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    if (srv6_api->remove_srv6_sidlist == (void *)0) {
        std::cerr << "NULL ptr: srv6_api->remove_srv6_sidlist" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = srv6_api->remove_srv6_sidlist((sai_object_id_t)srv6_sidlist_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_srv6_sidlist_attribute(const sai_thrift_object_id_t srv6_sidlist_oid, const sai_thrift_attribute_t& attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t sai_attr;

    sai_srv6_api_t *srv6_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_SRV6), (void **)&srv6_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);

    sai_thrift_parse_srv6_sidlist_attributes(attr_vec, &sai_attr);

    if (srv6_api->set_srv6_sidlist_attribute == (void *)0) {
        std::cerr << "NULL ptr: srv6_api->set_srv6_sidlist_attribute" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = srv6_api->set_srv6_sidlist_attribute((sai_object_id_t)srv6_sidlist_oid, &sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_get_srv6_sidlist_attribute(sai_thrift_attribute_list_t& attr_list_out, const sai_thrift_object_id_t srv6_sidlist_oid, const sai_thrift_attribute_list_t& attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_srv6_api_t *srv6_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_SRV6), (void **)&srv6_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    else {
      return;
    }


    const std::vector<sai_thrift_attribute_t> &attr_list_vec = attr_list.attr_list;

    sai_thrift_parse_srv6_sidlist_attributes(attr_list_vec, sai_attr_list);

    if (srv6_api->get_srv6_sidlist_attribute == (void *)0) {
        std::cerr << "NULL ptr: srv6_api->get_srv6_sidlist_attribute" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = srv6_api->get_srv6_sidlist_attribute((sai_object_id_t)srv6_sidlist_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_srv6_sidlist_attributes(sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  void sai_thrift_get_srv6_sidlist_stats(std::vector<sai_thrift_uint64_t> & counters_out, const sai_thrift_object_id_t srv6_sidlist_oid, const std::vector<sai_thrift_stat_id_t> & counter_ids) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_srv6_api_t *srv6_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_SRV6), (void **)&srv6_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_stat_id_t *sai_counter_ids = NULL;
    uint32_t number_of_counters = counter_ids.size();

    if (number_of_counters != 0) {
      sai_counter_ids = (sai_stat_id_t *)malloc(sizeof(sai_stat_id_t) * number_of_counters);
    }
    else {
      return;
    }


    std::vector<sai_thrift_stat_id_t>::const_iterator it = counter_ids.begin();
    for (uint32_t i = 0; i < counter_ids.size(); i++, it++) {
      sai_counter_ids[i] = (sai_stat_id_t)*it;
    }

    uint64_t *sai_counters = NULL;
    if (number_of_counters != 0) {
      sai_counters = (uint64_t *)malloc(sizeof(uint64_t) * number_of_counters);
    }

    if (srv6_api->get_srv6_sidlist_stats == (void *)0) {
        std::cerr << "NULL ptr: srv6_api->get_srv6_sidlist_stats" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = srv6_api->get_srv6_sidlist_stats((sai_object_id_t)srv6_sidlist_oid, number_of_counters, sai_counter_ids, sai_counters);

    // sai_adapter always takes all srv6 stats. Since some of them may be
    // not supported, SAI_STATUS_INVALID_PARAMETER should not be raised.
    if (status != SAI_STATUS_SUCCESS && status != SAI_STATUS_INVALID_PARAMETER) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_counter_ids);
    for (uint32_t i = 0; i < (uint32_t)number_of_counters; i++) {
      counters_out.push_back((sai_thrift_uint64_t)sai_counters[i]);
    }
    free(sai_counters);
    return;
  }

  void sai_thrift_get_srv6_sidlist_stats_ext(std::vector<sai_thrift_uint64_t> & counters_out, const sai_thrift_object_id_t srv6_sidlist_oid, const std::vector<sai_thrift_stat_id_t> & counter_ids, const sai_thrift_stats_mode_t mode) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_srv6_api_t *srv6_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_SRV6), (void **)&srv6_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_stat_id_t *sai_counter_ids = NULL;
    uint32_t number_of_counters = counter_ids.size();

    if (number_of_counters != 0) {
      sai_counter_ids = (sai_stat_id_t *)malloc(sizeof(sai_stat_id_t) * number_of_counters);
    }
    else {
      return;
    }


    std::vector<sai_thrift_stat_id_t>::const_iterator it = counter_ids.begin();
    for (uint32_t i = 0; i < counter_ids.size(); i++, it++) {
      sai_counter_ids[i] = (sai_stat_id_t)*it;
    }

    uint64_t *sai_counters = NULL;
    if (number_of_counters != 0) {
      sai_counters = (uint64_t *)malloc(sizeof(uint64_t) * number_of_counters);
    }

    if (srv6_api->get_srv6_sidlist_stats_ext == (void *)0) {
        std::cerr << "NULL ptr: srv6_api->get_srv6_sidlist_stats_ext" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = srv6_api->get_srv6_sidlist_stats_ext((sai_object_id_t)srv6_sidlist_oid, number_of_counters, sai_counter_ids, (sai_stats_mode_t)mode, sai_counters);

    // sai_adapter always takes all srv6 stats. Since some of them may be
    // not supported, SAI_STATUS_INVALID_PARAMETER should not be raised.
    if (status != SAI_STATUS_SUCCESS && status != SAI_STATUS_INVALID_PARAMETER) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_counter_ids);
    for (uint32_t i = 0; i < (uint32_t)number_of_counters; i++) {
      counters_out.push_back((sai_thrift_uint64_t)sai_counters[i]);
    }
    free(sai_counters);
    return;
  }

  void sai_thrift_clear_srv6_sidlist_stats(const sai_thrift_object_id_t srv6_sidlist_oid, const std::vector<sai_thrift_stat_id_t> & counter_ids) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_srv6_api_t *srv6_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_SRV6), (void **)&srv6_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_stat_id_t *sai_counter_ids = NULL;
    uint32_t number_of_counters = counter_ids.size();

    if (number_of_counters != 0) {
      sai_counter_ids = (sai_stat_id_t *)malloc(sizeof(sai_stat_id_t) * number_of_counters);
    }
    else {
      return;
    }


    std::vector<sai_thrift_stat_id_t>::const_iterator it = counter_ids.begin();
    for (uint32_t i = 0; i < counter_ids.size(); i++, it++) {
      sai_counter_ids[i] = (sai_stat_id_t)*it;
    }

    if (srv6_api->clear_srv6_sidlist_stats == (void *)0) {
        std::cerr << "NULL ptr: srv6_api->clear_srv6_sidlist_stats" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = srv6_api->clear_srv6_sidlist_stats((sai_object_id_t)srv6_sidlist_oid, number_of_counters, sai_counter_ids);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_counter_ids);
    return;
  }

  void sai_thrift_create_my_sid_entry(const sai_thrift_my_sid_entry_t& my_sid_entry, const std::vector<sai_thrift_attribute_t> & attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_my_sid_entry_t sai_my_sid_entry;

    sai_srv6_api_t *srv6_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_SRV6), (void **)&srv6_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_parse_my_sid_entry(my_sid_entry, &sai_my_sid_entry);

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_my_sid_entry_attributes(attr_list, sai_attr_list);

    if (srv6_api->create_my_sid_entry == (void *)0) {
        std::cerr << "NULL ptr: srv6_api->create_my_sid_entry" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = srv6_api->create_my_sid_entry(&sai_my_sid_entry, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);
    return;
  }

  void sai_thrift_remove_my_sid_entry(const sai_thrift_my_sid_entry_t& my_sid_entry) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_my_sid_entry_t sai_my_sid_entry;

    sai_srv6_api_t *srv6_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_SRV6), (void **)&srv6_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_parse_my_sid_entry(my_sid_entry, &sai_my_sid_entry);

    if (srv6_api->remove_my_sid_entry == (void *)0) {
        std::cerr << "NULL ptr: srv6_api->remove_my_sid_entry" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = srv6_api->remove_my_sid_entry(&sai_my_sid_entry);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_my_sid_entry_attribute(const sai_thrift_my_sid_entry_t& my_sid_entry, const sai_thrift_attribute_t& attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_my_sid_entry_t sai_my_sid_entry;
    sai_attribute_t sai_attr;

    sai_srv6_api_t *srv6_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_SRV6), (void **)&srv6_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_parse_my_sid_entry(my_sid_entry, &sai_my_sid_entry);

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);

    sai_thrift_parse_my_sid_entry_attributes(attr_vec, &sai_attr);

    if (srv6_api->set_my_sid_entry_attribute == (void *)0) {
        std::cerr << "NULL ptr: srv6_api->set_my_sid_entry_attribute" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = srv6_api->set_my_sid_entry_attribute(&sai_my_sid_entry, &sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_get_my_sid_entry_attribute(sai_thrift_attribute_list_t& attr_list_out, const sai_thrift_my_sid_entry_t& my_sid_entry, const sai_thrift_attribute_list_t& attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_my_sid_entry_t sai_my_sid_entry;

    sai_srv6_api_t *srv6_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_SRV6), (void **)&srv6_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_parse_my_sid_entry(my_sid_entry, &sai_my_sid_entry);

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    else {
      return;
    }


    const std::vector<sai_thrift_attribute_t> &attr_list_vec = attr_list.attr_list;

    sai_thrift_parse_my_sid_entry_attributes(attr_list_vec, sai_attr_list);

    if (srv6_api->get_my_sid_entry_attribute == (void *)0) {
        std::cerr << "NULL ptr: srv6_api->get_my_sid_entry_attribute" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = srv6_api->get_my_sid_entry_attribute(&sai_my_sid_entry, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_my_sid_entry_attributes(sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  void sai_thrift_bulk_create_my_sid_entry(std::vector<sai_thrift_status_t> & object_statuses_out, const std::vector<sai_thrift_my_sid_entry_t> & my_sid_entry, const std::vector<sai_thrift_uint32_t> & attr_count, const std::vector<sai_thrift_attribute_t> & attr_list, const sai_thrift_bulk_op_error_mode_t mode) {

    // This function is UNSUPPORTED
    return;
  }

  void sai_thrift_bulk_remove_my_sid_entry(std::vector<sai_thrift_status_t> & object_statuses_out, const std::vector<sai_thrift_my_sid_entry_t> & my_sid_entry, const sai_thrift_bulk_op_error_mode_t mode) {

    // This function is UNSUPPORTED
    return;
  }

  void sai_thrift_bulk_set_my_sid_entry_attribute(std::vector<sai_thrift_status_t> & object_statuses_out, const std::vector<sai_thrift_my_sid_entry_t> & my_sid_entry, const std::vector<sai_thrift_attribute_t> & attr_list, const sai_thrift_bulk_op_error_mode_t mode) {

    // This function is UNSUPPORTED
    return;
  }

  void sai_thrift_bulk_get_my_sid_entry_attribute(sai_thrift_attribute_list_t& attr_list_out, const std::vector<sai_thrift_my_sid_entry_t> & my_sid_entry, const std::vector<sai_thrift_uint32_t> & attr_count, const sai_thrift_attribute_list_t& attr_list, const sai_thrift_bulk_op_error_mode_t mode, const std::vector<sai_thrift_status_t> & object_statuses) {

    // This function is UNSUPPORTED
    return;
  }

  sai_thrift_object_id_t sai_thrift_create_stp(const std::vector<sai_thrift_attribute_t> & attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t stp_oid_out = SAI_NULL_OBJECT_ID;

    sai_stp_api_t *stp_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_STP), (void **)&stp_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_stp_attributes(attr_list, sai_attr_list);

    if (stp_api->create_stp == (void *)0) {
        std::cerr << "NULL ptr: stp_api->create_stp" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = stp_api->create_stp(&stp_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);    return stp_oid_out;
  }

  void sai_thrift_remove_stp(const sai_thrift_object_id_t stp_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_stp_api_t *stp_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_STP), (void **)&stp_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    if (stp_api->remove_stp == (void *)0) {
        std::cerr << "NULL ptr: stp_api->remove_stp" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = stp_api->remove_stp((sai_object_id_t)stp_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_stp_attribute(const sai_thrift_object_id_t stp_oid, const sai_thrift_attribute_t& attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t sai_attr;

    sai_stp_api_t *stp_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_STP), (void **)&stp_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);

    sai_thrift_parse_stp_attributes(attr_vec, &sai_attr);

    if (stp_api->set_stp_attribute == (void *)0) {
        std::cerr << "NULL ptr: stp_api->set_stp_attribute" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = stp_api->set_stp_attribute((sai_object_id_t)stp_oid, &sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_get_stp_attribute(sai_thrift_attribute_list_t& attr_list_out, const sai_thrift_object_id_t stp_oid, const sai_thrift_attribute_list_t& attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_stp_api_t *stp_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_STP), (void **)&stp_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    else {
      return;
    }


    const std::vector<sai_thrift_attribute_t> &attr_list_vec = attr_list.attr_list;

    sai_thrift_parse_stp_attributes(attr_list_vec, sai_attr_list);

    if (stp_api->get_stp_attribute == (void *)0) {
        std::cerr << "NULL ptr: stp_api->get_stp_attribute" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = stp_api->get_stp_attribute((sai_object_id_t)stp_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_stp_attributes(sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  sai_thrift_object_id_t sai_thrift_create_stp_port(const std::vector<sai_thrift_attribute_t> & attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t stp_port_oid_out = SAI_NULL_OBJECT_ID;

    sai_stp_api_t *stp_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_STP), (void **)&stp_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_stp_port_attributes(attr_list, sai_attr_list);

    if (stp_api->create_stp_port == (void *)0) {
        std::cerr << "NULL ptr: stp_api->create_stp_port" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = stp_api->create_stp_port(&stp_port_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);    return stp_port_oid_out;
  }

  void sai_thrift_remove_stp_port(const sai_thrift_object_id_t stp_port_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_stp_api_t *stp_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_STP), (void **)&stp_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    if (stp_api->remove_stp_port == (void *)0) {
        std::cerr << "NULL ptr: stp_api->remove_stp_port" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = stp_api->remove_stp_port((sai_object_id_t)stp_port_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_stp_port_attribute(const sai_thrift_object_id_t stp_port_oid, const sai_thrift_attribute_t& attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t sai_attr;

    sai_stp_api_t *stp_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_STP), (void **)&stp_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);

    sai_thrift_parse_stp_port_attributes(attr_vec, &sai_attr);

    if (stp_api->set_stp_port_attribute == (void *)0) {
        std::cerr << "NULL ptr: stp_api->set_stp_port_attribute" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = stp_api->set_stp_port_attribute((sai_object_id_t)stp_port_oid, &sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_get_stp_port_attribute(sai_thrift_attribute_list_t& attr_list_out, const sai_thrift_object_id_t stp_port_oid, const sai_thrift_attribute_list_t& attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_stp_api_t *stp_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_STP), (void **)&stp_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    else {
      return;
    }


    const std::vector<sai_thrift_attribute_t> &attr_list_vec = attr_list.attr_list;

    sai_thrift_parse_stp_port_attributes(attr_list_vec, sai_attr_list);

    if (stp_api->get_stp_port_attribute == (void *)0) {
        std::cerr << "NULL ptr: stp_api->get_stp_port_attribute" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = stp_api->get_stp_port_attribute((sai_object_id_t)stp_port_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_stp_port_attributes(sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  void sai_thrift_switch_register_read(std::vector<sai_thrift_uint32_t> & reg_val_out, const sai_thrift_uint64_t platform_context, const sai_thrift_uint32_t device_addr, const sai_thrift_uint32_t start_reg_addr) {

    // This function is UNSUPPORTED
    return;
  }

  void sai_thrift_switch_register_write(const sai_thrift_uint64_t platform_context, const sai_thrift_uint32_t device_addr, const sai_thrift_uint32_t start_reg_addr, const std::vector<sai_thrift_uint32_t> & reg_val) {

    // This function is UNSUPPORTED
    return;
  }

  void sai_thrift_switch_mdio_read(std::vector<sai_thrift_uint32_t> & reg_val_out, const sai_thrift_uint32_t device_addr, const sai_thrift_uint32_t start_reg_addr) {

    // This function is UNSUPPORTED
    return;
  }

  void sai_thrift_switch_mdio_write(const sai_thrift_uint32_t device_addr, const sai_thrift_uint32_t start_reg_addr, const std::vector<sai_thrift_uint32_t> & reg_val) {

    // This function is UNSUPPORTED
    return;
  }

  void sai_thrift_switch_mdio_cl22_read(std::vector<sai_thrift_uint32_t> & reg_val_out, const sai_thrift_uint32_t device_addr, const sai_thrift_uint32_t start_reg_addr) {

    // This function is UNSUPPORTED
    return;
  }

  void sai_thrift_switch_mdio_cl22_write(const sai_thrift_uint32_t device_addr, const sai_thrift_uint32_t start_reg_addr, const std::vector<sai_thrift_uint32_t> & reg_val) {

    // This function is UNSUPPORTED
    return;
  }

  sai_thrift_object_id_t sai_thrift_create_switch(const std::vector<sai_thrift_attribute_t> & attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t switch_id_out = SAI_NULL_OBJECT_ID;

    // need to check if the switch exist
    if (switch_id != NULL) {
        return switch_id;
    }

    //check if the switch created in syncd
    if (gSwitchId != NULL) {
      switch_id = gSwitchId;
      return switch_id;
    }
   
    sai_switch_api_t *switch_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_SWITCH), (void **)&switch_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_switch_attributes(attr_list, sai_attr_list);

    if (switch_api->create_switch == (void *)0) {
        std::cerr << "NULL ptr: switch_api->create_switch" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = switch_api->create_switch(&switch_id_out, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);
    // switch_id is stored in the global variable
    switch_id = switch_id_out;    return switch_id_out;
  }

  void sai_thrift_remove_switch() {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_switch_api_t *switch_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_SWITCH), (void **)&switch_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    if (switch_api->remove_switch == (void *)0) {
        std::cerr << "NULL ptr: switch_api->remove_switch" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = switch_api->remove_switch(switch_id);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    // reset the switch id
    switch_id = NULL;
   
    return;
  }

  void sai_thrift_set_switch_attribute(const sai_thrift_attribute_t& attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t sai_attr;

    sai_switch_api_t *switch_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_SWITCH), (void **)&switch_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);

    sai_thrift_parse_switch_attributes(attr_vec, &sai_attr);

    if (switch_api->set_switch_attribute == (void *)0) {
        std::cerr << "NULL ptr: switch_api->set_switch_attribute" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = switch_api->set_switch_attribute(switch_id, &sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_get_switch_attribute(sai_thrift_attribute_list_t& attr_list_out, const sai_thrift_attribute_list_t& attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_switch_api_t *switch_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_SWITCH), (void **)&switch_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    else {
      return;
    }


    const std::vector<sai_thrift_attribute_t> &attr_list_vec = attr_list.attr_list;

    sai_thrift_parse_switch_attributes(attr_list_vec, sai_attr_list);

    if (switch_api->get_switch_attribute == (void *)0) {
        std::cerr << "NULL ptr: switch_api->get_switch_attribute" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = switch_api->get_switch_attribute(switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_switch_attributes(sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  void sai_thrift_get_switch_stats(std::vector<sai_thrift_uint64_t> & counters_out, const std::vector<sai_thrift_stat_id_t> & counter_ids) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_switch_api_t *switch_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_SWITCH), (void **)&switch_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_stat_id_t *sai_counter_ids = NULL;
    uint32_t number_of_counters = counter_ids.size();

    if (number_of_counters != 0) {
      sai_counter_ids = (sai_stat_id_t *)malloc(sizeof(sai_stat_id_t) * number_of_counters);
    }
    else {
      return;
    }


    std::vector<sai_thrift_stat_id_t>::const_iterator it = counter_ids.begin();
    for (uint32_t i = 0; i < counter_ids.size(); i++, it++) {
      sai_counter_ids[i] = (sai_stat_id_t)*it;
    }

    uint64_t *sai_counters = NULL;
    if (number_of_counters != 0) {
      sai_counters = (uint64_t *)malloc(sizeof(uint64_t) * number_of_counters);
    }

    if (switch_api->get_switch_stats == (void *)0) {
        std::cerr << "NULL ptr: switch_api->get_switch_stats" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = switch_api->get_switch_stats(switch_id, number_of_counters, sai_counter_ids, sai_counters);

    // sai_adapter always takes all switch stats. Since some of them may be
    // not supported, SAI_STATUS_INVALID_PARAMETER should not be raised.
    if (status != SAI_STATUS_SUCCESS && status != SAI_STATUS_INVALID_PARAMETER) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_counter_ids);
    for (uint32_t i = 0; i < (uint32_t)number_of_counters; i++) {
      counters_out.push_back((sai_thrift_uint64_t)sai_counters[i]);
    }
    free(sai_counters);
    return;
  }

  void sai_thrift_get_switch_stats_ext(std::vector<sai_thrift_uint64_t> & counters_out, const std::vector<sai_thrift_stat_id_t> & counter_ids, const sai_thrift_stats_mode_t mode) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_switch_api_t *switch_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_SWITCH), (void **)&switch_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_stat_id_t *sai_counter_ids = NULL;
    uint32_t number_of_counters = counter_ids.size();

    if (number_of_counters != 0) {
      sai_counter_ids = (sai_stat_id_t *)malloc(sizeof(sai_stat_id_t) * number_of_counters);
    }
    else {
      return;
    }


    std::vector<sai_thrift_stat_id_t>::const_iterator it = counter_ids.begin();
    for (uint32_t i = 0; i < counter_ids.size(); i++, it++) {
      sai_counter_ids[i] = (sai_stat_id_t)*it;
    }

    uint64_t *sai_counters = NULL;
    if (number_of_counters != 0) {
      sai_counters = (uint64_t *)malloc(sizeof(uint64_t) * number_of_counters);
    }

    if (switch_api->get_switch_stats_ext == (void *)0) {
        std::cerr << "NULL ptr: switch_api->get_switch_stats_ext" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = switch_api->get_switch_stats_ext(switch_id, number_of_counters, sai_counter_ids, (sai_stats_mode_t)mode, sai_counters);

    // sai_adapter always takes all switch stats. Since some of them may be
    // not supported, SAI_STATUS_INVALID_PARAMETER should not be raised.
    if (status != SAI_STATUS_SUCCESS && status != SAI_STATUS_INVALID_PARAMETER) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_counter_ids);
    for (uint32_t i = 0; i < (uint32_t)number_of_counters; i++) {
      counters_out.push_back((sai_thrift_uint64_t)sai_counters[i]);
    }
    free(sai_counters);
    return;
  }

  void sai_thrift_clear_switch_stats(const std::vector<sai_thrift_stat_id_t> & counter_ids) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_switch_api_t *switch_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_SWITCH), (void **)&switch_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_stat_id_t *sai_counter_ids = NULL;
    uint32_t number_of_counters = counter_ids.size();

    if (number_of_counters != 0) {
      sai_counter_ids = (sai_stat_id_t *)malloc(sizeof(sai_stat_id_t) * number_of_counters);
    }
    else {
      return;
    }


    std::vector<sai_thrift_stat_id_t>::const_iterator it = counter_ids.begin();
    for (uint32_t i = 0; i < counter_ids.size(); i++, it++) {
      sai_counter_ids[i] = (sai_stat_id_t)*it;
    }

    if (switch_api->clear_switch_stats == (void *)0) {
        std::cerr << "NULL ptr: switch_api->clear_switch_stats" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = switch_api->clear_switch_stats(switch_id, number_of_counters, sai_counter_ids);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_counter_ids);
    return;
  }

  sai_thrift_object_id_t sai_thrift_create_switch_tunnel(const std::vector<sai_thrift_attribute_t> & attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t switch_tunnel_oid_out = SAI_NULL_OBJECT_ID;

    // need to check if the switch exist
    if (switch_id != NULL) {
        return switch_id;
    }

    //check if the switch created in syncd
    if (gSwitchId != NULL) {
      switch_id = gSwitchId;
      return switch_id;
    }
   
    sai_switch_api_t *switch_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_SWITCH), (void **)&switch_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_switch_tunnel_attributes(attr_list, sai_attr_list);

    if (switch_api->create_switch_tunnel == (void *)0) {
        std::cerr << "NULL ptr: switch_api->create_switch_tunnel" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = switch_api->create_switch_tunnel(&switch_tunnel_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);    return switch_tunnel_oid_out;
  }

  void sai_thrift_remove_switch_tunnel(const sai_thrift_object_id_t switch_tunnel_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_switch_api_t *switch_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_SWITCH), (void **)&switch_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    if (switch_api->remove_switch_tunnel == (void *)0) {
        std::cerr << "NULL ptr: switch_api->remove_switch_tunnel" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = switch_api->remove_switch_tunnel((sai_object_id_t)switch_tunnel_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    // reset the switch id
    switch_id = NULL;
   
    return;
  }

  void sai_thrift_set_switch_tunnel_attribute(const sai_thrift_object_id_t switch_tunnel_oid, const sai_thrift_attribute_t& attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t sai_attr;

    sai_switch_api_t *switch_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_SWITCH), (void **)&switch_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);

    sai_thrift_parse_switch_tunnel_attributes(attr_vec, &sai_attr);

    if (switch_api->set_switch_tunnel_attribute == (void *)0) {
        std::cerr << "NULL ptr: switch_api->set_switch_tunnel_attribute" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = switch_api->set_switch_tunnel_attribute((sai_object_id_t)switch_tunnel_oid, &sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_get_switch_tunnel_attribute(sai_thrift_attribute_list_t& attr_list_out, const sai_thrift_object_id_t switch_tunnel_oid, const sai_thrift_attribute_list_t& attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_switch_api_t *switch_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_SWITCH), (void **)&switch_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    else {
      return;
    }


    const std::vector<sai_thrift_attribute_t> &attr_list_vec = attr_list.attr_list;

    sai_thrift_parse_switch_tunnel_attributes(attr_list_vec, sai_attr_list);

    if (switch_api->get_switch_tunnel_attribute == (void *)0) {
        std::cerr << "NULL ptr: switch_api->get_switch_tunnel_attribute" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = switch_api->get_switch_tunnel_attribute((sai_object_id_t)switch_tunnel_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_switch_tunnel_attributes(sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  sai_thrift_object_id_t sai_thrift_create_system_port(const std::vector<sai_thrift_attribute_t> & attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t system_port_oid_out = SAI_NULL_OBJECT_ID;

    sai_systemport_api_t *systemport_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_SYSTEMPORT), (void **)&systemport_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_system_port_attributes(attr_list, sai_attr_list);

    if (systemport_api->create_system_port == (void *)0) {
        std::cerr << "NULL ptr: systemport_api->create_system_port" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = systemport_api->create_system_port(&system_port_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);    return system_port_oid_out;
  }

  void sai_thrift_remove_system_port(const sai_thrift_object_id_t system_port_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_systemport_api_t *systemport_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_SYSTEMPORT), (void **)&systemport_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    if (systemport_api->remove_system_port == (void *)0) {
        std::cerr << "NULL ptr: systemport_api->remove_system_port" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = systemport_api->remove_system_port((sai_object_id_t)system_port_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_system_port_attribute(const sai_thrift_object_id_t system_port_oid, const sai_thrift_attribute_t& attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t sai_attr;

    sai_systemport_api_t *systemport_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_SYSTEMPORT), (void **)&systemport_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);

    sai_thrift_parse_system_port_attributes(attr_vec, &sai_attr);

    if (systemport_api->set_system_port_attribute == (void *)0) {
        std::cerr << "NULL ptr: systemport_api->set_system_port_attribute" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = systemport_api->set_system_port_attribute((sai_object_id_t)system_port_oid, &sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_get_system_port_attribute(sai_thrift_attribute_list_t& attr_list_out, const sai_thrift_object_id_t system_port_oid, const sai_thrift_attribute_list_t& attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_systemport_api_t *systemport_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_SYSTEMPORT), (void **)&systemport_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    else {
      return;
    }


    const std::vector<sai_thrift_attribute_t> &attr_list_vec = attr_list.attr_list;

    sai_thrift_parse_system_port_attributes(attr_list_vec, sai_attr_list);

    if (systemport_api->get_system_port_attribute == (void *)0) {
        std::cerr << "NULL ptr: systemport_api->get_system_port_attribute" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = systemport_api->get_system_port_attribute((sai_object_id_t)system_port_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_system_port_attributes(sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  sai_thrift_object_id_t sai_thrift_create_tam(const std::vector<sai_thrift_attribute_t> & attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t tam_oid_out = SAI_NULL_OBJECT_ID;

    sai_tam_api_t *tam_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_TAM), (void **)&tam_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_tam_attributes(attr_list, sai_attr_list);

    if (tam_api->create_tam == (void *)0) {
        std::cerr << "NULL ptr: tam_api->create_tam" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = tam_api->create_tam(&tam_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);    return tam_oid_out;
  }

  void sai_thrift_remove_tam(const sai_thrift_object_id_t tam_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_tam_api_t *tam_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_TAM), (void **)&tam_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    if (tam_api->remove_tam == (void *)0) {
        std::cerr << "NULL ptr: tam_api->remove_tam" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = tam_api->remove_tam((sai_object_id_t)tam_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_tam_attribute(const sai_thrift_object_id_t tam_oid, const sai_thrift_attribute_t& attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t sai_attr;

    sai_tam_api_t *tam_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_TAM), (void **)&tam_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);

    sai_thrift_parse_tam_attributes(attr_vec, &sai_attr);

    if (tam_api->set_tam_attribute == (void *)0) {
        std::cerr << "NULL ptr: tam_api->set_tam_attribute" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = tam_api->set_tam_attribute((sai_object_id_t)tam_oid, &sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_get_tam_attribute(sai_thrift_attribute_list_t& attr_list_out, const sai_thrift_object_id_t tam_oid, const sai_thrift_attribute_list_t& attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_tam_api_t *tam_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_TAM), (void **)&tam_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    else {
      return;
    }


    const std::vector<sai_thrift_attribute_t> &attr_list_vec = attr_list.attr_list;

    sai_thrift_parse_tam_attributes(attr_list_vec, sai_attr_list);

    if (tam_api->get_tam_attribute == (void *)0) {
        std::cerr << "NULL ptr: tam_api->get_tam_attribute" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = tam_api->get_tam_attribute((sai_object_id_t)tam_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_tam_attributes(sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  sai_thrift_object_id_t sai_thrift_create_tam_math_func(const std::vector<sai_thrift_attribute_t> & attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t tam_math_func_oid_out = SAI_NULL_OBJECT_ID;

    sai_tam_api_t *tam_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_TAM), (void **)&tam_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_tam_math_func_attributes(attr_list, sai_attr_list);

    if (tam_api->create_tam_math_func == (void *)0) {
        std::cerr << "NULL ptr: tam_api->create_tam_math_func" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = tam_api->create_tam_math_func(&tam_math_func_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);    return tam_math_func_oid_out;
  }

  void sai_thrift_remove_tam_math_func(const sai_thrift_object_id_t tam_math_func_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_tam_api_t *tam_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_TAM), (void **)&tam_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    if (tam_api->remove_tam_math_func == (void *)0) {
        std::cerr << "NULL ptr: tam_api->remove_tam_math_func" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = tam_api->remove_tam_math_func((sai_object_id_t)tam_math_func_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_get_tam_math_func_attribute(sai_thrift_attribute_list_t& attr_list_out, const sai_thrift_object_id_t tam_math_func_oid, const sai_thrift_attribute_list_t& attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_tam_api_t *tam_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_TAM), (void **)&tam_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    else {
      return;
    }


    const std::vector<sai_thrift_attribute_t> &attr_list_vec = attr_list.attr_list;

    sai_thrift_parse_tam_math_func_attributes(attr_list_vec, sai_attr_list);

    if (tam_api->get_tam_math_func_attribute == (void *)0) {
        std::cerr << "NULL ptr: tam_api->get_tam_math_func_attribute" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = tam_api->get_tam_math_func_attribute((sai_object_id_t)tam_math_func_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_tam_math_func_attributes(sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  void sai_thrift_set_tam_math_func_attribute(const sai_thrift_object_id_t tam_math_func_oid, const sai_thrift_attribute_t& attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t sai_attr;

    sai_tam_api_t *tam_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_TAM), (void **)&tam_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);

    sai_thrift_parse_tam_math_func_attributes(attr_vec, &sai_attr);

    if (tam_api->set_tam_math_func_attribute == (void *)0) {
        std::cerr << "NULL ptr: tam_api->set_tam_math_func_attribute" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = tam_api->set_tam_math_func_attribute((sai_object_id_t)tam_math_func_oid, &sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  sai_thrift_object_id_t sai_thrift_create_tam_event_threshold(const std::vector<sai_thrift_attribute_t> & attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t tam_event_threshold_oid_out = SAI_NULL_OBJECT_ID;

    sai_tam_api_t *tam_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_TAM), (void **)&tam_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_tam_event_threshold_attributes(attr_list, sai_attr_list);

    if (tam_api->create_tam_event_threshold == (void *)0) {
        std::cerr << "NULL ptr: tam_api->create_tam_event_threshold" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = tam_api->create_tam_event_threshold(&tam_event_threshold_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);    return tam_event_threshold_oid_out;
  }

  void sai_thrift_remove_tam_event_threshold(const sai_thrift_object_id_t tam_event_threshold_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_tam_api_t *tam_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_TAM), (void **)&tam_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    if (tam_api->remove_tam_event_threshold == (void *)0) {
        std::cerr << "NULL ptr: tam_api->remove_tam_event_threshold" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = tam_api->remove_tam_event_threshold((sai_object_id_t)tam_event_threshold_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_get_tam_event_threshold_attribute(sai_thrift_attribute_list_t& attr_list_out, const sai_thrift_object_id_t tam_event_threshold_oid, const sai_thrift_attribute_list_t& attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_tam_api_t *tam_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_TAM), (void **)&tam_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    else {
      return;
    }


    const std::vector<sai_thrift_attribute_t> &attr_list_vec = attr_list.attr_list;

    sai_thrift_parse_tam_event_threshold_attributes(attr_list_vec, sai_attr_list);

    if (tam_api->get_tam_event_threshold_attribute == (void *)0) {
        std::cerr << "NULL ptr: tam_api->get_tam_event_threshold_attribute" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = tam_api->get_tam_event_threshold_attribute((sai_object_id_t)tam_event_threshold_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_tam_event_threshold_attributes(sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  void sai_thrift_set_tam_event_threshold_attribute(const sai_thrift_object_id_t tam_event_threshold_oid, const sai_thrift_attribute_t& attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t sai_attr;

    sai_tam_api_t *tam_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_TAM), (void **)&tam_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);

    sai_thrift_parse_tam_event_threshold_attributes(attr_vec, &sai_attr);

    if (tam_api->set_tam_event_threshold_attribute == (void *)0) {
        std::cerr << "NULL ptr: tam_api->set_tam_event_threshold_attribute" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = tam_api->set_tam_event_threshold_attribute((sai_object_id_t)tam_event_threshold_oid, &sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  sai_thrift_object_id_t sai_thrift_create_tam_int(const std::vector<sai_thrift_attribute_t> & attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t tam_int_oid_out = SAI_NULL_OBJECT_ID;

    sai_tam_api_t *tam_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_TAM), (void **)&tam_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_tam_int_attributes(attr_list, sai_attr_list);

    if (tam_api->create_tam_int == (void *)0) {
        std::cerr << "NULL ptr: tam_api->create_tam_int" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = tam_api->create_tam_int(&tam_int_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);    return tam_int_oid_out;
  }

  void sai_thrift_remove_tam_int(const sai_thrift_object_id_t tam_int_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_tam_api_t *tam_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_TAM), (void **)&tam_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    if (tam_api->remove_tam_int == (void *)0) {
        std::cerr << "NULL ptr: tam_api->remove_tam_int" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = tam_api->remove_tam_int((sai_object_id_t)tam_int_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_get_tam_int_attribute(sai_thrift_attribute_list_t& attr_list_out, const sai_thrift_object_id_t tam_int_oid, const sai_thrift_attribute_list_t& attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_tam_api_t *tam_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_TAM), (void **)&tam_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    else {
      return;
    }


    const std::vector<sai_thrift_attribute_t> &attr_list_vec = attr_list.attr_list;

    sai_thrift_parse_tam_int_attributes(attr_list_vec, sai_attr_list);

    if (tam_api->get_tam_int_attribute == (void *)0) {
        std::cerr << "NULL ptr: tam_api->get_tam_int_attribute" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = tam_api->get_tam_int_attribute((sai_object_id_t)tam_int_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_tam_int_attributes(sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  void sai_thrift_set_tam_int_attribute(const sai_thrift_object_id_t tam_int_oid, const sai_thrift_attribute_t& attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t sai_attr;

    sai_tam_api_t *tam_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_TAM), (void **)&tam_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);

    sai_thrift_parse_tam_int_attributes(attr_vec, &sai_attr);

    if (tam_api->set_tam_int_attribute == (void *)0) {
        std::cerr << "NULL ptr: tam_api->set_tam_int_attribute" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = tam_api->set_tam_int_attribute((sai_object_id_t)tam_int_oid, &sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  sai_thrift_object_id_t sai_thrift_create_tam_tel_type(const std::vector<sai_thrift_attribute_t> & attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t tam_tel_type_oid_out = SAI_NULL_OBJECT_ID;

    sai_tam_api_t *tam_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_TAM), (void **)&tam_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_tam_tel_type_attributes(attr_list, sai_attr_list);

    if (tam_api->create_tam_tel_type == (void *)0) {
        std::cerr << "NULL ptr: tam_api->create_tam_tel_type" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = tam_api->create_tam_tel_type(&tam_tel_type_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);    return tam_tel_type_oid_out;
  }

  void sai_thrift_remove_tam_tel_type(const sai_thrift_object_id_t tam_tel_type_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_tam_api_t *tam_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_TAM), (void **)&tam_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    if (tam_api->remove_tam_tel_type == (void *)0) {
        std::cerr << "NULL ptr: tam_api->remove_tam_tel_type" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = tam_api->remove_tam_tel_type((sai_object_id_t)tam_tel_type_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_get_tam_tel_type_attribute(sai_thrift_attribute_list_t& attr_list_out, const sai_thrift_object_id_t tam_tel_type_oid, const sai_thrift_attribute_list_t& attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_tam_api_t *tam_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_TAM), (void **)&tam_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    else {
      return;
    }


    const std::vector<sai_thrift_attribute_t> &attr_list_vec = attr_list.attr_list;

    sai_thrift_parse_tam_tel_type_attributes(attr_list_vec, sai_attr_list);

    if (tam_api->get_tam_tel_type_attribute == (void *)0) {
        std::cerr << "NULL ptr: tam_api->get_tam_tel_type_attribute" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = tam_api->get_tam_tel_type_attribute((sai_object_id_t)tam_tel_type_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_tam_tel_type_attributes(sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  void sai_thrift_set_tam_tel_type_attribute(const sai_thrift_object_id_t tam_tel_type_oid, const sai_thrift_attribute_t& attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t sai_attr;

    sai_tam_api_t *tam_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_TAM), (void **)&tam_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);

    sai_thrift_parse_tam_tel_type_attributes(attr_vec, &sai_attr);

    if (tam_api->set_tam_tel_type_attribute == (void *)0) {
        std::cerr << "NULL ptr: tam_api->set_tam_tel_type_attribute" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = tam_api->set_tam_tel_type_attribute((sai_object_id_t)tam_tel_type_oid, &sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  sai_thrift_object_id_t sai_thrift_create_tam_report(const std::vector<sai_thrift_attribute_t> & attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t tam_report_oid_out = SAI_NULL_OBJECT_ID;

    sai_tam_api_t *tam_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_TAM), (void **)&tam_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_tam_report_attributes(attr_list, sai_attr_list);

    if (tam_api->create_tam_report == (void *)0) {
        std::cerr << "NULL ptr: tam_api->create_tam_report" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = tam_api->create_tam_report(&tam_report_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);    return tam_report_oid_out;
  }

  void sai_thrift_remove_tam_report(const sai_thrift_object_id_t tam_report_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_tam_api_t *tam_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_TAM), (void **)&tam_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    if (tam_api->remove_tam_report == (void *)0) {
        std::cerr << "NULL ptr: tam_api->remove_tam_report" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = tam_api->remove_tam_report((sai_object_id_t)tam_report_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_get_tam_report_attribute(sai_thrift_attribute_list_t& attr_list_out, const sai_thrift_object_id_t tam_report_oid, const sai_thrift_attribute_list_t& attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_tam_api_t *tam_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_TAM), (void **)&tam_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    else {
      return;
    }


    const std::vector<sai_thrift_attribute_t> &attr_list_vec = attr_list.attr_list;

    sai_thrift_parse_tam_report_attributes(attr_list_vec, sai_attr_list);

    if (tam_api->get_tam_report_attribute == (void *)0) {
        std::cerr << "NULL ptr: tam_api->get_tam_report_attribute" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = tam_api->get_tam_report_attribute((sai_object_id_t)tam_report_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_tam_report_attributes(sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  void sai_thrift_set_tam_report_attribute(const sai_thrift_object_id_t tam_report_oid, const sai_thrift_attribute_t& attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t sai_attr;

    sai_tam_api_t *tam_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_TAM), (void **)&tam_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);

    sai_thrift_parse_tam_report_attributes(attr_vec, &sai_attr);

    if (tam_api->set_tam_report_attribute == (void *)0) {
        std::cerr << "NULL ptr: tam_api->set_tam_report_attribute" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = tam_api->set_tam_report_attribute((sai_object_id_t)tam_report_oid, &sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  sai_thrift_object_id_t sai_thrift_create_tam_telemetry(const std::vector<sai_thrift_attribute_t> & attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t tam_telemetry_oid_out = SAI_NULL_OBJECT_ID;

    sai_tam_api_t *tam_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_TAM), (void **)&tam_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_tam_telemetry_attributes(attr_list, sai_attr_list);

    if (tam_api->create_tam_telemetry == (void *)0) {
        std::cerr << "NULL ptr: tam_api->create_tam_telemetry" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = tam_api->create_tam_telemetry(&tam_telemetry_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);    return tam_telemetry_oid_out;
  }

  void sai_thrift_remove_tam_telemetry(const sai_thrift_object_id_t tam_telemetry_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_tam_api_t *tam_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_TAM), (void **)&tam_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    if (tam_api->remove_tam_telemetry == (void *)0) {
        std::cerr << "NULL ptr: tam_api->remove_tam_telemetry" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = tam_api->remove_tam_telemetry((sai_object_id_t)tam_telemetry_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_get_tam_telemetry_attribute(sai_thrift_attribute_list_t& attr_list_out, const sai_thrift_object_id_t tam_telemetry_oid, const sai_thrift_attribute_list_t& attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_tam_api_t *tam_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_TAM), (void **)&tam_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    else {
      return;
    }


    const std::vector<sai_thrift_attribute_t> &attr_list_vec = attr_list.attr_list;

    sai_thrift_parse_tam_telemetry_attributes(attr_list_vec, sai_attr_list);

    if (tam_api->get_tam_telemetry_attribute == (void *)0) {
        std::cerr << "NULL ptr: tam_api->get_tam_telemetry_attribute" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = tam_api->get_tam_telemetry_attribute((sai_object_id_t)tam_telemetry_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_tam_telemetry_attributes(sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  void sai_thrift_set_tam_telemetry_attribute(const sai_thrift_object_id_t tam_telemetry_oid, const sai_thrift_attribute_t& attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t sai_attr;

    sai_tam_api_t *tam_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_TAM), (void **)&tam_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);

    sai_thrift_parse_tam_telemetry_attributes(attr_vec, &sai_attr);

    if (tam_api->set_tam_telemetry_attribute == (void *)0) {
        std::cerr << "NULL ptr: tam_api->set_tam_telemetry_attribute" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = tam_api->set_tam_telemetry_attribute((sai_object_id_t)tam_telemetry_oid, &sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  sai_thrift_object_id_t sai_thrift_create_tam_transport(const std::vector<sai_thrift_attribute_t> & attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t tam_transport_oid_out = SAI_NULL_OBJECT_ID;

    sai_tam_api_t *tam_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_TAM), (void **)&tam_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_tam_transport_attributes(attr_list, sai_attr_list);

    if (tam_api->create_tam_transport == (void *)0) {
        std::cerr << "NULL ptr: tam_api->create_tam_transport" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = tam_api->create_tam_transport(&tam_transport_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);    return tam_transport_oid_out;
  }

  void sai_thrift_remove_tam_transport(const sai_thrift_object_id_t tam_transport_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_tam_api_t *tam_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_TAM), (void **)&tam_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    if (tam_api->remove_tam_transport == (void *)0) {
        std::cerr << "NULL ptr: tam_api->remove_tam_transport" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = tam_api->remove_tam_transport((sai_object_id_t)tam_transport_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_get_tam_transport_attribute(sai_thrift_attribute_list_t& attr_list_out, const sai_thrift_object_id_t tam_transport_oid, const sai_thrift_attribute_list_t& attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_tam_api_t *tam_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_TAM), (void **)&tam_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    else {
      return;
    }


    const std::vector<sai_thrift_attribute_t> &attr_list_vec = attr_list.attr_list;

    sai_thrift_parse_tam_transport_attributes(attr_list_vec, sai_attr_list);

    if (tam_api->get_tam_transport_attribute == (void *)0) {
        std::cerr << "NULL ptr: tam_api->get_tam_transport_attribute" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = tam_api->get_tam_transport_attribute((sai_object_id_t)tam_transport_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_tam_transport_attributes(sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  void sai_thrift_set_tam_transport_attribute(const sai_thrift_object_id_t tam_transport_oid, const sai_thrift_attribute_t& attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t sai_attr;

    sai_tam_api_t *tam_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_TAM), (void **)&tam_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);

    sai_thrift_parse_tam_transport_attributes(attr_vec, &sai_attr);

    if (tam_api->set_tam_transport_attribute == (void *)0) {
        std::cerr << "NULL ptr: tam_api->set_tam_transport_attribute" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = tam_api->set_tam_transport_attribute((sai_object_id_t)tam_transport_oid, &sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  sai_thrift_object_id_t sai_thrift_create_tam_collector(const std::vector<sai_thrift_attribute_t> & attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t tam_collector_oid_out = SAI_NULL_OBJECT_ID;

    sai_tam_api_t *tam_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_TAM), (void **)&tam_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_tam_collector_attributes(attr_list, sai_attr_list);

    if (tam_api->create_tam_collector == (void *)0) {
        std::cerr << "NULL ptr: tam_api->create_tam_collector" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = tam_api->create_tam_collector(&tam_collector_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);    return tam_collector_oid_out;
  }

  void sai_thrift_remove_tam_collector(const sai_thrift_object_id_t tam_collector_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_tam_api_t *tam_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_TAM), (void **)&tam_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    if (tam_api->remove_tam_collector == (void *)0) {
        std::cerr << "NULL ptr: tam_api->remove_tam_collector" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = tam_api->remove_tam_collector((sai_object_id_t)tam_collector_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_get_tam_collector_attribute(sai_thrift_attribute_list_t& attr_list_out, const sai_thrift_object_id_t tam_collector_oid, const sai_thrift_attribute_list_t& attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_tam_api_t *tam_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_TAM), (void **)&tam_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    else {
      return;
    }


    const std::vector<sai_thrift_attribute_t> &attr_list_vec = attr_list.attr_list;

    sai_thrift_parse_tam_collector_attributes(attr_list_vec, sai_attr_list);

    if (tam_api->get_tam_collector_attribute == (void *)0) {
        std::cerr << "NULL ptr: tam_api->get_tam_collector_attribute" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = tam_api->get_tam_collector_attribute((sai_object_id_t)tam_collector_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_tam_collector_attributes(sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  void sai_thrift_set_tam_collector_attribute(const sai_thrift_object_id_t tam_collector_oid, const sai_thrift_attribute_t& attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t sai_attr;

    sai_tam_api_t *tam_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_TAM), (void **)&tam_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);

    sai_thrift_parse_tam_collector_attributes(attr_vec, &sai_attr);

    if (tam_api->set_tam_collector_attribute == (void *)0) {
        std::cerr << "NULL ptr: tam_api->set_tam_collector_attribute" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = tam_api->set_tam_collector_attribute((sai_object_id_t)tam_collector_oid, &sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  sai_thrift_object_id_t sai_thrift_create_tam_event_action(const std::vector<sai_thrift_attribute_t> & attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t tam_event_action_oid_out = SAI_NULL_OBJECT_ID;

    sai_tam_api_t *tam_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_TAM), (void **)&tam_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_tam_event_action_attributes(attr_list, sai_attr_list);

    if (tam_api->create_tam_event_action == (void *)0) {
        std::cerr << "NULL ptr: tam_api->create_tam_event_action" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = tam_api->create_tam_event_action(&tam_event_action_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);    return tam_event_action_oid_out;
  }

  void sai_thrift_remove_tam_event_action(const sai_thrift_object_id_t tam_event_action_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_tam_api_t *tam_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_TAM), (void **)&tam_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    if (tam_api->remove_tam_event_action == (void *)0) {
        std::cerr << "NULL ptr: tam_api->remove_tam_event_action" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = tam_api->remove_tam_event_action((sai_object_id_t)tam_event_action_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_get_tam_event_action_attribute(sai_thrift_attribute_list_t& attr_list_out, const sai_thrift_object_id_t tam_event_action_oid, const sai_thrift_attribute_list_t& attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_tam_api_t *tam_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_TAM), (void **)&tam_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    else {
      return;
    }


    const std::vector<sai_thrift_attribute_t> &attr_list_vec = attr_list.attr_list;

    sai_thrift_parse_tam_event_action_attributes(attr_list_vec, sai_attr_list);

    if (tam_api->get_tam_event_action_attribute == (void *)0) {
        std::cerr << "NULL ptr: tam_api->get_tam_event_action_attribute" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = tam_api->get_tam_event_action_attribute((sai_object_id_t)tam_event_action_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_tam_event_action_attributes(sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  void sai_thrift_set_tam_event_action_attribute(const sai_thrift_object_id_t tam_event_action_oid, const sai_thrift_attribute_t& attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t sai_attr;

    sai_tam_api_t *tam_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_TAM), (void **)&tam_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);

    sai_thrift_parse_tam_event_action_attributes(attr_vec, &sai_attr);

    if (tam_api->set_tam_event_action_attribute == (void *)0) {
        std::cerr << "NULL ptr: tam_api->set_tam_event_action_attribute" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = tam_api->set_tam_event_action_attribute((sai_object_id_t)tam_event_action_oid, &sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  sai_thrift_object_id_t sai_thrift_create_tam_event(const std::vector<sai_thrift_attribute_t> & attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t tam_event_oid_out = SAI_NULL_OBJECT_ID;

    sai_tam_api_t *tam_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_TAM), (void **)&tam_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_tam_event_attributes(attr_list, sai_attr_list);

    if (tam_api->create_tam_event == (void *)0) {
        std::cerr << "NULL ptr: tam_api->create_tam_event" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = tam_api->create_tam_event(&tam_event_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);    return tam_event_oid_out;
  }

  void sai_thrift_remove_tam_event(const sai_thrift_object_id_t tam_event_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_tam_api_t *tam_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_TAM), (void **)&tam_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    if (tam_api->remove_tam_event == (void *)0) {
        std::cerr << "NULL ptr: tam_api->remove_tam_event" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = tam_api->remove_tam_event((sai_object_id_t)tam_event_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_get_tam_event_attribute(sai_thrift_attribute_list_t& attr_list_out, const sai_thrift_object_id_t tam_event_oid, const sai_thrift_attribute_list_t& attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_tam_api_t *tam_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_TAM), (void **)&tam_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    else {
      return;
    }


    const std::vector<sai_thrift_attribute_t> &attr_list_vec = attr_list.attr_list;

    sai_thrift_parse_tam_event_attributes(attr_list_vec, sai_attr_list);

    if (tam_api->get_tam_event_attribute == (void *)0) {
        std::cerr << "NULL ptr: tam_api->get_tam_event_attribute" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = tam_api->get_tam_event_attribute((sai_object_id_t)tam_event_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_tam_event_attributes(sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  void sai_thrift_set_tam_event_attribute(const sai_thrift_object_id_t tam_event_oid, const sai_thrift_attribute_t& attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t sai_attr;

    sai_tam_api_t *tam_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_TAM), (void **)&tam_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);

    sai_thrift_parse_tam_event_attributes(attr_vec, &sai_attr);

    if (tam_api->set_tam_event_attribute == (void *)0) {
        std::cerr << "NULL ptr: tam_api->set_tam_event_attribute" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = tam_api->set_tam_event_attribute((sai_object_id_t)tam_event_oid, &sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  sai_thrift_object_id_t sai_thrift_create_tunnel_map(const std::vector<sai_thrift_attribute_t> & attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t tunnel_map_oid_out = SAI_NULL_OBJECT_ID;

    sai_tunnel_api_t *tunnel_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_TUNNEL), (void **)&tunnel_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_tunnel_map_attributes(attr_list, sai_attr_list);

    if (tunnel_api->create_tunnel_map == (void *)0) {
        std::cerr << "NULL ptr: tunnel_api->create_tunnel_map" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = tunnel_api->create_tunnel_map(&tunnel_map_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);    return tunnel_map_oid_out;
  }

  void sai_thrift_remove_tunnel_map(const sai_thrift_object_id_t tunnel_map_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_tunnel_api_t *tunnel_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_TUNNEL), (void **)&tunnel_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    if (tunnel_api->remove_tunnel_map == (void *)0) {
        std::cerr << "NULL ptr: tunnel_api->remove_tunnel_map" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = tunnel_api->remove_tunnel_map((sai_object_id_t)tunnel_map_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_tunnel_map_attribute(const sai_thrift_object_id_t tunnel_map_oid, const sai_thrift_attribute_t& attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t sai_attr;

    sai_tunnel_api_t *tunnel_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_TUNNEL), (void **)&tunnel_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);

    sai_thrift_parse_tunnel_map_attributes(attr_vec, &sai_attr);

    if (tunnel_api->set_tunnel_map_attribute == (void *)0) {
        std::cerr << "NULL ptr: tunnel_api->set_tunnel_map_attribute" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = tunnel_api->set_tunnel_map_attribute((sai_object_id_t)tunnel_map_oid, &sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_get_tunnel_map_attribute(sai_thrift_attribute_list_t& attr_list_out, const sai_thrift_object_id_t tunnel_map_oid, const sai_thrift_attribute_list_t& attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_tunnel_api_t *tunnel_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_TUNNEL), (void **)&tunnel_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    else {
      return;
    }


    const std::vector<sai_thrift_attribute_t> &attr_list_vec = attr_list.attr_list;

    sai_thrift_parse_tunnel_map_attributes(attr_list_vec, sai_attr_list);

    if (tunnel_api->get_tunnel_map_attribute == (void *)0) {
        std::cerr << "NULL ptr: tunnel_api->get_tunnel_map_attribute" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = tunnel_api->get_tunnel_map_attribute((sai_object_id_t)tunnel_map_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_tunnel_map_attributes(sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  sai_thrift_object_id_t sai_thrift_create_tunnel(const std::vector<sai_thrift_attribute_t> & attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t tunnel_oid_out = SAI_NULL_OBJECT_ID;

    sai_tunnel_api_t *tunnel_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_TUNNEL), (void **)&tunnel_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_tunnel_attributes(attr_list, sai_attr_list);

    if (tunnel_api->create_tunnel == (void *)0) {
        std::cerr << "NULL ptr: tunnel_api->create_tunnel" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = tunnel_api->create_tunnel(&tunnel_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);    return tunnel_oid_out;
  }

  void sai_thrift_remove_tunnel(const sai_thrift_object_id_t tunnel_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_tunnel_api_t *tunnel_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_TUNNEL), (void **)&tunnel_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    if (tunnel_api->remove_tunnel == (void *)0) {
        std::cerr << "NULL ptr: tunnel_api->remove_tunnel" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = tunnel_api->remove_tunnel((sai_object_id_t)tunnel_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_tunnel_attribute(const sai_thrift_object_id_t tunnel_oid, const sai_thrift_attribute_t& attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t sai_attr;

    sai_tunnel_api_t *tunnel_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_TUNNEL), (void **)&tunnel_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);

    sai_thrift_parse_tunnel_attributes(attr_vec, &sai_attr);

    if (tunnel_api->set_tunnel_attribute == (void *)0) {
        std::cerr << "NULL ptr: tunnel_api->set_tunnel_attribute" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = tunnel_api->set_tunnel_attribute((sai_object_id_t)tunnel_oid, &sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_get_tunnel_attribute(sai_thrift_attribute_list_t& attr_list_out, const sai_thrift_object_id_t tunnel_oid, const sai_thrift_attribute_list_t& attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_tunnel_api_t *tunnel_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_TUNNEL), (void **)&tunnel_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    else {
      return;
    }


    const std::vector<sai_thrift_attribute_t> &attr_list_vec = attr_list.attr_list;

    sai_thrift_parse_tunnel_attributes(attr_list_vec, sai_attr_list);

    if (tunnel_api->get_tunnel_attribute == (void *)0) {
        std::cerr << "NULL ptr: tunnel_api->get_tunnel_attribute" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = tunnel_api->get_tunnel_attribute((sai_object_id_t)tunnel_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_tunnel_attributes(sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  void sai_thrift_get_tunnel_stats(std::vector<sai_thrift_uint64_t> & counters_out, const sai_thrift_object_id_t tunnel_oid, const std::vector<sai_thrift_stat_id_t> & counter_ids) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_tunnel_api_t *tunnel_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_TUNNEL), (void **)&tunnel_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_stat_id_t *sai_counter_ids = NULL;
    uint32_t number_of_counters = counter_ids.size();

    if (number_of_counters != 0) {
      sai_counter_ids = (sai_stat_id_t *)malloc(sizeof(sai_stat_id_t) * number_of_counters);
    }
    else {
      return;
    }


    std::vector<sai_thrift_stat_id_t>::const_iterator it = counter_ids.begin();
    for (uint32_t i = 0; i < counter_ids.size(); i++, it++) {
      sai_counter_ids[i] = (sai_stat_id_t)*it;
    }

    uint64_t *sai_counters = NULL;
    if (number_of_counters != 0) {
      sai_counters = (uint64_t *)malloc(sizeof(uint64_t) * number_of_counters);
    }

    if (tunnel_api->get_tunnel_stats == (void *)0) {
        std::cerr << "NULL ptr: tunnel_api->get_tunnel_stats" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = tunnel_api->get_tunnel_stats((sai_object_id_t)tunnel_oid, number_of_counters, sai_counter_ids, sai_counters);

    // sai_adapter always takes all tunnel stats. Since some of them may be
    // not supported, SAI_STATUS_INVALID_PARAMETER should not be raised.
    if (status != SAI_STATUS_SUCCESS && status != SAI_STATUS_INVALID_PARAMETER) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_counter_ids);
    for (uint32_t i = 0; i < (uint32_t)number_of_counters; i++) {
      counters_out.push_back((sai_thrift_uint64_t)sai_counters[i]);
    }
    free(sai_counters);
    return;
  }

  void sai_thrift_get_tunnel_stats_ext(std::vector<sai_thrift_uint64_t> & counters_out, const sai_thrift_object_id_t tunnel_oid, const std::vector<sai_thrift_stat_id_t> & counter_ids, const sai_thrift_stats_mode_t mode) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_tunnel_api_t *tunnel_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_TUNNEL), (void **)&tunnel_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_stat_id_t *sai_counter_ids = NULL;
    uint32_t number_of_counters = counter_ids.size();

    if (number_of_counters != 0) {
      sai_counter_ids = (sai_stat_id_t *)malloc(sizeof(sai_stat_id_t) * number_of_counters);
    }
    else {
      return;
    }


    std::vector<sai_thrift_stat_id_t>::const_iterator it = counter_ids.begin();
    for (uint32_t i = 0; i < counter_ids.size(); i++, it++) {
      sai_counter_ids[i] = (sai_stat_id_t)*it;
    }

    uint64_t *sai_counters = NULL;
    if (number_of_counters != 0) {
      sai_counters = (uint64_t *)malloc(sizeof(uint64_t) * number_of_counters);
    }

    if (tunnel_api->get_tunnel_stats_ext == (void *)0) {
        std::cerr << "NULL ptr: tunnel_api->get_tunnel_stats_ext" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = tunnel_api->get_tunnel_stats_ext((sai_object_id_t)tunnel_oid, number_of_counters, sai_counter_ids, (sai_stats_mode_t)mode, sai_counters);

    // sai_adapter always takes all tunnel stats. Since some of them may be
    // not supported, SAI_STATUS_INVALID_PARAMETER should not be raised.
    if (status != SAI_STATUS_SUCCESS && status != SAI_STATUS_INVALID_PARAMETER) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_counter_ids);
    for (uint32_t i = 0; i < (uint32_t)number_of_counters; i++) {
      counters_out.push_back((sai_thrift_uint64_t)sai_counters[i]);
    }
    free(sai_counters);
    return;
  }

  void sai_thrift_clear_tunnel_stats(const sai_thrift_object_id_t tunnel_oid, const std::vector<sai_thrift_stat_id_t> & counter_ids) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_tunnel_api_t *tunnel_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_TUNNEL), (void **)&tunnel_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_stat_id_t *sai_counter_ids = NULL;
    uint32_t number_of_counters = counter_ids.size();

    if (number_of_counters != 0) {
      sai_counter_ids = (sai_stat_id_t *)malloc(sizeof(sai_stat_id_t) * number_of_counters);
    }
    else {
      return;
    }


    std::vector<sai_thrift_stat_id_t>::const_iterator it = counter_ids.begin();
    for (uint32_t i = 0; i < counter_ids.size(); i++, it++) {
      sai_counter_ids[i] = (sai_stat_id_t)*it;
    }

    if (tunnel_api->clear_tunnel_stats == (void *)0) {
        std::cerr << "NULL ptr: tunnel_api->clear_tunnel_stats" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = tunnel_api->clear_tunnel_stats((sai_object_id_t)tunnel_oid, number_of_counters, sai_counter_ids);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_counter_ids);
    return;
  }

  sai_thrift_object_id_t sai_thrift_create_tunnel_term_table_entry(const std::vector<sai_thrift_attribute_t> & attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t tunnel_term_table_entry_oid_out = SAI_NULL_OBJECT_ID;

    sai_tunnel_api_t *tunnel_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_TUNNEL), (void **)&tunnel_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_tunnel_term_table_entry_attributes(attr_list, sai_attr_list);

    if (tunnel_api->create_tunnel_term_table_entry == (void *)0) {
        std::cerr << "NULL ptr: tunnel_api->create_tunnel_term_table_entry" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = tunnel_api->create_tunnel_term_table_entry(&tunnel_term_table_entry_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);    return tunnel_term_table_entry_oid_out;
  }

  void sai_thrift_remove_tunnel_term_table_entry(const sai_thrift_object_id_t tunnel_term_table_entry_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_tunnel_api_t *tunnel_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_TUNNEL), (void **)&tunnel_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    if (tunnel_api->remove_tunnel_term_table_entry == (void *)0) {
        std::cerr << "NULL ptr: tunnel_api->remove_tunnel_term_table_entry" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = tunnel_api->remove_tunnel_term_table_entry((sai_object_id_t)tunnel_term_table_entry_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_tunnel_term_table_entry_attribute(const sai_thrift_object_id_t tunnel_term_table_entry_oid, const sai_thrift_attribute_t& attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t sai_attr;

    sai_tunnel_api_t *tunnel_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_TUNNEL), (void **)&tunnel_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);

    sai_thrift_parse_tunnel_term_table_entry_attributes(attr_vec, &sai_attr);

    if (tunnel_api->set_tunnel_term_table_entry_attribute == (void *)0) {
        std::cerr << "NULL ptr: tunnel_api->set_tunnel_term_table_entry_attribute" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = tunnel_api->set_tunnel_term_table_entry_attribute((sai_object_id_t)tunnel_term_table_entry_oid, &sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_get_tunnel_term_table_entry_attribute(sai_thrift_attribute_list_t& attr_list_out, const sai_thrift_object_id_t tunnel_term_table_entry_oid, const sai_thrift_attribute_list_t& attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_tunnel_api_t *tunnel_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_TUNNEL), (void **)&tunnel_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    else {
      return;
    }


    const std::vector<sai_thrift_attribute_t> &attr_list_vec = attr_list.attr_list;

    sai_thrift_parse_tunnel_term_table_entry_attributes(attr_list_vec, sai_attr_list);

    if (tunnel_api->get_tunnel_term_table_entry_attribute == (void *)0) {
        std::cerr << "NULL ptr: tunnel_api->get_tunnel_term_table_entry_attribute" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = tunnel_api->get_tunnel_term_table_entry_attribute((sai_object_id_t)tunnel_term_table_entry_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_tunnel_term_table_entry_attributes(sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  sai_thrift_object_id_t sai_thrift_create_tunnel_map_entry(const std::vector<sai_thrift_attribute_t> & attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t tunnel_map_entry_oid_out = SAI_NULL_OBJECT_ID;

    sai_tunnel_api_t *tunnel_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_TUNNEL), (void **)&tunnel_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_tunnel_map_entry_attributes(attr_list, sai_attr_list);

    if (tunnel_api->create_tunnel_map_entry == (void *)0) {
        std::cerr << "NULL ptr: tunnel_api->create_tunnel_map_entry" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = tunnel_api->create_tunnel_map_entry(&tunnel_map_entry_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);    return tunnel_map_entry_oid_out;
  }

  void sai_thrift_remove_tunnel_map_entry(const sai_thrift_object_id_t tunnel_map_entry_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_tunnel_api_t *tunnel_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_TUNNEL), (void **)&tunnel_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    if (tunnel_api->remove_tunnel_map_entry == (void *)0) {
        std::cerr << "NULL ptr: tunnel_api->remove_tunnel_map_entry" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = tunnel_api->remove_tunnel_map_entry((sai_object_id_t)tunnel_map_entry_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_tunnel_map_entry_attribute(const sai_thrift_object_id_t tunnel_map_entry_oid, const sai_thrift_attribute_t& attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t sai_attr;

    sai_tunnel_api_t *tunnel_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_TUNNEL), (void **)&tunnel_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);

    sai_thrift_parse_tunnel_map_entry_attributes(attr_vec, &sai_attr);

    if (tunnel_api->set_tunnel_map_entry_attribute == (void *)0) {
        std::cerr << "NULL ptr: tunnel_api->set_tunnel_map_entry_attribute" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = tunnel_api->set_tunnel_map_entry_attribute((sai_object_id_t)tunnel_map_entry_oid, &sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_get_tunnel_map_entry_attribute(sai_thrift_attribute_list_t& attr_list_out, const sai_thrift_object_id_t tunnel_map_entry_oid, const sai_thrift_attribute_list_t& attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_tunnel_api_t *tunnel_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_TUNNEL), (void **)&tunnel_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    else {
      return;
    }


    const std::vector<sai_thrift_attribute_t> &attr_list_vec = attr_list.attr_list;

    sai_thrift_parse_tunnel_map_entry_attributes(attr_list_vec, sai_attr_list);

    if (tunnel_api->get_tunnel_map_entry_attribute == (void *)0) {
        std::cerr << "NULL ptr: tunnel_api->get_tunnel_map_entry_attribute" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = tunnel_api->get_tunnel_map_entry_attribute((sai_object_id_t)tunnel_map_entry_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_tunnel_map_entry_attributes(sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  sai_thrift_object_id_t sai_thrift_create_udf(const std::vector<sai_thrift_attribute_t> & attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t udf_oid_out = SAI_NULL_OBJECT_ID;

    sai_udf_api_t *udf_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_UDF), (void **)&udf_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_udf_attributes(attr_list, sai_attr_list);

    if (udf_api->create_udf == (void *)0) {
        std::cerr << "NULL ptr: udf_api->create_udf" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = udf_api->create_udf(&udf_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);    return udf_oid_out;
  }

  void sai_thrift_remove_udf(const sai_thrift_object_id_t udf_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_udf_api_t *udf_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_UDF), (void **)&udf_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    if (udf_api->remove_udf == (void *)0) {
        std::cerr << "NULL ptr: udf_api->remove_udf" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = udf_api->remove_udf((sai_object_id_t)udf_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_udf_attribute(const sai_thrift_object_id_t udf_oid, const sai_thrift_attribute_t& attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t sai_attr;

    sai_udf_api_t *udf_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_UDF), (void **)&udf_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);

    sai_thrift_parse_udf_attributes(attr_vec, &sai_attr);

    if (udf_api->set_udf_attribute == (void *)0) {
        std::cerr << "NULL ptr: udf_api->set_udf_attribute" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = udf_api->set_udf_attribute((sai_object_id_t)udf_oid, &sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_get_udf_attribute(sai_thrift_attribute_list_t& attr_list_out, const sai_thrift_object_id_t udf_oid, const sai_thrift_attribute_list_t& attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_udf_api_t *udf_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_UDF), (void **)&udf_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    else {
      return;
    }


    const std::vector<sai_thrift_attribute_t> &attr_list_vec = attr_list.attr_list;

    sai_thrift_parse_udf_attributes(attr_list_vec, sai_attr_list);

    if (udf_api->get_udf_attribute == (void *)0) {
        std::cerr << "NULL ptr: udf_api->get_udf_attribute" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = udf_api->get_udf_attribute((sai_object_id_t)udf_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_udf_attributes(sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  sai_thrift_object_id_t sai_thrift_create_udf_match(const std::vector<sai_thrift_attribute_t> & attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t udf_match_oid_out = SAI_NULL_OBJECT_ID;

    sai_udf_api_t *udf_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_UDF), (void **)&udf_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_udf_match_attributes(attr_list, sai_attr_list);

    if (udf_api->create_udf_match == (void *)0) {
        std::cerr << "NULL ptr: udf_api->create_udf_match" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = udf_api->create_udf_match(&udf_match_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);    return udf_match_oid_out;
  }

  void sai_thrift_remove_udf_match(const sai_thrift_object_id_t udf_match_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_udf_api_t *udf_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_UDF), (void **)&udf_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    if (udf_api->remove_udf_match == (void *)0) {
        std::cerr << "NULL ptr: udf_api->remove_udf_match" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = udf_api->remove_udf_match((sai_object_id_t)udf_match_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_udf_match_attribute(const sai_thrift_object_id_t udf_match_oid, const sai_thrift_attribute_t& attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t sai_attr;

    sai_udf_api_t *udf_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_UDF), (void **)&udf_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);

    sai_thrift_parse_udf_match_attributes(attr_vec, &sai_attr);

    if (udf_api->set_udf_match_attribute == (void *)0) {
        std::cerr << "NULL ptr: udf_api->set_udf_match_attribute" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = udf_api->set_udf_match_attribute((sai_object_id_t)udf_match_oid, &sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_get_udf_match_attribute(sai_thrift_attribute_list_t& attr_list_out, const sai_thrift_object_id_t udf_match_oid, const sai_thrift_attribute_list_t& attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_udf_api_t *udf_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_UDF), (void **)&udf_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    else {
      return;
    }


    const std::vector<sai_thrift_attribute_t> &attr_list_vec = attr_list.attr_list;

    sai_thrift_parse_udf_match_attributes(attr_list_vec, sai_attr_list);

    if (udf_api->get_udf_match_attribute == (void *)0) {
        std::cerr << "NULL ptr: udf_api->get_udf_match_attribute" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = udf_api->get_udf_match_attribute((sai_object_id_t)udf_match_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_udf_match_attributes(sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  sai_thrift_object_id_t sai_thrift_create_udf_group(const std::vector<sai_thrift_attribute_t> & attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t udf_group_oid_out = SAI_NULL_OBJECT_ID;

    sai_udf_api_t *udf_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_UDF), (void **)&udf_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_udf_group_attributes(attr_list, sai_attr_list);

    if (udf_api->create_udf_group == (void *)0) {
        std::cerr << "NULL ptr: udf_api->create_udf_group" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = udf_api->create_udf_group(&udf_group_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);    return udf_group_oid_out;
  }

  void sai_thrift_remove_udf_group(const sai_thrift_object_id_t udf_group_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_udf_api_t *udf_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_UDF), (void **)&udf_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    if (udf_api->remove_udf_group == (void *)0) {
        std::cerr << "NULL ptr: udf_api->remove_udf_group" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = udf_api->remove_udf_group((sai_object_id_t)udf_group_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_udf_group_attribute(const sai_thrift_object_id_t udf_group_oid, const sai_thrift_attribute_t& attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t sai_attr;

    sai_udf_api_t *udf_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_UDF), (void **)&udf_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);

    sai_thrift_parse_udf_group_attributes(attr_vec, &sai_attr);

    if (udf_api->set_udf_group_attribute == (void *)0) {
        std::cerr << "NULL ptr: udf_api->set_udf_group_attribute" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = udf_api->set_udf_group_attribute((sai_object_id_t)udf_group_oid, &sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_get_udf_group_attribute(sai_thrift_attribute_list_t& attr_list_out, const sai_thrift_object_id_t udf_group_oid, const sai_thrift_attribute_list_t& attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_udf_api_t *udf_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_UDF), (void **)&udf_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    else {
      return;
    }


    const std::vector<sai_thrift_attribute_t> &attr_list_vec = attr_list.attr_list;

    sai_thrift_parse_udf_group_attributes(attr_list_vec, sai_attr_list);

    if (udf_api->get_udf_group_attribute == (void *)0) {
        std::cerr << "NULL ptr: udf_api->get_udf_group_attribute" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = udf_api->get_udf_group_attribute((sai_object_id_t)udf_group_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_udf_group_attributes(sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  sai_thrift_object_id_t sai_thrift_create_virtual_router(const std::vector<sai_thrift_attribute_t> & attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t virtual_router_oid_out = SAI_NULL_OBJECT_ID;

    sai_virtualrouter_api_t *virtualrouter_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_VIRTUALROUTER), (void **)&virtualrouter_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_virtual_router_attributes(attr_list, sai_attr_list);

    if (virtualrouter_api->create_virtual_router == (void *)0) {
        std::cerr << "NULL ptr: virtualrouter_api->create_virtual_router" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = virtualrouter_api->create_virtual_router(&virtual_router_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);    return virtual_router_oid_out;
  }

  void sai_thrift_remove_virtual_router(const sai_thrift_object_id_t virtual_router_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_virtualrouter_api_t *virtualrouter_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_VIRTUALROUTER), (void **)&virtualrouter_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    if (virtualrouter_api->remove_virtual_router == (void *)0) {
        std::cerr << "NULL ptr: virtualrouter_api->remove_virtual_router" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = virtualrouter_api->remove_virtual_router((sai_object_id_t)virtual_router_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_virtual_router_attribute(const sai_thrift_object_id_t virtual_router_oid, const sai_thrift_attribute_t& attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t sai_attr;

    sai_virtualrouter_api_t *virtualrouter_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_VIRTUALROUTER), (void **)&virtualrouter_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);

    sai_thrift_parse_virtual_router_attributes(attr_vec, &sai_attr);

    if (virtualrouter_api->set_virtual_router_attribute == (void *)0) {
        std::cerr << "NULL ptr: virtualrouter_api->set_virtual_router_attribute" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = virtualrouter_api->set_virtual_router_attribute((sai_object_id_t)virtual_router_oid, &sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_get_virtual_router_attribute(sai_thrift_attribute_list_t& attr_list_out, const sai_thrift_object_id_t virtual_router_oid, const sai_thrift_attribute_list_t& attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_virtualrouter_api_t *virtualrouter_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_VIRTUALROUTER), (void **)&virtualrouter_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    else {
      return;
    }


    const std::vector<sai_thrift_attribute_t> &attr_list_vec = attr_list.attr_list;

    sai_thrift_parse_virtual_router_attributes(attr_list_vec, sai_attr_list);

    if (virtualrouter_api->get_virtual_router_attribute == (void *)0) {
        std::cerr << "NULL ptr: virtualrouter_api->get_virtual_router_attribute" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = virtualrouter_api->get_virtual_router_attribute((sai_object_id_t)virtual_router_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_virtual_router_attributes(sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  sai_thrift_object_id_t sai_thrift_create_vlan(const std::vector<sai_thrift_attribute_t> & attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t vlan_oid_out = SAI_NULL_OBJECT_ID;

    sai_vlan_api_t *vlan_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_VLAN), (void **)&vlan_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_vlan_attributes(attr_list, sai_attr_list);

    if (vlan_api->create_vlan == (void *)0) {
        std::cerr << "NULL ptr: vlan_api->create_vlan" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = vlan_api->create_vlan(&vlan_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);    return vlan_oid_out;
  }

  void sai_thrift_remove_vlan(const sai_thrift_object_id_t vlan_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_vlan_api_t *vlan_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_VLAN), (void **)&vlan_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    if (vlan_api->remove_vlan == (void *)0) {
        std::cerr << "NULL ptr: vlan_api->remove_vlan" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = vlan_api->remove_vlan((sai_object_id_t)vlan_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_vlan_attribute(const sai_thrift_object_id_t vlan_oid, const sai_thrift_attribute_t& attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t sai_attr;

    sai_vlan_api_t *vlan_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_VLAN), (void **)&vlan_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);

    sai_thrift_parse_vlan_attributes(attr_vec, &sai_attr);

    if (vlan_api->set_vlan_attribute == (void *)0) {
        std::cerr << "NULL ptr: vlan_api->set_vlan_attribute" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = vlan_api->set_vlan_attribute((sai_object_id_t)vlan_oid, &sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_get_vlan_attribute(sai_thrift_attribute_list_t& attr_list_out, const sai_thrift_object_id_t vlan_oid, const sai_thrift_attribute_list_t& attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_vlan_api_t *vlan_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_VLAN), (void **)&vlan_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    else {
      return;
    }


    const std::vector<sai_thrift_attribute_t> &attr_list_vec = attr_list.attr_list;

    sai_thrift_parse_vlan_attributes(attr_list_vec, sai_attr_list);

    if (vlan_api->get_vlan_attribute == (void *)0) {
        std::cerr << "NULL ptr: vlan_api->get_vlan_attribute" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = vlan_api->get_vlan_attribute((sai_object_id_t)vlan_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_vlan_attributes(sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  sai_thrift_object_id_t sai_thrift_create_vlan_member(const std::vector<sai_thrift_attribute_t> & attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t vlan_member_oid_out = SAI_NULL_OBJECT_ID;

    sai_vlan_api_t *vlan_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_VLAN), (void **)&vlan_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_vlan_member_attributes(attr_list, sai_attr_list);

    if (vlan_api->create_vlan_member == (void *)0) {
        std::cerr << "NULL ptr: vlan_api->create_vlan_member" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = vlan_api->create_vlan_member(&vlan_member_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);    return vlan_member_oid_out;
  }

  void sai_thrift_remove_vlan_member(const sai_thrift_object_id_t vlan_member_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_vlan_api_t *vlan_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_VLAN), (void **)&vlan_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    if (vlan_api->remove_vlan_member == (void *)0) {
        std::cerr << "NULL ptr: vlan_api->remove_vlan_member" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = vlan_api->remove_vlan_member((sai_object_id_t)vlan_member_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_vlan_member_attribute(const sai_thrift_object_id_t vlan_member_oid, const sai_thrift_attribute_t& attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t sai_attr;

    sai_vlan_api_t *vlan_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_VLAN), (void **)&vlan_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);

    sai_thrift_parse_vlan_member_attributes(attr_vec, &sai_attr);

    if (vlan_api->set_vlan_member_attribute == (void *)0) {
        std::cerr << "NULL ptr: vlan_api->set_vlan_member_attribute" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = vlan_api->set_vlan_member_attribute((sai_object_id_t)vlan_member_oid, &sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_get_vlan_member_attribute(sai_thrift_attribute_list_t& attr_list_out, const sai_thrift_object_id_t vlan_member_oid, const sai_thrift_attribute_list_t& attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_vlan_api_t *vlan_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_VLAN), (void **)&vlan_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    else {
      return;
    }


    const std::vector<sai_thrift_attribute_t> &attr_list_vec = attr_list.attr_list;

    sai_thrift_parse_vlan_member_attributes(attr_list_vec, sai_attr_list);

    if (vlan_api->get_vlan_member_attribute == (void *)0) {
        std::cerr << "NULL ptr: vlan_api->get_vlan_member_attribute" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = vlan_api->get_vlan_member_attribute((sai_object_id_t)vlan_member_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_vlan_member_attributes(sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  void sai_thrift_get_vlan_stats(std::vector<sai_thrift_uint64_t> & counters_out, const sai_thrift_object_id_t vlan_oid, const std::vector<sai_thrift_stat_id_t> & counter_ids) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_vlan_api_t *vlan_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_VLAN), (void **)&vlan_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_stat_id_t *sai_counter_ids = NULL;
    uint32_t number_of_counters = counter_ids.size();

    if (number_of_counters != 0) {
      sai_counter_ids = (sai_stat_id_t *)malloc(sizeof(sai_stat_id_t) * number_of_counters);
    }
    else {
      return;
    }


    std::vector<sai_thrift_stat_id_t>::const_iterator it = counter_ids.begin();
    for (uint32_t i = 0; i < counter_ids.size(); i++, it++) {
      sai_counter_ids[i] = (sai_stat_id_t)*it;
    }

    uint64_t *sai_counters = NULL;
    if (number_of_counters != 0) {
      sai_counters = (uint64_t *)malloc(sizeof(uint64_t) * number_of_counters);
    }

    if (vlan_api->get_vlan_stats == (void *)0) {
        std::cerr << "NULL ptr: vlan_api->get_vlan_stats" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = vlan_api->get_vlan_stats((sai_object_id_t)vlan_oid, number_of_counters, sai_counter_ids, sai_counters);

    // sai_adapter always takes all vlan stats. Since some of them may be
    // not supported, SAI_STATUS_INVALID_PARAMETER should not be raised.
    if (status != SAI_STATUS_SUCCESS && status != SAI_STATUS_INVALID_PARAMETER) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_counter_ids);
    for (uint32_t i = 0; i < (uint32_t)number_of_counters; i++) {
      counters_out.push_back((sai_thrift_uint64_t)sai_counters[i]);
    }
    free(sai_counters);
    return;
  }

  void sai_thrift_get_vlan_stats_ext(std::vector<sai_thrift_uint64_t> & counters_out, const sai_thrift_object_id_t vlan_oid, const std::vector<sai_thrift_stat_id_t> & counter_ids, const sai_thrift_stats_mode_t mode) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_vlan_api_t *vlan_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_VLAN), (void **)&vlan_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_stat_id_t *sai_counter_ids = NULL;
    uint32_t number_of_counters = counter_ids.size();

    if (number_of_counters != 0) {
      sai_counter_ids = (sai_stat_id_t *)malloc(sizeof(sai_stat_id_t) * number_of_counters);
    }
    else {
      return;
    }


    std::vector<sai_thrift_stat_id_t>::const_iterator it = counter_ids.begin();
    for (uint32_t i = 0; i < counter_ids.size(); i++, it++) {
      sai_counter_ids[i] = (sai_stat_id_t)*it;
    }

    uint64_t *sai_counters = NULL;
    if (number_of_counters != 0) {
      sai_counters = (uint64_t *)malloc(sizeof(uint64_t) * number_of_counters);
    }

    if (vlan_api->get_vlan_stats_ext == (void *)0) {
        std::cerr << "NULL ptr: vlan_api->get_vlan_stats_ext" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = vlan_api->get_vlan_stats_ext((sai_object_id_t)vlan_oid, number_of_counters, sai_counter_ids, (sai_stats_mode_t)mode, sai_counters);

    // sai_adapter always takes all vlan stats. Since some of them may be
    // not supported, SAI_STATUS_INVALID_PARAMETER should not be raised.
    if (status != SAI_STATUS_SUCCESS && status != SAI_STATUS_INVALID_PARAMETER) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_counter_ids);
    for (uint32_t i = 0; i < (uint32_t)number_of_counters; i++) {
      counters_out.push_back((sai_thrift_uint64_t)sai_counters[i]);
    }
    free(sai_counters);
    return;
  }

  void sai_thrift_clear_vlan_stats(const sai_thrift_object_id_t vlan_oid, const std::vector<sai_thrift_stat_id_t> & counter_ids) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_vlan_api_t *vlan_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_VLAN), (void **)&vlan_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_stat_id_t *sai_counter_ids = NULL;
    uint32_t number_of_counters = counter_ids.size();

    if (number_of_counters != 0) {
      sai_counter_ids = (sai_stat_id_t *)malloc(sizeof(sai_stat_id_t) * number_of_counters);
    }
    else {
      return;
    }


    std::vector<sai_thrift_stat_id_t>::const_iterator it = counter_ids.begin();
    for (uint32_t i = 0; i < counter_ids.size(); i++, it++) {
      sai_counter_ids[i] = (sai_stat_id_t)*it;
    }

    if (vlan_api->clear_vlan_stats == (void *)0) {
        std::cerr << "NULL ptr: vlan_api->clear_vlan_stats" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = vlan_api->clear_vlan_stats((sai_object_id_t)vlan_oid, number_of_counters, sai_counter_ids);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_counter_ids);
    return;
  }

  sai_thrift_object_id_t sai_thrift_create_wred(const std::vector<sai_thrift_attribute_t> & attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t wred_oid_out = SAI_NULL_OBJECT_ID;

    sai_wred_api_t *wred_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_WRED), (void **)&wred_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_wred_attributes(attr_list, sai_attr_list);

    if (wred_api->create_wred == (void *)0) {
        std::cerr << "NULL ptr: wred_api->create_wred" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = wred_api->create_wred(&wred_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);    return wred_oid_out;
  }

  void sai_thrift_remove_wred(const sai_thrift_object_id_t wred_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_wred_api_t *wred_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_WRED), (void **)&wred_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    if (wred_api->remove_wred == (void *)0) {
        std::cerr << "NULL ptr: wred_api->remove_wred" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = wred_api->remove_wred((sai_object_id_t)wred_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_wred_attribute(const sai_thrift_object_id_t wred_oid, const sai_thrift_attribute_t& attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t sai_attr;

    sai_wred_api_t *wred_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_WRED), (void **)&wred_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);

    sai_thrift_parse_wred_attributes(attr_vec, &sai_attr);

    if (wred_api->set_wred_attribute == (void *)0) {
        std::cerr << "NULL ptr: wred_api->set_wred_attribute" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = wred_api->set_wred_attribute((sai_object_id_t)wred_oid, &sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_get_wred_attribute(sai_thrift_attribute_list_t& attr_list_out, const sai_thrift_object_id_t wred_oid, const sai_thrift_attribute_list_t& attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_wred_api_t *wred_api;

    status = sai_api_query(static_cast<sai_api_t>(SAI_API_WRED), (void **)&wred_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    else {
      return;
    }


    const std::vector<sai_thrift_attribute_t> &attr_list_vec = attr_list.attr_list;

    sai_thrift_parse_wred_attributes(attr_list_vec, sai_attr_list);

    if (wred_api->get_wred_attribute == (void *)0) {
        std::cerr << "NULL ptr: wred_api->get_wred_attribute" << std::endl;
    
      sai_thrift_exception e;
      e.status = SAI_STATUS_NOT_IMPLEMENTED;
      throw e;
    }
    status = wred_api->get_wred_attribute((sai_object_id_t)wred_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_wred_attributes(sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  void sai_thrift_query_attribute_enum_values_capability(std::vector<int32_t> & _out, const sai_thrift_object_type_t object_type, const sai_thrift_attr_id_t attr_id, const int32_t caps_count) {

    // This function should be manually implemented elsewhere
    return;
  }

  int64_t sai_thrift_object_type_get_availability(const sai_thrift_object_type_t object_type, const sai_thrift_attr_id_t attr_id, const int32_t attr_type) {

    // This function should be manually implemented elsewhere
    return 0ULL;
  }

  sai_thrift_object_id_t sai_thrift_switch_id_query(const sai_thrift_object_id_t object_id) {

    // This function should be manually implemented elsewhere
    return SAI_NULL_OBJECT_ID;
  }

  sai_thrift_object_type_t sai_thrift_object_type_query(const sai_thrift_object_id_t object_id) {

    // This function should be manually implemented elsewhere
    return SAI_NULL_OBJECT_ID;
  }

  sai_thrift_status_t sai_thrift_api_uninitialize() {

    // This function should be manually implemented elsewhere
    return 0ULL;
  }

};


